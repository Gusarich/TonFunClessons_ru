import {
  require_nacl_fast
} from "./chunk-ITYDSQ43.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  import_buffer,
  import_process,
  init_shim
} from "./chunk-4B4YVQXQ.js";

// node_modules/symbol.inspect/index.js
var require_symbol = __commonJS({
  "node_modules/symbol.inspect/index.js"(exports, module) {
    "use strict";
    init_shim();
    var SymbolInspect = Symbol.for("nodejs.util.inspect.custom");
    module.exports = SymbolInspect;
  }
});

// node_modules/ton-core/dist/utils/crc16.js
var require_crc16 = __commonJS({
  "node_modules/ton-core/dist/utils/crc16.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crc16 = void 0;
    function crc16(data) {
      const poly = 4129;
      let reg = 0;
      const message = import_buffer.Buffer.alloc(data.length + 2);
      message.set(data);
      for (let byte of message) {
        let mask = 128;
        while (mask > 0) {
          reg <<= 1;
          if (byte & mask) {
            reg += 1;
          }
          mask >>= 1;
          if (reg > 65535) {
            reg &= 65535;
            reg ^= poly;
          }
        }
      }
      return import_buffer.Buffer.from([Math.floor(reg / 256), reg % 256]);
    }
    exports.crc16 = crc16;
  }
});

// node_modules/ton-core/dist/address/Address.js
var require_Address = __commonJS({
  "node_modules/ton-core/dist/address/Address.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.address = exports.Address = void 0;
    var symbol_inspect_1 = __importDefault(require_symbol());
    var crc16_1 = require_crc16();
    var bounceable_tag = 17;
    var non_bounceable_tag = 81;
    var test_flag = 128;
    function parseFriendlyAddress(src) {
      const data = import_buffer.Buffer.isBuffer(src) ? src : import_buffer.Buffer.from(src, "base64");
      if (data.length !== 36) {
        throw new Error("Unknown address type: byte length is not equal to 36");
      }
      const addr = data.subarray(0, 34);
      const crc = data.subarray(34, 36);
      const calcedCrc = (0, crc16_1.crc16)(addr);
      if (!(calcedCrc[0] === crc[0] && calcedCrc[1] === crc[1])) {
        throw new Error("Invalid checksum: " + src);
      }
      let tag = addr[0];
      let isTestOnly = false;
      let isBounceable = false;
      if (tag & test_flag) {
        isTestOnly = true;
        tag = tag ^ test_flag;
      }
      if (tag !== bounceable_tag && tag !== non_bounceable_tag)
        throw "Unknown address tag";
      isBounceable = tag === bounceable_tag;
      let workchain = null;
      if (addr[1] === 255) {
        workchain = -1;
      } else {
        workchain = addr[1];
      }
      const hashPart = addr.subarray(2, 34);
      return { isTestOnly, isBounceable, workchain, hashPart };
    }
    var Address = class {
      static isAddress(src) {
        return src instanceof Address;
      }
      static isFriendly(source) {
        return source.indexOf(":") < 0;
      }
      static normalize(source) {
        if (typeof source === "string") {
          return Address.parse(source).toString();
        } else {
          return source.toString();
        }
      }
      static parse(source) {
        if (Address.isFriendly(source)) {
          return this.parseFriendly(source).address;
        } else {
          return this.parseRaw(source);
        }
      }
      static parseRaw(source) {
        let workChain = parseInt(source.split(":")[0]);
        let hash = import_buffer.Buffer.from(source.split(":")[1], "hex");
        return new Address(workChain, hash);
      }
      static parseFriendly(source) {
        if (import_buffer.Buffer.isBuffer(source)) {
          let r = parseFriendlyAddress(source);
          return {
            isBounceable: r.isBounceable,
            isTestOnly: r.isTestOnly,
            address: new Address(r.workchain, r.hashPart)
          };
        } else {
          let addr = source.replace(/\-/g, "+").replace(/_/g, "/");
          let r = parseFriendlyAddress(addr);
          return {
            isBounceable: r.isBounceable,
            isTestOnly: r.isTestOnly,
            address: new Address(r.workchain, r.hashPart)
          };
        }
      }
      constructor(workChain, hash) {
        this.toRawString = () => {
          return this.workChain + ":" + this.hash.toString("hex");
        };
        this.toRaw = () => {
          const addressWithChecksum = import_buffer.Buffer.alloc(36);
          addressWithChecksum.set(this.hash);
          addressWithChecksum.set([this.workChain, this.workChain, this.workChain, this.workChain], 32);
          return addressWithChecksum;
        };
        this.toStringBuffer = (args) => {
          let testOnly = args && args.testOnly !== void 0 ? args.testOnly : false;
          let bounceable = args && args.bounceable !== void 0 ? args.bounceable : true;
          let tag = bounceable ? bounceable_tag : non_bounceable_tag;
          if (testOnly) {
            tag |= test_flag;
          }
          const addr = import_buffer.Buffer.alloc(34);
          addr[0] = tag;
          addr[1] = this.workChain;
          addr.set(this.hash, 2);
          const addressWithChecksum = import_buffer.Buffer.alloc(36);
          addressWithChecksum.set(addr);
          addressWithChecksum.set((0, crc16_1.crc16)(addr), 34);
          return addressWithChecksum;
        };
        this.toString = (args) => {
          let urlSafe = args && args.urlSafe !== void 0 ? args.urlSafe : true;
          let buffer = this.toStringBuffer(args);
          if (urlSafe) {
            return buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_");
          } else {
            return buffer.toString("base64");
          }
        };
        this[_a] = () => this.toString();
        this.workChain = workChain;
        this.hash = hash;
        Object.freeze(this);
      }
      equals(src) {
        if (src.workChain !== this.workChain) {
          return false;
        }
        return src.hash.equals(this.hash);
      }
    };
    exports.Address = Address;
    _a = symbol_inspect_1.default;
    function address(src) {
      return Address.parse(src);
    }
    exports.address = address;
  }
});

// node_modules/ton-core/dist/address/ExternalAddress.js
var require_ExternalAddress = __commonJS({
  "node_modules/ton-core/dist/address/ExternalAddress.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExternalAddress = void 0;
    var symbol_inspect_1 = __importDefault(require_symbol());
    var ExternalAddress = class {
      static isAddress(src) {
        return src instanceof ExternalAddress;
      }
      constructor(value, bits) {
        this[_a] = () => this.toString();
        this.value = value;
        this.bits = bits;
      }
      toString() {
        return `External<${this.bits}:${this.value}>`;
      }
    };
    exports.ExternalAddress = ExternalAddress;
    _a = symbol_inspect_1.default;
  }
});

// node_modules/ton-core/dist/utils/base32.js
var require_base32 = __commonJS({
  "node_modules/ton-core/dist/utils/base32.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.base32Decode = exports.base32Encode = void 0;
    var alphabet = "abcdefghijklmnopqrstuvwxyz234567";
    function base32Encode(buffer) {
      const length = buffer.byteLength;
      let bits = 0;
      let value = 0;
      let output = "";
      for (let i = 0; i < length; i++) {
        value = value << 8 | buffer[i];
        bits += 8;
        while (bits >= 5) {
          output += alphabet[value >>> bits - 5 & 31];
          bits -= 5;
        }
      }
      if (bits > 0) {
        output += alphabet[value << 5 - bits & 31];
      }
      return output;
    }
    exports.base32Encode = base32Encode;
    function readChar(alphabet2, char) {
      const idx = alphabet2.indexOf(char);
      if (idx === -1) {
        throw new Error("Invalid character found: " + char);
      }
      return idx;
    }
    function base32Decode(input) {
      let cleanedInput;
      cleanedInput = input.toLowerCase();
      const { length } = cleanedInput;
      let bits = 0;
      let value = 0;
      let index = 0;
      const output = import_buffer.Buffer.alloc(length * 5 / 8 | 0);
      for (let i = 0; i < length; i++) {
        value = value << 5 | readChar(alphabet, cleanedInput[i]);
        bits += 5;
        if (bits >= 8) {
          output[index++] = value >>> bits - 8 & 255;
          bits -= 8;
        }
      }
      return output;
    }
    exports.base32Decode = base32Decode;
  }
});

// node_modules/ton-core/dist/address/ADNLAddress.js
var require_ADNLAddress = __commonJS({
  "node_modules/ton-core/dist/address/ADNLAddress.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ADNLAddress = void 0;
    var symbol_inspect_1 = __importDefault(require_symbol());
    var base32_1 = require_base32();
    var crc16_1 = require_crc16();
    var ADNLAddress = class {
      static parseFriendly(src) {
        if (src.length !== 55) {
          throw Error("Invalid address");
        }
        src = "f" + src;
        let decoded = (0, base32_1.base32Decode)(src);
        if (decoded[0] !== 45) {
          throw Error("Invalid address");
        }
        let gotHash = decoded.slice(33);
        let hash = (0, crc16_1.crc16)(decoded.slice(0, 33));
        if (!hash.equals(gotHash)) {
          throw Error("Invalid address");
        }
        return new ADNLAddress(decoded.slice(1, 33));
      }
      static parseRaw(src) {
        const data = import_buffer.Buffer.from(src, "base64");
        return new ADNLAddress(data);
      }
      constructor(address) {
        this.toRaw = () => {
          return this.address.toString("hex").toUpperCase();
        };
        this.toString = () => {
          let data = import_buffer.Buffer.concat([import_buffer.Buffer.from([45]), this.address]);
          let hash = (0, crc16_1.crc16)(data);
          data = import_buffer.Buffer.concat([data, hash]);
          return (0, base32_1.base32Encode)(data).slice(1);
        };
        this[_a] = () => this.toString();
        if (address.length !== 32) {
          throw Error("Invalid address");
        }
        this.address = address;
      }
      equals(b) {
        return this.address.equals(b.address);
      }
    };
    exports.ADNLAddress = ADNLAddress;
    _a = symbol_inspect_1.default;
  }
});

// node_modules/ton-core/dist/boc/utils/paddedBits.js
var require_paddedBits = __commonJS({
  "node_modules/ton-core/dist/boc/utils/paddedBits.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bitsToPaddedBuffer = void 0;
    var BitBuilder_1 = require_BitBuilder();
    function bitsToPaddedBuffer(bits) {
      let builder = new BitBuilder_1.BitBuilder(Math.ceil(bits.length / 8) * 8);
      builder.writeBits(bits);
      let padding = Math.ceil(bits.length / 8) * 8 - bits.length;
      for (let i = 0; i < padding; i++) {
        if (i === 0) {
          builder.writeBit(1);
        } else {
          builder.writeBit(0);
        }
      }
      return builder.buffer();
    }
    exports.bitsToPaddedBuffer = bitsToPaddedBuffer;
  }
});

// node_modules/ton-core/dist/boc/BitString.js
var require_BitString = __commonJS({
  "node_modules/ton-core/dist/boc/BitString.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitString = void 0;
    var paddedBits_1 = require_paddedBits();
    var symbol_inspect_1 = __importDefault(require_symbol());
    var BitString = class {
      /**
       * Constructing BitString from a buffer
       * @param data data that contains the bitstring data. NOTE: We are expecting this buffer to be NOT modified
       * @param offset offset in bits from the start of the buffer
       * @param length length of the bitstring in bits
       */
      constructor(data, offset, length) {
        this[_a] = () => this.toString();
        if (length < 0) {
          throw new Error(`Length ${length} is out of bounds`);
        }
        this._length = length;
        this._data = data;
        this._offset = offset;
      }
      /**
       * Returns the length of the bitstring
       */
      get length() {
        return this._length;
      }
      /**
       * Returns the bit at the specified index
       * @param index index of the bit
       * @throws Error if index is out of bounds
       * @returns true if the bit is set, false otherwise
       */
      at(index) {
        if (index >= this._length) {
          throw new Error(`Index ${index} > ${this._length} is out of bounds`);
        }
        if (index < 0) {
          throw new Error(`Index ${index} < 0 is out of bounds`);
        }
        let byteIndex = this._offset + index >> 3;
        let bitIndex = 7 - (this._offset + index) % 8;
        return (this._data[byteIndex] & 1 << bitIndex) !== 0;
      }
      /**
       * Get a subscring of the bitstring
       * @param offset
       * @param length
       * @returns
       */
      substring(offset, length) {
        if (length === 0 && offset === this._length) {
          return BitString.EMPTY;
        }
        if (offset >= this._length) {
          throw new Error(`Offset(${offset}) > ${this._length} is out of bounds`);
        }
        if (offset < 0) {
          throw new Error(`Offset(${offset}) < 0 is out of bounds`);
        }
        if (offset + length > this._length) {
          throw new Error(`Offset ${offset} + Length ${length} > ${this._length} is out of bounds`);
        }
        return new BitString(this._data, this._offset + offset, length);
      }
      /**
       * Try to get a buffer from the bitstring without allocations
       * @param offset offset in bits
       * @param length length in bits
       * @returns buffer if the bitstring is aligned to bytes, null otherwise
       */
      subbuffer(offset, length) {
        if (offset >= this._length) {
          throw new Error(`Offset ${offset} is out of bounds`);
        }
        if (offset < 0) {
          throw new Error(`Offset ${offset} is out of bounds`);
        }
        if (offset + length > this._length) {
          throw new Error(`Offset + Lenght = ${offset + length} is out of bounds`);
        }
        if (length % 8 !== 0) {
          return null;
        }
        if ((this._offset + offset) % 8 !== 0) {
          return null;
        }
        let start = this._offset + offset >> 3;
        let end = start + (length >> 3);
        return this._data.subarray(start, end);
      }
      /**
       * Checks for equality
       * @param b other bitstring
       * @returns true if the bitstrings are equal, false otherwise
       */
      equals(b) {
        if (this._length !== b._length) {
          return false;
        }
        for (let i = 0; i < this._length; i++) {
          if (this.at(i) !== b.at(i)) {
            return false;
          }
        }
        return true;
      }
      /**
       * Format to canonical string
       * @returns formatted bits as a string
       */
      toString() {
        const padded = (0, paddedBits_1.bitsToPaddedBuffer)(this);
        if (this._length % 4 === 0) {
          const s = padded.subarray(0, Math.ceil(this._length / 8)).toString("hex").toUpperCase();
          if (this._length % 8 === 0) {
            return s;
          } else {
            return s.substring(0, s.length - 1);
          }
        } else {
          const hex = padded.toString("hex").toUpperCase();
          if (this._length % 8 <= 4) {
            return hex.substring(0, hex.length - 1) + "_";
          } else {
            return hex + "_";
          }
        }
      }
    };
    exports.BitString = BitString;
    _a = symbol_inspect_1.default;
    BitString.EMPTY = new BitString(import_buffer.Buffer.alloc(0), 0, 0);
  }
});

// node_modules/ton-core/dist/boc/BitBuilder.js
var require_BitBuilder = __commonJS({
  "node_modules/ton-core/dist/boc/BitBuilder.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitBuilder = void 0;
    var Address_1 = require_Address();
    var ExternalAddress_1 = require_ExternalAddress();
    var BitString_1 = require_BitString();
    var BitBuilder = class {
      constructor(size4 = 1023) {
        this._buffer = import_buffer.Buffer.alloc(Math.ceil(size4 / 8));
        this._length = 0;
      }
      /**
       * Current number of bits written
       */
      get length() {
        return this._length;
      }
      /**
       * Write a single bit
       * @param value bit to write, true or positive number for 1, false or zero or negative for 0
       */
      writeBit(value) {
        let n = this._length;
        if (n > this._buffer.length * 8) {
          throw new Error("BitBuilder overflow");
        }
        if (value === true || value > 0) {
          this._buffer[n / 8 | 0] |= 1 << 7 - n % 8;
        }
        this._length++;
      }
      /**
       * Copy bits from BitString
       * @param src source bits
       */
      writeBits(src) {
        for (let i = 0; i < src.length; i++) {
          this.writeBit(src.at(i));
        }
      }
      /**
       * Write bits from buffer
       * @param src source buffer
       */
      writeBuffer(src) {
        if (this._length % 8 === 0) {
          if (this._length + src.length * 8 > this._buffer.length * 8) {
            throw new Error("BitBuilder overflow");
          }
          src.copy(this._buffer, this._length / 8);
          this._length += src.length * 8;
        } else {
          for (let i = 0; i < src.length; i++) {
            this.writeUint(src[i], 8);
          }
        }
      }
      /**
       * Write uint value
       * @param value value as bigint or number
       * @param bits number of bits to write
       */
      writeUint(value, bits) {
        if (bits === 8 && this._length % 8 === 0) {
          let v2 = Number(value);
          if (v2 < 0 || v2 > 255 || !Number.isSafeInteger(v2)) {
            throw Error(`value is out of range for ${bits} bits. Got ${value}`);
          }
          this._buffer[this._length / 8] = Number(value);
          this._length += 8;
          return;
        }
        if (bits === 16 && this._length % 8 === 0) {
          let v2 = Number(value);
          if (v2 < 0 || v2 > 65536 || !Number.isSafeInteger(v2)) {
            throw Error(`value is out of range for ${bits} bits. Got ${value}`);
          }
          this._buffer[this._length / 8] = v2 >> 8;
          this._buffer[this._length / 8 + 1] = v2 & 255;
          this._length += 16;
          return;
        }
        let v = BigInt(value);
        if (bits < 0 || !Number.isSafeInteger(bits)) {
          throw Error(`invalid bit length. Got ${bits}`);
        }
        if (bits === 0) {
          if (value !== 0n) {
            throw Error(`value is not zero for ${bits} bits. Got ${value}`);
          } else {
            return;
          }
        }
        let vBits = 1n << BigInt(bits);
        if (v < 0 || v >= vBits) {
          throw Error(`bitLength is too small for a value ${value}. Got ${bits}`);
        }
        let b = [];
        while (v > 0) {
          b.push(v % 2n === 1n);
          v /= 2n;
        }
        for (let i = 0; i < bits; i++) {
          let off = bits - i - 1;
          if (off < b.length) {
            this.writeBit(b[off]);
          } else {
            this.writeBit(false);
          }
        }
      }
      /**
       * Write int value
       * @param value value as bigint or number
       * @param bits number of bits to write
       */
      writeInt(value, bits) {
        let v = BigInt(value);
        if (bits < 0 || !Number.isSafeInteger(bits)) {
          throw Error(`invalid bit length. Got ${bits}`);
        }
        if (bits === 0) {
          if (value !== 0n) {
            throw Error(`value is not zero for ${bits} bits. Got ${value}`);
          } else {
            return;
          }
        }
        if (bits === 1) {
          if (value !== -1n && value !== 0n) {
            throw Error(`value is not zero or -1 for ${bits} bits. Got ${value}`);
          } else {
            this.writeBit(value === -1n);
            return;
          }
        }
        let vBits = 1n << BigInt(bits) - 1n;
        if (v < -vBits || v >= vBits) {
          throw Error(`value is out of range for ${bits} bits. Got ${value}`);
        }
        if (v < 0) {
          this.writeBit(true);
          v = (1n << BigInt(bits) - 1n) + v;
        } else {
          this.writeBit(false);
        }
        this.writeUint(v, bits - 1);
      }
      /**
       * Wrtie var uint value, used for serializing coins
       * @param value value to write as bigint or number
       * @param bits header bits to write size
       */
      writeVarUint(value, bits) {
        let v = BigInt(value);
        if (bits < 0 || !Number.isSafeInteger(bits)) {
          throw Error(`invalid bit length. Got ${bits}`);
        }
        if (v < 0) {
          throw Error(`value is negative. Got ${value}`);
        }
        if (v === 0n) {
          this.writeUint(0, bits);
          return;
        }
        const sizeBytes = Math.ceil(v.toString(2).length / 8);
        const sizeBits = sizeBytes * 8;
        this.writeUint(sizeBytes, bits);
        this.writeUint(v, sizeBits);
      }
      /**
       * Wrtie var int value, used for serializing coins
       * @param value value to write as bigint or number
       * @param bits header bits to write size
       */
      writeVarInt(value, bits) {
        let v = BigInt(value);
        if (bits < 0 || !Number.isSafeInteger(bits)) {
          throw Error(`invalid bit length. Got ${bits}`);
        }
        if (v === 0n) {
          this.writeUint(0, bits);
          return;
        }
        let v2 = v > 0 ? v : -v;
        const sizeBytes = 1 + Math.ceil(v2.toString(2).length / 8);
        const sizeBits = sizeBytes * 8;
        this.writeUint(sizeBytes, bits);
        this.writeInt(v, sizeBits);
      }
      /**
       * Write coins in var uint format
       * @param amount amount to write
       */
      writeCoins(amount) {
        this.writeVarUint(amount, 4);
      }
      /**
       * Write address
       * @param address write address or address external
       */
      writeAddress(address) {
        if (address === null || address === void 0) {
          this.writeUint(0, 2);
          return;
        }
        if (Address_1.Address.isAddress(address)) {
          this.writeUint(2, 2);
          this.writeUint(0, 1);
          this.writeInt(address.workChain, 8);
          this.writeBuffer(address.hash);
          return;
        }
        if (ExternalAddress_1.ExternalAddress.isAddress(address)) {
          this.writeUint(1, 2);
          this.writeUint(address.bits, 9);
          this.writeUint(address.value, address.bits);
          return;
        }
        throw Error(`Invalid address. Got ${address}`);
      }
      /**
       * Build BitString
       * @returns result bit string
       */
      build() {
        return new BitString_1.BitString(this._buffer, 0, this._length);
      }
      /**
       * Build into Buffer
       * @returns result buffer
       */
      buffer() {
        if (this._length % 8 !== 0) {
          throw new Error("BitBuilder buffer is not byte aligned");
        }
        return this._buffer.subarray(0, this._length / 8);
      }
    };
    exports.BitBuilder = BitBuilder;
  }
});

// node_modules/ton-core/dist/boc/CellType.js
var require_CellType = __commonJS({
  "node_modules/ton-core/dist/boc/CellType.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CellType = void 0;
    var CellType;
    (function(CellType2) {
      CellType2[CellType2["Ordinary"] = -1] = "Ordinary";
      CellType2[CellType2["PrunedBranch"] = 1] = "PrunedBranch";
      CellType2[CellType2["Library"] = 2] = "Library";
      CellType2[CellType2["MerkleProof"] = 3] = "MerkleProof";
      CellType2[CellType2["MerkleUpdate"] = 4] = "MerkleUpdate";
    })(CellType = exports.CellType || (exports.CellType = {}));
  }
});

// node_modules/ton-core/dist/dict/parseDict.js
var require_parseDict = __commonJS({
  "node_modules/ton-core/dist/dict/parseDict.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseDict = void 0;
    function readUnaryLength(slice) {
      let res = 0;
      while (slice.loadBit()) {
        res++;
      }
      return res;
    }
    function doParse(prefix, slice, n, res, extractor) {
      let lb0 = slice.loadBit() ? 1 : 0;
      let prefixLength = 0;
      let pp = prefix;
      if (lb0 === 0) {
        prefixLength = readUnaryLength(slice);
        for (let i = 0; i < prefixLength; i++) {
          pp += slice.loadBit() ? "1" : "0";
        }
      } else {
        let lb1 = slice.loadBit() ? 1 : 0;
        if (lb1 === 0) {
          prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
          for (let i = 0; i < prefixLength; i++) {
            pp += slice.loadBit() ? "1" : "0";
          }
        } else {
          let bit = slice.loadBit() ? "1" : "0";
          prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
          for (let i = 0; i < prefixLength; i++) {
            pp += bit;
          }
        }
      }
      if (n - prefixLength === 0) {
        res.set(BigInt("0b" + pp), extractor(slice));
      } else {
        let left4 = slice.loadRef();
        let right4 = slice.loadRef();
        if (!left4.isExotic) {
          doParse(pp + "0", left4.beginParse(), n - prefixLength - 1, res, extractor);
        }
        if (!right4.isExotic) {
          doParse(pp + "1", right4.beginParse(), n - prefixLength - 1, res, extractor);
        }
      }
    }
    function parseDict(sc, keySize, extractor) {
      let res = /* @__PURE__ */ new Map();
      if (sc) {
        doParse("", sc, keySize, res, extractor);
      }
      return res;
    }
    exports.parseDict = parseDict;
  }
});

// node_modules/ton-core/dist/dict/utils/findCommonPrefix.js
var require_findCommonPrefix = __commonJS({
  "node_modules/ton-core/dist/dict/utils/findCommonPrefix.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findCommonPrefix = void 0;
    function findCommonPrefix(src) {
      if (src.length === 0) {
        return "";
      }
      if (src.length === 1) {
        return src[0];
      }
      const sorted = [...src].sort();
      let size4 = 0;
      for (let i = 0; i < sorted[0].length; i++) {
        if (sorted[0][i] !== sorted[sorted.length - 1][i]) {
          break;
        }
        size4++;
      }
      return src[0].slice(0, size4);
    }
    exports.findCommonPrefix = findCommonPrefix;
  }
});

// node_modules/ton-core/dist/dict/serializeDict.js
var require_serializeDict = __commonJS({
  "node_modules/ton-core/dist/dict/serializeDict.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeDict = exports.detectLabelType = exports.writeLabelSame = exports.writeLabelLong = exports.writeLabelShort = exports.buildTree = void 0;
    var Builder_1 = require_Builder();
    var findCommonPrefix_1 = require_findCommonPrefix();
    function pad(src, size4) {
      while (src.length < size4) {
        src = "0" + src;
      }
      return src;
    }
    function removePrefixMap(src, length) {
      if (length === 0) {
        return src;
      } else {
        let res = /* @__PURE__ */ new Map();
        for (let k of src.keys()) {
          let d = src.get(k);
          res.set(k.slice(length), d);
        }
        return res;
      }
    }
    function forkMap(src) {
      if (src.size === 0) {
        throw Error("Internal inconsistency");
      }
      let left4 = /* @__PURE__ */ new Map();
      let right4 = /* @__PURE__ */ new Map();
      for (let k of src.keys()) {
        let d = src.get(k);
        if (k.startsWith("0")) {
          left4.set(k.substr(1), d);
        } else {
          right4.set(k.substr(1), d);
        }
      }
      if (left4.size === 0) {
        throw Error("Internal inconsistency. Left emtpy.");
      }
      if (right4.size === 0) {
        throw Error("Internal inconsistency. Right emtpy.");
      }
      return { left: left4, right: right4 };
    }
    function buildNode(src) {
      if (src.size === 0) {
        throw Error("Internal inconsistency");
      }
      if (src.size === 1) {
        return { type: "leaf", value: Array.from(src.values())[0] };
      }
      let { left: left4, right: right4 } = forkMap(src);
      return {
        type: "fork",
        left: buildEdge(left4),
        right: buildEdge(right4)
      };
    }
    function buildEdge(src) {
      if (src.size === 0) {
        throw Error("Internal inconsistency");
      }
      const label = (0, findCommonPrefix_1.findCommonPrefix)(Array.from(src.keys()));
      return { label, node: buildNode(removePrefixMap(src, label.length)) };
    }
    function buildTree(src, keyLength) {
      let converted = /* @__PURE__ */ new Map();
      for (let k of Array.from(src.keys())) {
        const padded = pad(k.toString(2), keyLength);
        converted.set(padded, src.get(k));
      }
      return buildEdge(converted);
    }
    exports.buildTree = buildTree;
    function writeLabelShort(src, to) {
      to.storeBit(0);
      for (let i = 0; i < src.length; i++) {
        to.storeBit(1);
      }
      to.storeBit(0);
      for (let i = 0; i < src.length; i++) {
        to.storeBit(src[i] === "1");
      }
      return to;
    }
    exports.writeLabelShort = writeLabelShort;
    function labelShortLength(src) {
      return 1 + src.length + 1 + src.length;
    }
    function writeLabelLong(src, keyLength, to) {
      to.storeBit(1);
      to.storeBit(0);
      let length = Math.ceil(Math.log2(keyLength + 1));
      to.storeUint(src.length, length);
      for (let i = 0; i < src.length; i++) {
        to.storeBit(src[i] === "1");
      }
      return to;
    }
    exports.writeLabelLong = writeLabelLong;
    function labelLongLength(src, keyLength) {
      return 1 + 1 + Math.ceil(Math.log2(keyLength + 1)) + src.length;
    }
    function writeLabelSame(value, length, keyLength, to) {
      to.storeBit(1);
      to.storeBit(1);
      to.storeBit(value);
      let lenLen = Math.ceil(Math.log2(keyLength + 1));
      to.storeUint(length, lenLen);
    }
    exports.writeLabelSame = writeLabelSame;
    function labelSameLength(keyLength) {
      return 1 + 1 + 1 + Math.ceil(Math.log2(keyLength + 1));
    }
    function isSame(src) {
      if (src.length === 0 || src.length === 1) {
        return true;
      }
      for (let i = 1; i < src.length; i++) {
        if (src[i] !== src[0]) {
          return false;
        }
      }
      return true;
    }
    function detectLabelType(src, keyLength) {
      let kind = "short";
      let kindLength = labelShortLength(src);
      let longLength = labelLongLength(src, keyLength);
      if (longLength < kindLength) {
        kindLength = longLength;
        kind = "long";
      }
      if (isSame(src)) {
        let sameLength = labelSameLength(keyLength);
        if (sameLength < kindLength) {
          kindLength = sameLength;
          kind = "same";
        }
      }
      return kind;
    }
    exports.detectLabelType = detectLabelType;
    function writeLabel(src, keyLength, to) {
      let type2 = detectLabelType(src, keyLength);
      if (type2 === "short") {
        writeLabelShort(src, to);
      }
      if (type2 === "long") {
        writeLabelLong(src, keyLength, to);
      }
      if (type2 === "same") {
        writeLabelSame(src[0] === "1", src.length, keyLength, to);
      }
    }
    function writeNode(src, keyLength, serializer, to) {
      if (src.type === "leaf") {
        serializer(src.value, to);
      }
      if (src.type === "fork") {
        const leftCell = (0, Builder_1.beginCell)();
        const rightCell = (0, Builder_1.beginCell)();
        writeEdge(src.left, keyLength - 1, serializer, leftCell);
        writeEdge(src.right, keyLength - 1, serializer, rightCell);
        to.storeRef(leftCell);
        to.storeRef(rightCell);
      }
    }
    function writeEdge(src, keyLength, serializer, to) {
      writeLabel(src.label, keyLength, to);
      writeNode(src.node, keyLength - src.label.length, serializer, to);
    }
    function serializeDict(src, keyLength, serializer, to) {
      const tree = buildTree(src, keyLength);
      writeEdge(tree, keyLength, serializer, to);
    }
    exports.serializeDict = serializeDict;
  }
});

// node_modules/ton-core/dist/dict/utils/internalKeySerializer.js
var require_internalKeySerializer = __commonJS({
  "node_modules/ton-core/dist/dict/utils/internalKeySerializer.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deserializeInternalKey = exports.serializeInternalKey = void 0;
    var Address_1 = require_Address();
    function serializeInternalKey(value) {
      if (typeof value === "number") {
        if (!Number.isSafeInteger(value)) {
          throw Error("Invalid key type: not a safe integer: " + value);
        }
        return "n:" + value.toString(10);
      } else if (typeof value === "bigint") {
        return "b:" + value.toString(10);
      } else if (Address_1.Address.isAddress(value)) {
        return "a:" + value.toString();
      } else if (import_buffer.Buffer.isBuffer(value)) {
        return "f:" + value.toString("hex");
      } else {
        throw Error("Invalid key type");
      }
    }
    exports.serializeInternalKey = serializeInternalKey;
    function deserializeInternalKey(value) {
      let k = value.slice(0, 2);
      let v = value.slice(2);
      if (k === "n:") {
        return parseInt(v, 10);
      } else if (k === "b:") {
        return BigInt(v);
      } else if (k === "a:") {
        return Address_1.Address.parse(v);
      } else if (k === "f:") {
        return import_buffer.Buffer.from(v, "hex");
      }
      throw Error("Invalid key type: " + k);
    }
    exports.deserializeInternalKey = deserializeInternalKey;
  }
});

// node_modules/ton-core/dist/dict/Dictionary.js
var require_Dictionary = __commonJS({
  "node_modules/ton-core/dist/dict/Dictionary.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Dictionary = void 0;
    var Address_1 = require_Address();
    var Builder_1 = require_Builder();
    var Cell_1 = require_Cell();
    var parseDict_1 = require_parseDict();
    var serializeDict_1 = require_serializeDict();
    var internalKeySerializer_1 = require_internalKeySerializer();
    var Dictionary2 = class {
      /**
       * Create an empty map
       * @param key key type
       * @param value value type
       * @returns Dictionary<K, V>
       */
      static empty(key, value) {
        if (key && value) {
          return new Dictionary2(/* @__PURE__ */ new Map(), key, value);
        } else {
          return new Dictionary2(/* @__PURE__ */ new Map(), null, null);
        }
      }
      /**
       * Load dictionary from slice
       * @param key key description
       * @param value value description
       * @param src slice
       * @returns Dictionary<K, V>
       */
      static load(key, value, sc) {
        let slice;
        if (sc instanceof Cell_1.Cell) {
          if (sc.isExotic) {
            return Dictionary2.empty(key, value);
          }
          slice = sc.beginParse();
        } else {
          slice = sc;
        }
        let cell = slice.loadMaybeRef();
        if (cell && !cell.isExotic) {
          return Dictionary2.loadDirect(key, value, cell.beginParse());
        } else {
          return Dictionary2.empty(key, value);
        }
      }
      /**
       * Low level method for rare dictionaries from system contracts.
       * Loads dictionary from slice directly without going to the ref.
       *
       * @param key key description
       * @param value value description
       * @param sc slice
       * @returns Dictionary<K, V>
       */
      static loadDirect(key, value, sc) {
        if (!sc) {
          return Dictionary2.empty(key, value);
        }
        let slice;
        if (sc instanceof Cell_1.Cell) {
          slice = sc.beginParse();
        } else {
          slice = sc;
        }
        let values = (0, parseDict_1.parseDict)(slice, key.bits, value.parse);
        let prepare = /* @__PURE__ */ new Map();
        for (let [k, v] of values) {
          prepare.set((0, internalKeySerializer_1.serializeInternalKey)(key.parse(k)), v);
        }
        return new Dictionary2(prepare, key, value);
      }
      constructor(values, key, value) {
        this._key = key;
        this._value = value;
        this._map = values;
      }
      get size() {
        return this._map.size;
      }
      get(key) {
        return this._map.get((0, internalKeySerializer_1.serializeInternalKey)(key));
      }
      has(key) {
        return this._map.has((0, internalKeySerializer_1.serializeInternalKey)(key));
      }
      set(key, value) {
        this._map.set((0, internalKeySerializer_1.serializeInternalKey)(key), value);
        return this;
      }
      delete(key) {
        const k = (0, internalKeySerializer_1.serializeInternalKey)(key);
        return this._map.delete(k);
      }
      clear() {
        this._map.clear();
      }
      *[Symbol.iterator]() {
        for (const [k, v] of this._map) {
          const key = (0, internalKeySerializer_1.deserializeInternalKey)(k);
          yield [key, v];
        }
      }
      keys() {
        return Array.from(this._map.keys()).map((v) => (0, internalKeySerializer_1.deserializeInternalKey)(v));
      }
      values() {
        return Array.from(this._map.values());
      }
      store(builder, key, value) {
        if (this._map.size === 0) {
          builder.storeBit(0);
        } else {
          let resolvedKey = this._key;
          if (key !== null && key !== void 0) {
            resolvedKey = key;
          }
          let resolvedValue = this._value;
          if (value !== null && value !== void 0) {
            resolvedValue = value;
          }
          if (!resolvedKey) {
            throw Error("Key serializer is not defined");
          }
          if (!resolvedValue) {
            throw Error("Value serializer is not defined");
          }
          let prepared = /* @__PURE__ */ new Map();
          for (const [k, v] of this._map) {
            prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k)), v);
          }
          builder.storeBit(1);
          let dd = (0, Builder_1.beginCell)();
          (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, dd);
          builder.storeRef(dd.endCell());
        }
      }
      storeDirect(builder, key, value) {
        if (this._map.size === 0) {
          throw Error("Cannot store empty dictionary directly");
        }
        let resolvedKey = this._key;
        if (key !== null && key !== void 0) {
          resolvedKey = key;
        }
        let resolvedValue = this._value;
        if (value !== null && value !== void 0) {
          resolvedValue = value;
        }
        if (!resolvedKey) {
          throw Error("Key serializer is not defined");
        }
        if (!resolvedValue) {
          throw Error("Value serializer is not defined");
        }
        let prepared = /* @__PURE__ */ new Map();
        for (const [k, v] of this._map) {
          prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k)), v);
        }
        (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, builder);
      }
    };
    exports.Dictionary = Dictionary2;
    Dictionary2.Keys = {
      /**
       * Standard address key
       * @returns DictionaryKey<Address>
       */
      Address: () => {
        return createAddressKey();
      },
      /**
       * Create standard big integer key
       * @param bits number of bits
       * @returns DictionaryKey<bigint>
       */
      BigInt: (bits) => {
        return createBigIntKey(bits);
      },
      /**
       * Create integer key
       * @param bits bits of integer
       * @returns DictionaryKey<number>
       */
      Int: (bits) => {
        return createIntKey(bits);
      },
      /**
       * Create standard unsigned big integer key
       * @param bits number of bits
       * @returns DictionaryKey<bigint>
       */
      BigUint: (bits) => {
        return createBigUintKey(bits);
      },
      /**
       * Create standard unsigned integer key
       * @param bits number of bits
       * @returns DictionaryKey<number>
       */
      Uint: (bits) => {
        return createUintKey(bits);
      },
      /**
       * Create standard buffer key
       * @param bytes number of bytes of a buffer
       * @returns DictionaryKey<Buffer>
       */
      Buffer: (bytes) => {
        return createBufferKey(bytes);
      }
    };
    Dictionary2.Values = {
      /**
       * Create standard integer value
       * @returns DictionaryValue<bigint>
       */
      BigInt: (bits) => {
        return createBigIntValue(bits);
      },
      /**
       * Create standard integer value
       * @returns DictionaryValue<number>
       */
      Int: (bits) => {
        return createIntValue(bits);
      },
      /**
       * Create big var int
       * @param bits nubmer of header bits
       * @returns DictionaryValue<bigint>
       */
      BigVarInt: (bits) => {
        return createBigVarIntValue(bits);
      },
      /**
       * Create standard unsigned integer value
       * @param bits number of bits
       * @returns DictionaryValue<bigint>
       */
      BigUint: (bits) => {
        return createBigUintValue(bits);
      },
      /**
       * Create standard unsigned integer value
       * @param bits number of bits
       * @returns DictionaryValue<bigint>
       */
      Uint: (bits) => {
        return createUintValue(bits);
      },
      /**
       * Create big var int
       * @param bits nubmer of header bits
       * @returns DictionaryValue<bigint>
       */
      BigVarUint: (bits) => {
        return createBigVarUintValue(bits);
      },
      /**
       * Create standard boolean value
       * @returns DictionaryValue<boolean>
       */
      Bool: () => {
        return createBooleanValue();
      },
      /**
       * Create standard address value
       * @returns DictionaryValue<Address>
       */
      Address: () => {
        return createAddressValue();
      },
      /**
       * Create standard cell value
       * @returns DictionaryValue<Cell>
       */
      Cell: () => {
        return createCellValue();
      },
      /**
       * Create Builder value
       * @param bytes number of bytes of a buffer
       * @returns DictionaryValue<Builder>
       */
      Buffer: (bytes) => {
        return createBufferValue(bytes);
      },
      /**
       * Create dictionary value
       * @param key
       * @param value
       */
      Dictionary: (key, value) => {
        return createDictionaryValue(key, value);
      }
    };
    function createAddressKey() {
      return {
        bits: 267,
        serialize: (src) => {
          if (!Address_1.Address.isAddress(src)) {
            throw Error("Key is not an address");
          }
          return (0, Builder_1.beginCell)().storeAddress(src).endCell().beginParse().preloadUintBig(267);
        },
        parse: (src) => {
          return (0, Builder_1.beginCell)().storeUint(src, 267).endCell().beginParse().loadAddress();
        }
      };
    }
    function createBigIntKey(bits) {
      return {
        bits,
        serialize: (src) => {
          if (typeof src !== "bigint") {
            throw Error("Key is not a bigint");
          }
          return (0, Builder_1.beginCell)().storeInt(src, bits).endCell().beginParse().loadUintBig(bits);
        },
        parse: (src) => {
          return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadIntBig(bits);
        }
      };
    }
    function createIntKey(bits) {
      return {
        bits,
        serialize: (src) => {
          if (typeof src !== "number") {
            throw Error("Key is not a number");
          }
          if (!Number.isSafeInteger(src)) {
            throw Error("Key is not a safe integer: " + src);
          }
          return (0, Builder_1.beginCell)().storeInt(src, bits).endCell().beginParse().loadUintBig(bits);
        },
        parse: (src) => {
          return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadInt(bits);
        }
      };
    }
    function createBigUintKey(bits) {
      return {
        bits,
        serialize: (src) => {
          if (typeof src !== "bigint") {
            throw Error("Key is not a bigint");
          }
          if (src < 0) {
            throw Error("Key is negative: " + src);
          }
          return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
        },
        parse: (src) => {
          return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
        }
      };
    }
    function createUintKey(bits) {
      return {
        bits,
        serialize: (src) => {
          if (typeof src !== "number") {
            throw Error("Key is not a number");
          }
          if (!Number.isSafeInteger(src)) {
            throw Error("Key is not a safe integer: " + src);
          }
          if (src < 0) {
            throw Error("Key is negative: " + src);
          }
          return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
        },
        parse: (src) => {
          return Number((0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUint(bits));
        }
      };
    }
    function createBufferKey(bytes) {
      return {
        bits: bytes * 8,
        serialize: (src) => {
          if (!import_buffer.Buffer.isBuffer(src)) {
            throw Error("Key is not a buffer");
          }
          return (0, Builder_1.beginCell)().storeBuffer(src).endCell().beginParse().loadUintBig(bytes * 8);
        },
        parse: (src) => {
          return (0, Builder_1.beginCell)().storeUint(src, bytes * 8).endCell().beginParse().loadBuffer(bytes);
        }
      };
    }
    function createIntValue(bits) {
      return {
        serialize: (src, buidler) => {
          buidler.storeInt(src, bits);
        },
        parse: (src) => {
          return src.loadInt(bits);
        }
      };
    }
    function createBigIntValue(bits) {
      return {
        serialize: (src, buidler) => {
          buidler.storeInt(src, bits);
        },
        parse: (src) => {
          return src.loadIntBig(bits);
        }
      };
    }
    function createBigVarIntValue(bits) {
      return {
        serialize: (src, buidler) => {
          buidler.storeVarInt(src, bits);
        },
        parse: (src) => {
          return src.loadVarIntBig(bits);
        }
      };
    }
    function createBigVarUintValue(bits) {
      return {
        serialize: (src, buidler) => {
          buidler.storeVarUint(src, bits);
        },
        parse: (src) => {
          return src.loadVarUintBig(bits);
        }
      };
    }
    function createUintValue(bits) {
      return {
        serialize: (src, buidler) => {
          buidler.storeUint(src, bits);
        },
        parse: (src) => {
          return src.loadUint(bits);
        }
      };
    }
    function createBigUintValue(bits) {
      return {
        serialize: (src, buidler) => {
          buidler.storeUint(src, bits);
        },
        parse: (src) => {
          return src.loadUintBig(bits);
        }
      };
    }
    function createBooleanValue() {
      return {
        serialize: (src, buidler) => {
          buidler.storeBit(src);
        },
        parse: (src) => {
          return src.loadBit();
        }
      };
    }
    function createAddressValue() {
      return {
        serialize: (src, buidler) => {
          buidler.storeAddress(src);
        },
        parse: (src) => {
          return src.loadAddress();
        }
      };
    }
    function createCellValue() {
      return {
        serialize: (src, buidler) => {
          buidler.storeRef(src);
        },
        parse: (src) => {
          return src.loadRef();
        }
      };
    }
    function createDictionaryValue(key, value) {
      return {
        serialize: (src, buidler) => {
          src.store(buidler);
        },
        parse: (src) => {
          return Dictionary2.load(key, value, src);
        }
      };
    }
    function createBufferValue(size4) {
      return {
        serialize: (src, buidler) => {
          if (src.length !== size4) {
            throw Error("Invalid buffer size");
          }
          buidler.storeBuffer(src);
        },
        parse: (src) => {
          return src.loadBuffer(size4);
        }
      };
    }
  }
});

// node_modules/ton-core/dist/boc/utils/strings.js
var require_strings = __commonJS({
  "node_modules/ton-core/dist/boc/utils/strings.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.writeString = exports.stringToCell = exports.readString = void 0;
    var Builder_1 = require_Builder();
    function readBuffer(slice) {
      if (slice.remainingBits % 8 !== 0) {
        throw new Error(`Invalid string length: ${slice.remainingBits}`);
      }
      if (slice.remainingRefs !== 0 && slice.remainingRefs !== 1) {
        throw new Error(`invalid number of refs: ${slice.remainingRefs}`);
      }
      if (slice.remainingRefs === 1 && 1023 - slice.remainingBits > 7) {
        throw new Error(`invalid string length: ${slice.remainingBits / 8}`);
      }
      let res;
      if (slice.remainingBits === 0) {
        res = import_buffer.Buffer.alloc(0);
      } else {
        res = slice.loadBuffer(slice.remainingBits / 8);
      }
      if (slice.remainingRefs === 1) {
        res = import_buffer.Buffer.concat([res, readBuffer(slice.loadRef().beginParse())]);
      }
      return res;
    }
    function readString(slice) {
      return readBuffer(slice).toString();
    }
    exports.readString = readString;
    function writeBuffer(src, builder) {
      if (src.length > 0) {
        let bytes = Math.floor(builder.availableBits / 8);
        if (src.length > bytes) {
          let a = src.subarray(0, bytes);
          let t = src.subarray(bytes);
          builder = builder.storeBuffer(a);
          let bb = (0, Builder_1.beginCell)();
          writeBuffer(t, bb);
          builder = builder.storeRef(bb.endCell());
        } else {
          builder = builder.storeBuffer(src);
        }
      }
    }
    function stringToCell(src) {
      let builder = (0, Builder_1.beginCell)();
      writeBuffer(import_buffer.Buffer.from(src), builder);
      return builder.endCell();
    }
    exports.stringToCell = stringToCell;
    function writeString(src, builder) {
      writeBuffer(import_buffer.Buffer.from(src), builder);
    }
    exports.writeString = writeString;
  }
});

// node_modules/ton-core/dist/boc/Slice.js
var require_Slice = __commonJS({
  "node_modules/ton-core/dist/boc/Slice.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Slice = void 0;
    var symbol_inspect_1 = __importDefault(require_symbol());
    var Dictionary_1 = require_Dictionary();
    var Builder_1 = require_Builder();
    var strings_1 = require_strings();
    var Slice = class {
      constructor(reader, refs) {
        this[_a] = () => this.toString();
        this._reader = reader.clone();
        this._refs = [...refs];
      }
      /**
       * Get remaining bits
       */
      get remainingBits() {
        return this._reader.remaining;
      }
      /**
       * Get remaining refs
       */
      get remainingRefs() {
        return this._refs.length;
      }
      /**
       * Skip bits
       * @param bits
       */
      skip(bits) {
        this._reader.skip(bits);
        return this;
      }
      /**
       * Load a single bit
       * @returns true or false depending on the bit value
       */
      loadBit() {
        return this._reader.loadBit();
      }
      /**
       * Preload a signle bit
       * @returns true or false depending on the bit value
       */
      preloadBit() {
        return this._reader.preloadBit();
      }
      /**
       * Load a boolean
       * @returns true or false depending on the bit value
       */
      loadBoolean() {
        return this.loadBit();
      }
      /**
       * Load maybe boolean
       * @returns true or false depending on the bit value or null
       */
      loadMaybeBoolean() {
        if (this.loadBit()) {
          return this.loadBoolean();
        } else {
          return null;
        }
      }
      /**
       * Load bits as a new BitString
       * @param bits number of bits to read
       * @returns new BitString
       */
      loadBits(bits) {
        return this._reader.loadBits(bits);
      }
      /**
       * Preload bits as a new BitString
       * @param bits number of bits to read
       * @returns new BitString
       */
      preloadBits(bits) {
        return this._reader.preloadBits(bits);
      }
      /**
       * Load uint
       * @param bits number of bits to read
       * @returns uint value
       */
      loadUint(bits) {
        return this._reader.loadUint(bits);
      }
      /**
       * Load uint
       * @param bits number of bits to read
       * @returns uint value
       */
      loadUintBig(bits) {
        return this._reader.loadUintBig(bits);
      }
      /**
       * Preload uint
       * @param bits number of bits to read
       * @returns uint value
       */
      preloadUint(bits) {
        return this._reader.preloadUint(bits);
      }
      /**
       * Preload uint
       * @param bits number of bits to read
       * @returns uint value
       */
      preloadUintBig(bits) {
        return this._reader.preloadUintBig(bits);
      }
      /**
       * Load maybe uint
       * @param bits number of bits to read
       * @returns uint value or null
       */
      loadMaybeUint(bits) {
        if (this.loadBit()) {
          return this.loadUint(bits);
        } else {
          return null;
        }
      }
      /**
       * Load maybe uint
       * @param bits number of bits to read
       * @returns uint value or null
       */
      loadMaybeUintBig(bits) {
        if (this.loadBit()) {
          return this.loadUintBig(bits);
        } else {
          return null;
        }
      }
      /**
       * Load int
       * @param bits number of bits to read
       * @returns int value
       */
      loadInt(bits) {
        return this._reader.loadInt(bits);
      }
      /**
       * Load int
       * @param bits number of bits to read
       * @returns int value
       */
      loadIntBig(bits) {
        return this._reader.loadIntBig(bits);
      }
      /**
       * Preload int
       * @param bits number of bits to read
       * @returns int value
       */
      preloadInt(bits) {
        return this._reader.preloadInt(bits);
      }
      /**
       * Preload int
       * @param bits number of bits to read
       * @returns int value
       */
      preloadIntBig(bits) {
        return this._reader.preloadIntBig(bits);
      }
      /**
       * Load maybe uint
       * @param bits number of bits to read
       * @returns uint value or null
       */
      loadMaybeInt(bits) {
        if (this.loadBit()) {
          return this.loadInt(bits);
        } else {
          return null;
        }
      }
      /**
       * Load maybe uint
       * @param bits number of bits to read
       * @returns uint value or null
       */
      loadMaybeIntBig(bits) {
        if (this.loadBit()) {
          return this.loadIntBig(bits);
        } else {
          return null;
        }
      }
      /**
       * Load varuint
       * @param bits number of bits to read in header
       * @returns varuint value
       */
      loadVarUint(bits) {
        return this._reader.loadVarUint(bits);
      }
      /**
       * Load varuint
       * @param bits number of bits to read in header
       * @returns varuint value
       */
      loadVarUintBig(bits) {
        return this._reader.loadVarUintBig(bits);
      }
      /**
       * Preload varuint
       * @param bits number of bits to read in header
       * @returns varuint value
       */
      preloadVarUint(bits) {
        return this._reader.preloadVarUint(bits);
      }
      /**
       * Preload varuint
       * @param bits number of bits to read in header
       * @returns varuint value
       */
      preloadVarUintBig(bits) {
        return this._reader.preloadVarUintBig(bits);
      }
      /**
       * Load varint
       * @param bits number of bits to read in header
       * @returns varint value
       */
      loadVarInt(bits) {
        return this._reader.loadVarInt(bits);
      }
      /**
       * Load varint
       * @param bits number of bits to read in header
       * @returns varint value
       */
      loadVarIntBig(bits) {
        return this._reader.loadVarIntBig(bits);
      }
      /**
       * Preload varint
       * @param bits number of bits to read in header
       * @returns varint value
       */
      preloadVarInt(bits) {
        return this._reader.preloadVarInt(bits);
      }
      /**
       * Preload varint
       * @param bits number of bits to read in header
       * @returns varint value
       */
      preloadVarIntBig(bits) {
        return this._reader.preloadVarIntBig(bits);
      }
      /**
       * Load coins
       * @returns coins value
       */
      loadCoins() {
        return this._reader.loadCoins();
      }
      /**
       * Preload coins
       * @returns coins value
       */
      preloadCoins() {
        return this._reader.preloadCoins();
      }
      /**
       * Load maybe coins
       * @returns coins value or null
       */
      loadMaybeCoins() {
        if (this._reader.loadBit()) {
          return this._reader.loadCoins();
        } else {
          return null;
        }
      }
      /**
       * Load internal Address
       * @returns Address
       */
      loadAddress() {
        return this._reader.loadAddress();
      }
      /**
       * Load optional internal Address
       * @returns Address or null
       */
      loadMaybeAddress() {
        return this._reader.loadMaybeAddress();
      }
      /**
       * Load external address
       * @returns ExternalAddress
       */
      loadExternalAddress() {
        return this._reader.loadExternalAddress();
      }
      /**
       * Load optional external address
       * @returns ExternalAddress or null
       */
      loadMaybeExternalAddress() {
        return this._reader.loadMaybeExternalAddress();
      }
      /**
       * Load address
       * @returns Address, ExternalAddress or null
       */
      loadAddressAny() {
        return this._reader.loadAddressAny();
      }
      /**
       * Load reference
       * @returns Cell
       */
      loadRef() {
        if (this._refs.length === 0) {
          throw new Error("No more references");
        }
        return this._refs.shift();
      }
      /**
       * Preload reference
       * @returns Cell
       */
      preloadRef() {
        if (this._refs.length === 0) {
          throw new Error("No more references");
        }
        return this._refs[0];
      }
      /**
       * Load optional reference
       * @returns Cell or null
       */
      loadMaybeRef() {
        if (this.loadBit()) {
          return this.loadRef();
        } else {
          return null;
        }
      }
      /**
       * Preload optional reference
       * @returns Cell or null
       */
      preloadMaybeRef() {
        if (this.preloadBit()) {
          return this.preloadRef();
        } else {
          return null;
        }
      }
      /**
       * Load byte buffer
       * @param bytes number of bytes to load
       * @returns Buffer
       */
      loadBuffer(bytes) {
        return this._reader.loadBuffer(bytes);
      }
      /**
       * Load byte buffer
       * @param bytes number of bytes to load
       * @returns Buffer
       */
      preloadBuffer(bytes) {
        return this._reader.preloadBuffer(bytes);
      }
      /**
       * Load string tail
       */
      loadStringTail() {
        return (0, strings_1.readString)(this);
      }
      /**
       * Load maybe string tail
       * @returns string or null
       */
      loadMaybeStringTail() {
        if (this.loadBit()) {
          return (0, strings_1.readString)(this);
        } else {
          return null;
        }
      }
      /**
       * Load string tail from ref
       * @returns string
       */
      loadStringRefTail() {
        return (0, strings_1.readString)(this.loadRef().beginParse());
      }
      /**
       * Load maybe string tail from ref
       * @returns string or null
       */
      loadMaybeStringRefTail() {
        const ref = this.loadMaybeRef();
        if (ref) {
          return (0, strings_1.readString)(ref.beginParse());
        } else {
          return null;
        }
      }
      /**
       * Loads dictionary
       * @param key key description
       * @param value value description
       * @returns Dictionary<K, V>
       */
      loadDict(key, value) {
        return Dictionary_1.Dictionary.load(key, value, this);
      }
      /**
       * Loads dictionary directly from current slice
       * @param key key description
       * @param value value description
       * @returns Dictionary<K, V>
       */
      loadDictDirect(key, value) {
        return Dictionary_1.Dictionary.loadDirect(key, value, this);
      }
      /**
       * Checks if slice is empty
       */
      endParse() {
        if (this.remainingBits > 0 || this.remainingRefs > 0) {
          throw new Error("Slice is not empty");
        }
      }
      /**
       * Convert slice to cell
       */
      asCell() {
        return (0, Builder_1.beginCell)().storeSlice(this).endCell();
      }
      /**
       *
       * @returns
       */
      asBuilder() {
        return (0, Builder_1.beginCell)().storeSlice(this);
      }
      /**
       * Clone slice
       * @returns cloned slice
       */
      clone() {
        return new Slice(this._reader, this._refs);
      }
      /**
       * Print slice as string by converting it to cell
       * @returns string
       */
      toString() {
        return this.asCell().toString();
      }
    };
    exports.Slice = Slice;
    _a = symbol_inspect_1.default;
  }
});

// node_modules/ton-core/dist/boc/BitReader.js
var require_BitReader = __commonJS({
  "node_modules/ton-core/dist/boc/BitReader.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitReader = void 0;
    var Address_1 = require_Address();
    var ExternalAddress_1 = require_ExternalAddress();
    var BitReader = class {
      constructor(bits, offset = 0) {
        this._checkpoints = [];
        this._bits = bits;
        this._offset = offset;
      }
      /**
       * Number of bits remaining
       */
      get remaining() {
        return this._bits.length - this._offset;
      }
      /**
       * Skip bits
       * @param bits number of bits to skip
       */
      skip(bits) {
        if (bits < 0 || this._offset + bits > this._bits.length) {
          throw new Error(`Index ${this._offset + bits} is out of bounds`);
        }
        this._offset += bits;
      }
      /**
       * Reset to the beginning or latest checkpoint
       */
      reset() {
        if (this._checkpoints.length > 0) {
          this._offset = this._checkpoints.pop();
        } else {
          this._offset = 0;
        }
      }
      /**
       * Save checkpoint
       */
      save() {
        this._checkpoints.push(this._offset);
      }
      /**
       * Load a single bit
       * @returns true if the bit is set, false otherwise
       */
      loadBit() {
        let r = this._bits.at(this._offset);
        this._offset++;
        return r;
      }
      /**
       * Preload bit
       * @returns true if the bit is set, false otherwise
       */
      preloadBit() {
        return this._bits.at(this._offset);
      }
      /**
       * Load bit string
       * @param bits number of bits to read
       * @returns new bitstring
       */
      loadBits(bits) {
        let r = this._bits.substring(this._offset, bits);
        this._offset += bits;
        return r;
      }
      /**
       * Preload bit string
       * @param bits number of bits to read
       * @returns new bitstring
       */
      preloadBits(bits) {
        return this._bits.substring(this._offset, bits);
      }
      /**
       * Load buffer
       * @param bytes number of bytes
       * @returns new buffer
       */
      loadBuffer(bytes) {
        let buf = this._preloadBuffer(bytes, this._offset);
        this._offset += bytes * 8;
        return buf;
      }
      /**
       * Preload buffer
       * @param bytes number of bytes
       * @returns new buffer
       */
      preloadBuffer(bytes) {
        return this._preloadBuffer(bytes, this._offset);
      }
      /**
       * Load uint value
       * @param bits uint bits
       * @returns read value as number
       */
      loadUint(bits) {
        return Number(this.loadUintBig(bits));
      }
      /**
       * Load uint value as bigint
       * @param bits uint bits
       * @returns read value as bigint
       */
      loadUintBig(bits) {
        let loaded = this.preloadUintBig(bits);
        this._offset += bits;
        return loaded;
      }
      /**
       * Preload uint value
       * @param bits uint bits
       * @returns read value as number
       */
      preloadUint(bits) {
        return Number(this._preloadUint(bits, this._offset));
      }
      /**
       * Preload uint value as bigint
       * @param bits uint bits
       * @returns read value as bigint
       */
      preloadUintBig(bits) {
        return this._preloadUint(bits, this._offset);
      }
      /**
       * Load int value
       * @param bits int bits
       * @returns read value as bigint
       */
      loadInt(bits) {
        let res = this._preloadInt(bits, this._offset);
        this._offset += bits;
        return Number(res);
      }
      /**
       * Load int value as bigint
       * @param bits int bits
       * @returns read value as bigint
       */
      loadIntBig(bits) {
        let res = this._preloadInt(bits, this._offset);
        this._offset += bits;
        return res;
      }
      /**
       * Preload int value
       * @param bits int bits
       * @returns read value as bigint
       */
      preloadInt(bits) {
        return Number(this._preloadInt(bits, this._offset));
      }
      /**
       * Preload int value
       * @param bits int bits
       * @returns read value as bigint
       */
      preloadIntBig(bits) {
        return this._preloadInt(bits, this._offset);
      }
      /**
       * Load varuint value
       * @param bits number of bits to read the size
       * @returns read value as bigint
       */
      loadVarUint(bits) {
        let size4 = Number(this.loadUint(bits));
        return Number(this.loadUintBig(size4 * 8));
      }
      /**
       * Load varuint value
       * @param bits number of bits to read the size
       * @returns read value as bigint
       */
      loadVarUintBig(bits) {
        let size4 = Number(this.loadUint(bits));
        return this.loadUintBig(size4 * 8);
      }
      /**
       * Preload varuint value
       * @param bits number of bits to read the size
       * @returns read value as bigint
       */
      preloadVarUint(bits) {
        let size4 = Number(this._preloadUint(bits, this._offset));
        return Number(this._preloadUint(size4 * 8, this._offset + bits));
      }
      /**
       * Preload varuint value
       * @param bits number of bits to read the size
       * @returns read value as bigint
       */
      preloadVarUintBig(bits) {
        let size4 = Number(this._preloadUint(bits, this._offset));
        return this._preloadUint(size4 * 8, this._offset + bits);
      }
      /**
       * Load varint value
       * @param bits number of bits to read the size
       * @returns read value as bigint
       */
      loadVarInt(bits) {
        let size4 = Number(this.loadUint(bits));
        return Number(this.loadIntBig(size4 * 8));
      }
      /**
       * Load varint value
       * @param bits number of bits to read the size
       * @returns read value as bigint
       */
      loadVarIntBig(bits) {
        let size4 = Number(this.loadUint(bits));
        return this.loadIntBig(size4 * 8);
      }
      /**
       * Preload varint value
       * @param bits number of bits to read the size
       * @returns read value as bigint
       */
      preloadVarInt(bits) {
        let size4 = Number(this._preloadUint(bits, this._offset));
        return Number(this._preloadInt(size4 * 8, this._offset + bits));
      }
      /**
       * Preload varint value
       * @param bits number of bits to read the size
       * @returns read value as bigint
       */
      preloadVarIntBig(bits) {
        let size4 = Number(this._preloadUint(bits, this._offset));
        return this._preloadInt(size4 * 8, this._offset + bits);
      }
      /**
       * Load coins value
       * @returns read value as bigint
       */
      loadCoins() {
        return this.loadVarUintBig(4);
      }
      /**
       * Preload coins value
       * @returns read value as bigint
       */
      preloadCoins() {
        return this.preloadVarUintBig(4);
      }
      /**
       * Load Address
       * @returns Address
       */
      loadAddress() {
        let type2 = Number(this._preloadUint(2, this._offset));
        if (type2 === 2) {
          return this._loadInternalAddress();
        } else {
          throw new Error("Invalid address: " + type2);
        }
      }
      /**
       * Load internal address
       * @returns Address or null
       */
      loadMaybeAddress() {
        let type2 = Number(this._preloadUint(2, this._offset));
        if (type2 === 0) {
          this._offset += 2;
          return null;
        } else if (type2 === 2) {
          return this._loadInternalAddress();
        } else {
          throw new Error("Invalid address");
        }
      }
      /**
       * Load external address
       * @returns ExternalAddress
       */
      loadExternalAddress() {
        let type2 = Number(this._preloadUint(2, this._offset));
        if (type2 === 1) {
          return this._loadExternalAddress();
        } else {
          throw new Error("Invalid address");
        }
      }
      /**
       * Load external address
       * @returns ExternalAddress or null
       */
      loadMaybeExternalAddress() {
        let type2 = Number(this._preloadUint(2, this._offset));
        if (type2 === 0) {
          this._offset += 2;
          return null;
        } else if (type2 === 1) {
          return this._loadExternalAddress();
        } else {
          throw new Error("Invalid address");
        }
      }
      /**
       * Read address of any type
       * @returns Address or ExternalAddress or null
       */
      loadAddressAny() {
        let type2 = Number(this._preloadUint(2, this._offset));
        if (type2 === 0) {
          this._offset += 2;
          return null;
        } else if (type2 === 2) {
          return this._loadInternalAddress();
        } else if (type2 === 1) {
          return this._loadExternalAddress();
        } else if (type2 === 3) {
          throw Error("Unsupported");
        } else {
          throw Error("Unreachable");
        }
      }
      /**
       * Load bit string that was padded to make it byte alligned. Used in BOC serialization
       * @param bytes number of bytes to read
       */
      loadPaddedBits(bits) {
        if (bits % 8 !== 0) {
          throw new Error("Invalid number of bits");
        }
        let length = bits;
        while (true) {
          if (this._bits.at(this._offset + length - 1)) {
            length--;
            break;
          } else {
            length--;
          }
        }
        let r = this._bits.substring(this._offset, length);
        this._offset += bits;
        return r;
      }
      /**
       * Clone BitReader
       */
      clone() {
        return new BitReader(this._bits, this._offset);
      }
      /**
       * Preload int from specific offset
       * @param bits bits to preload
       * @param offset offset to start from
       * @returns read value as bigint
       */
      _preloadInt(bits, offset) {
        if (bits == 0) {
          return 0n;
        }
        let sign = this._bits.at(offset);
        let res = 0n;
        for (let i = 0; i < bits - 1; i++) {
          if (this._bits.at(offset + 1 + i)) {
            res += 1n << BigInt(bits - i - 1 - 1);
          }
        }
        if (sign) {
          res = res - (1n << BigInt(bits - 1));
        }
        return res;
      }
      /**
       * Preload uint from specific offset
       * @param bits bits to preload
       * @param offset offset to start from
       * @returns read value as bigint
       */
      _preloadUint(bits, offset) {
        if (bits == 0) {
          return 0n;
        }
        let res = 0n;
        for (let i = 0; i < bits; i++) {
          if (this._bits.at(offset + i)) {
            res += 1n << BigInt(bits - i - 1);
          }
        }
        return res;
      }
      _preloadBuffer(bytes, offset) {
        let fastBuffer = this._bits.subbuffer(offset, bytes * 8);
        if (fastBuffer) {
          return fastBuffer;
        }
        let buf = import_buffer.Buffer.alloc(bytes);
        for (let i = 0; i < bytes; i++) {
          buf[i] = Number(this._preloadUint(8, offset + i * 8));
        }
        return buf;
      }
      _loadInternalAddress() {
        let type2 = Number(this._preloadUint(2, this._offset));
        if (type2 !== 2) {
          throw Error("Invalid address");
        }
        if (this._preloadUint(1, this._offset + 2) !== 0n) {
          throw Error("Invalid address");
        }
        let wc = Number(this._preloadInt(8, this._offset + 3));
        let hash = this._preloadBuffer(32, this._offset + 11);
        this._offset += 267;
        return new Address_1.Address(wc, hash);
      }
      _loadExternalAddress() {
        let type2 = Number(this._preloadUint(2, this._offset));
        if (type2 !== 1) {
          throw Error("Invalid address");
        }
        let bits = Number(this._preloadUint(9, this._offset + 2));
        let value = this._preloadUint(bits, this._offset + 11);
        this._offset += 11 + bits;
        return new ExternalAddress_1.ExternalAddress(value, bits);
      }
    };
    exports.BitReader = BitReader;
  }
});

// node_modules/ton-core/dist/boc/cell/exoticLibrary.js
var require_exoticLibrary = __commonJS({
  "node_modules/ton-core/dist/boc/cell/exoticLibrary.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exoticLibrary = void 0;
    var BitReader_1 = require_BitReader();
    function exoticLibrary(bits, refs) {
      const reader = new BitReader_1.BitReader(bits);
      const size4 = 8 + 256;
      if (bits.length !== size4) {
        throw new Error(`Library cell must have exactly (8 + 256) bits, got "${bits.length}"`);
      }
      let type2 = reader.loadUint(8);
      if (type2 !== 2) {
        throw new Error(`Library cell must have type 2, got "${type2}"`);
      }
      return {};
    }
    exports.exoticLibrary = exoticLibrary;
  }
});

// node_modules/ton-core/dist/boc/cell/exoticMerkleProof.js
var require_exoticMerkleProof = __commonJS({
  "node_modules/ton-core/dist/boc/cell/exoticMerkleProof.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exoticMerkleProof = void 0;
    var BitReader_1 = require_BitReader();
    function exoticMerkleProof(bits, refs) {
      const reader = new BitReader_1.BitReader(bits);
      const size4 = 8 + 256 + 16;
      if (bits.length !== size4) {
        throw new Error(`Merkle Proof cell must have exactly (8 + 256 + 16) bits, got "${bits.length}"`);
      }
      if (refs.length !== 1) {
        throw new Error(`Merkle Proof cell must have exactly 1 ref, got "${refs.length}"`);
      }
      let type2 = reader.loadUint(8);
      if (type2 !== 3) {
        throw new Error(`Merkle Proof cell must have type 3, got "${type2}"`);
      }
      const proofHash = reader.loadBuffer(32);
      const proofDepth = reader.loadUint(16);
      const refHash = refs[0].hash(0);
      const refDepth = refs[0].depth(0);
      if (proofDepth !== refDepth) {
        throw new Error(`Merkle Proof cell ref depth must be exactly "${proofDepth}", got "${refDepth}"`);
      }
      if (!proofHash.equals(refHash)) {
        throw new Error(`Merkle Proof cell ref hash must be exactly "${proofHash.toString("hex")}", got "${refHash.toString("hex")}"`);
      }
      return {
        proofDepth,
        proofHash
      };
    }
    exports.exoticMerkleProof = exoticMerkleProof;
  }
});

// node_modules/ton-core/dist/boc/cell/exoticMerkleUpdate.js
var require_exoticMerkleUpdate = __commonJS({
  "node_modules/ton-core/dist/boc/cell/exoticMerkleUpdate.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exoticMerkleUpdate = void 0;
    var BitReader_1 = require_BitReader();
    function exoticMerkleUpdate(bits, refs) {
      const reader = new BitReader_1.BitReader(bits);
      const size4 = 8 + 2 * (256 + 16);
      if (bits.length !== size4) {
        throw new Error(`Merkle Update cell must have exactly (8 + (2 * (256 + 16))) bits, got "${bits.length}"`);
      }
      if (refs.length !== 2) {
        throw new Error(`Merkle Update cell must have exactly 2 refs, got "${refs.length}"`);
      }
      let type2 = reader.loadUint(8);
      if (type2 !== 4) {
        throw new Error(`Merkle Update cell type must be exactly 4, got "${type2}"`);
      }
      const proofHash1 = reader.loadBuffer(32);
      const proofHash2 = reader.loadBuffer(32);
      const proofDepth1 = reader.loadUint(16);
      const proofDepth2 = reader.loadUint(16);
      if (proofDepth1 !== refs[0].depth(0)) {
        throw new Error(`Merkle Update cell ref depth must be exactly "${proofDepth1}", got "${refs[0].depth(0)}"`);
      }
      if (!proofHash1.equals(refs[0].hash(0))) {
        throw new Error(`Merkle Update cell ref hash must be exactly "${proofHash1.toString("hex")}", got "${refs[0].hash(0).toString("hex")}"`);
      }
      if (proofDepth2 !== refs[1].depth(0)) {
        throw new Error(`Merkle Update cell ref depth must be exactly "${proofDepth2}", got "${refs[1].depth(0)}"`);
      }
      if (!proofHash2.equals(refs[1].hash(0))) {
        throw new Error(`Merkle Update cell ref hash must be exactly "${proofHash2.toString("hex")}", got "${refs[1].hash(0).toString("hex")}"`);
      }
      return {
        proofDepth1,
        proofDepth2,
        proofHash1,
        proofHash2
      };
    }
    exports.exoticMerkleUpdate = exoticMerkleUpdate;
  }
});

// node_modules/ton-core/dist/boc/cell/LevelMask.js
var require_LevelMask = __commonJS({
  "node_modules/ton-core/dist/boc/cell/LevelMask.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LevelMask = void 0;
    var LevelMask = class {
      constructor(mask = 0) {
        this._mask = 0;
        this._mask = mask;
        this._hashIndex = countSetBits(this._mask);
        this._hashCount = this._hashIndex + 1;
      }
      get value() {
        return this._mask;
      }
      get level() {
        return 32 - Math.clz32(this._mask);
      }
      get hashIndex() {
        return this._hashIndex;
      }
      get hashCount() {
        return this._hashCount;
      }
      apply(level) {
        return new LevelMask(this._mask & (1 << level) - 1);
      }
      isSignificant(level) {
        let res = level === 0 || (this._mask >> level - 1) % 2 !== 0;
        return res;
      }
    };
    exports.LevelMask = LevelMask;
    function countSetBits(n) {
      n = n - (n >> 1 & 1431655765);
      n = (n & 858993459) + (n >> 2 & 858993459);
      return (n + (n >> 4) & 252645135) * 16843009 >> 24;
    }
  }
});

// node_modules/ton-core/dist/boc/cell/exoticPruned.js
var require_exoticPruned = __commonJS({
  "node_modules/ton-core/dist/boc/cell/exoticPruned.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exoticPruned = void 0;
    var BitReader_1 = require_BitReader();
    var LevelMask_1 = require_LevelMask();
    function exoticPruned(bits, refs) {
      let reader = new BitReader_1.BitReader(bits);
      let type2 = reader.loadUint(8);
      if (type2 !== 1) {
        throw new Error(`Pruned branch cell must have type 1, got "${type2}"`);
      }
      if (refs.length !== 0) {
        throw new Error(`Pruned Branch cell can't has refs, got "${refs.length}"`);
      }
      let mask;
      if (bits.length === 280) {
        mask = new LevelMask_1.LevelMask(1);
      } else {
        mask = new LevelMask_1.LevelMask(reader.loadUint(8));
        if (mask.level < 1 || mask.level > 3) {
          throw new Error(`Pruned Branch cell level must be >= 1 and <= 3, got "${mask.level}/${mask.value}"`);
        }
        const size4 = 8 + 8 + mask.apply(mask.level - 1).hashCount * (256 + 16);
        if (bits.length !== size4) {
          throw new Error(`Pruned branch cell must have exactly ${size4} bits, got "${bits.length}"`);
        }
      }
      let pruned = [];
      let hashes = [];
      let depths = [];
      for (let i = 0; i < mask.level; i++) {
        hashes.push(reader.loadBuffer(32));
      }
      for (let i = 0; i < mask.level; i++) {
        depths.push(reader.loadUint(16));
      }
      for (let i = 0; i < mask.level; i++) {
        pruned.push({
          depth: depths[i],
          hash: hashes[i]
        });
      }
      return {
        mask: mask.value,
        pruned
      };
    }
    exports.exoticPruned = exoticPruned;
  }
});

// node_modules/ton-core/dist/boc/cell/resolveExotic.js
var require_resolveExotic = __commonJS({
  "node_modules/ton-core/dist/boc/cell/resolveExotic.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveExotic = void 0;
    var BitReader_1 = require_BitReader();
    var CellType_1 = require_CellType();
    var exoticLibrary_1 = require_exoticLibrary();
    var exoticMerkleProof_1 = require_exoticMerkleProof();
    var exoticMerkleUpdate_1 = require_exoticMerkleUpdate();
    var exoticPruned_1 = require_exoticPruned();
    var LevelMask_1 = require_LevelMask();
    function resolvePruned(bits, refs) {
      let pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);
      let depths = [];
      let hashes = [];
      let mask = new LevelMask_1.LevelMask(pruned.mask);
      for (let i = 0; i < pruned.pruned.length; i++) {
        depths.push(pruned.pruned[i].depth);
        hashes.push(pruned.pruned[i].hash);
      }
      return {
        type: CellType_1.CellType.PrunedBranch,
        depths,
        hashes,
        mask
      };
    }
    function resolveLibrary(bits, refs) {
      let pruned = (0, exoticLibrary_1.exoticLibrary)(bits, refs);
      let depths = [];
      let hashes = [];
      let mask = new LevelMask_1.LevelMask();
      return {
        type: CellType_1.CellType.Library,
        depths,
        hashes,
        mask
      };
    }
    function resolveMerkleProof(bits, refs) {
      let merkleProof = (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);
      let depths = [];
      let hashes = [];
      let mask = new LevelMask_1.LevelMask(refs[0].level() >> 1);
      return {
        type: CellType_1.CellType.MerkleProof,
        depths,
        hashes,
        mask
      };
    }
    function resolveMerkleUpdate(bits, refs) {
      let merkleUpdate = (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);
      let depths = [];
      let hashes = [];
      let mask = new LevelMask_1.LevelMask((refs[0].level() | refs[1].level()) >> 1);
      return {
        type: CellType_1.CellType.MerkleUpdate,
        depths,
        hashes,
        mask
      };
    }
    function resolveExotic(bits, refs) {
      let reader = new BitReader_1.BitReader(bits);
      let type2 = reader.preloadUint(8);
      if (type2 === 1) {
        return resolvePruned(bits, refs);
      }
      if (type2 === 2) {
        return resolveLibrary(bits, refs);
      }
      if (type2 === 3) {
        return resolveMerkleProof(bits, refs);
      }
      if (type2 === 4) {
        return resolveMerkleUpdate(bits, refs);
      }
      throw Error("Invalid exotic cell type: " + type2);
    }
    exports.resolveExotic = resolveExotic;
  }
});

// node_modules/ton-core/dist/boc/cell/descriptor.js
var require_descriptor = __commonJS({
  "node_modules/ton-core/dist/boc/cell/descriptor.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRepr = exports.getBitsDescriptor = exports.getRefsDescriptor = void 0;
    var CellType_1 = require_CellType();
    var paddedBits_1 = require_paddedBits();
    function getRefsDescriptor(refs, level, type2) {
      return refs.length + (type2 !== CellType_1.CellType.Ordinary ? 1 : 0) * 8 + level * 32;
    }
    exports.getRefsDescriptor = getRefsDescriptor;
    function getBitsDescriptor(bits) {
      let len = bits.length;
      return Math.ceil(len / 8) + Math.floor(len / 8);
    }
    exports.getBitsDescriptor = getBitsDescriptor;
    function getRepr(bits, refs, level, type2) {
      const bitsLen = Math.ceil(bits.length / 8);
      const repr = import_buffer.Buffer.alloc(2 + bitsLen + (2 + 32) * refs.length);
      let reprCursor = 0;
      repr[reprCursor++] = getRefsDescriptor(refs, level, type2);
      repr[reprCursor++] = getBitsDescriptor(bits);
      (0, paddedBits_1.bitsToPaddedBuffer)(bits).copy(repr, reprCursor);
      reprCursor += bitsLen;
      for (const c of refs) {
        let childDepth;
        if (type2 == CellType_1.CellType.MerkleProof || type2 == CellType_1.CellType.MerkleUpdate) {
          childDepth = c.depth(level + 1);
        } else {
          childDepth = c.depth(level);
        }
        repr[reprCursor++] = Math.floor(childDepth / 256);
        repr[reprCursor++] = childDepth % 256;
      }
      for (const c of refs) {
        let childHash;
        if (type2 == CellType_1.CellType.MerkleProof || type2 == CellType_1.CellType.MerkleUpdate) {
          childHash = c.hash(level + 1);
        } else {
          childHash = c.hash(level);
        }
        childHash.copy(repr, reprCursor);
        reprCursor += 32;
      }
      return repr;
    }
    exports.getRepr = getRepr;
  }
});

// node_modules/jssha/dist/sha.js
var require_sha = __commonJS({
  "node_modules/jssha/dist/sha.js"(exports, module) {
    init_shim();
    !function(n, r) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = r() : "function" == typeof define && define.amd ? define(r) : (n = "undefined" != typeof globalThis ? globalThis : n || self).jsSHA = r();
    }(exports, function() {
      "use strict";
      var n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      function r(n2, r2, t2, e2) {
        var i2, o2, u2, f2 = r2 || [0], w2 = (t2 = t2 || 0) >>> 3, s2 = -1 === e2 ? 3 : 0;
        for (i2 = 0; i2 < n2.length; i2 += 1)
          o2 = (u2 = i2 + w2) >>> 2, f2.length <= o2 && f2.push(0), f2[o2] |= n2[i2] << 8 * (s2 + e2 * (u2 % 4));
        return { value: f2, binLen: 8 * n2.length + t2 };
      }
      function t(t2, e2, i2) {
        switch (e2) {
          case "UTF8":
          case "UTF16BE":
          case "UTF16LE":
            break;
          default:
            throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE");
        }
        switch (t2) {
          case "HEX":
            return function(n2, r2, t3) {
              return function(n3, r3, t4, e3) {
                var i3, o2, u2, f2;
                if (0 != n3.length % 2)
                  throw new Error("String of HEX type must be in byte increments");
                var w2 = r3 || [0], s2 = (t4 = t4 || 0) >>> 3, a2 = -1 === e3 ? 3 : 0;
                for (i3 = 0; i3 < n3.length; i3 += 2) {
                  if (o2 = parseInt(n3.substr(i3, 2), 16), isNaN(o2))
                    throw new Error("String of HEX type contains invalid characters");
                  for (u2 = (f2 = (i3 >>> 1) + s2) >>> 2; w2.length <= u2; )
                    w2.push(0);
                  w2[u2] |= o2 << 8 * (a2 + e3 * (f2 % 4));
                }
                return { value: w2, binLen: 4 * n3.length + t4 };
              }(n2, r2, t3, i2);
            };
          case "TEXT":
            return function(n2, r2, t3) {
              return function(n3, r3, t4, e3, i3) {
                var o2, u2, f2, w2, s2, a2, h2, c2, v2 = 0, A2 = t4 || [0], E2 = (e3 = e3 || 0) >>> 3;
                if ("UTF8" === r3)
                  for (h2 = -1 === i3 ? 3 : 0, f2 = 0; f2 < n3.length; f2 += 1)
                    for (u2 = [], 128 > (o2 = n3.charCodeAt(f2)) ? u2.push(o2) : 2048 > o2 ? (u2.push(192 | o2 >>> 6), u2.push(128 | 63 & o2)) : 55296 > o2 || 57344 <= o2 ? u2.push(224 | o2 >>> 12, 128 | o2 >>> 6 & 63, 128 | 63 & o2) : (f2 += 1, o2 = 65536 + ((1023 & o2) << 10 | 1023 & n3.charCodeAt(f2)), u2.push(240 | o2 >>> 18, 128 | o2 >>> 12 & 63, 128 | o2 >>> 6 & 63, 128 | 63 & o2)), w2 = 0; w2 < u2.length; w2 += 1) {
                      for (s2 = (a2 = v2 + E2) >>> 2; A2.length <= s2; )
                        A2.push(0);
                      A2[s2] |= u2[w2] << 8 * (h2 + i3 * (a2 % 4)), v2 += 1;
                    }
                else
                  for (h2 = -1 === i3 ? 2 : 0, c2 = "UTF16LE" === r3 && 1 !== i3 || "UTF16LE" !== r3 && 1 === i3, f2 = 0; f2 < n3.length; f2 += 1) {
                    for (o2 = n3.charCodeAt(f2), true === c2 && (o2 = (w2 = 255 & o2) << 8 | o2 >>> 8), s2 = (a2 = v2 + E2) >>> 2; A2.length <= s2; )
                      A2.push(0);
                    A2[s2] |= o2 << 8 * (h2 + i3 * (a2 % 4)), v2 += 2;
                  }
                return { value: A2, binLen: 8 * v2 + e3 };
              }(n2, e2, r2, t3, i2);
            };
          case "B64":
            return function(r2, t3, e3) {
              return function(r3, t4, e4, i3) {
                var o2, u2, f2, w2, s2, a2, h2 = 0, c2 = t4 || [0], v2 = (e4 = e4 || 0) >>> 3, A2 = -1 === i3 ? 3 : 0, E2 = r3.indexOf("=");
                if (-1 === r3.search(/^[a-zA-Z0-9=+/]+$/))
                  throw new Error("Invalid character in base-64 string");
                if (r3 = r3.replace(/=/g, ""), -1 !== E2 && E2 < r3.length)
                  throw new Error("Invalid '=' found in base-64 string");
                for (o2 = 0; o2 < r3.length; o2 += 4) {
                  for (w2 = r3.substr(o2, 4), f2 = 0, u2 = 0; u2 < w2.length; u2 += 1)
                    f2 |= n.indexOf(w2.charAt(u2)) << 18 - 6 * u2;
                  for (u2 = 0; u2 < w2.length - 1; u2 += 1) {
                    for (s2 = (a2 = h2 + v2) >>> 2; c2.length <= s2; )
                      c2.push(0);
                    c2[s2] |= (f2 >>> 16 - 8 * u2 & 255) << 8 * (A2 + i3 * (a2 % 4)), h2 += 1;
                  }
                }
                return { value: c2, binLen: 8 * h2 + e4 };
              }(r2, t3, e3, i2);
            };
          case "BYTES":
            return function(n2, r2, t3) {
              return function(n3, r3, t4, e3) {
                var i3, o2, u2, f2, w2 = r3 || [0], s2 = (t4 = t4 || 0) >>> 3, a2 = -1 === e3 ? 3 : 0;
                for (o2 = 0; o2 < n3.length; o2 += 1)
                  i3 = n3.charCodeAt(o2), u2 = (f2 = o2 + s2) >>> 2, w2.length <= u2 && w2.push(0), w2[u2] |= i3 << 8 * (a2 + e3 * (f2 % 4));
                return { value: w2, binLen: 8 * n3.length + t4 };
              }(n2, r2, t3, i2);
            };
          case "ARRAYBUFFER":
            try {
              new ArrayBuffer(0);
            } catch (n2) {
              throw new Error("ARRAYBUFFER not supported by this environment");
            }
            return function(n2, t3, e3) {
              return function(n3, t4, e4, i3) {
                return r(new Uint8Array(n3), t4, e4, i3);
              }(n2, t3, e3, i2);
            };
          case "UINT8ARRAY":
            try {
              new Uint8Array(0);
            } catch (n2) {
              throw new Error("UINT8ARRAY not supported by this environment");
            }
            return function(n2, t3, e3) {
              return r(n2, t3, e3, i2);
            };
          default:
            throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
        }
      }
      function e(r2, t2, e2, i2) {
        switch (r2) {
          case "HEX":
            return function(n2) {
              return function(n3, r3, t3, e3) {
                var i3, o2, u2 = "", f2 = r3 / 8, w2 = -1 === t3 ? 3 : 0;
                for (i3 = 0; i3 < f2; i3 += 1)
                  o2 = n3[i3 >>> 2] >>> 8 * (w2 + t3 * (i3 % 4)), u2 += "0123456789abcdef".charAt(o2 >>> 4 & 15) + "0123456789abcdef".charAt(15 & o2);
                return e3.outputUpper ? u2.toUpperCase() : u2;
              }(n2, t2, e2, i2);
            };
          case "B64":
            return function(r3) {
              return function(r4, t3, e3, i3) {
                var o2, u2, f2, w2, s2, a2 = "", h2 = t3 / 8, c2 = -1 === e3 ? 3 : 0;
                for (o2 = 0; o2 < h2; o2 += 3)
                  for (w2 = o2 + 1 < h2 ? r4[o2 + 1 >>> 2] : 0, s2 = o2 + 2 < h2 ? r4[o2 + 2 >>> 2] : 0, f2 = (r4[o2 >>> 2] >>> 8 * (c2 + e3 * (o2 % 4)) & 255) << 16 | (w2 >>> 8 * (c2 + e3 * ((o2 + 1) % 4)) & 255) << 8 | s2 >>> 8 * (c2 + e3 * ((o2 + 2) % 4)) & 255, u2 = 0; u2 < 4; u2 += 1)
                    a2 += 8 * o2 + 6 * u2 <= t3 ? n.charAt(f2 >>> 6 * (3 - u2) & 63) : i3.b64Pad;
                return a2;
              }(r3, t2, e2, i2);
            };
          case "BYTES":
            return function(n2) {
              return function(n3, r3, t3) {
                var e3, i3, o2 = "", u2 = r3 / 8, f2 = -1 === t3 ? 3 : 0;
                for (e3 = 0; e3 < u2; e3 += 1)
                  i3 = n3[e3 >>> 2] >>> 8 * (f2 + t3 * (e3 % 4)) & 255, o2 += String.fromCharCode(i3);
                return o2;
              }(n2, t2, e2);
            };
          case "ARRAYBUFFER":
            try {
              new ArrayBuffer(0);
            } catch (n2) {
              throw new Error("ARRAYBUFFER not supported by this environment");
            }
            return function(n2) {
              return function(n3, r3, t3) {
                var e3, i3 = r3 / 8, o2 = new ArrayBuffer(i3), u2 = new Uint8Array(o2), f2 = -1 === t3 ? 3 : 0;
                for (e3 = 0; e3 < i3; e3 += 1)
                  u2[e3] = n3[e3 >>> 2] >>> 8 * (f2 + t3 * (e3 % 4)) & 255;
                return o2;
              }(n2, t2, e2);
            };
          case "UINT8ARRAY":
            try {
              new Uint8Array(0);
            } catch (n2) {
              throw new Error("UINT8ARRAY not supported by this environment");
            }
            return function(n2) {
              return function(n3, r3, t3) {
                var e3, i3 = r3 / 8, o2 = -1 === t3 ? 3 : 0, u2 = new Uint8Array(i3);
                for (e3 = 0; e3 < i3; e3 += 1)
                  u2[e3] = n3[e3 >>> 2] >>> 8 * (o2 + t3 * (e3 % 4)) & 255;
                return u2;
              }(n2, t2, e2);
            };
          default:
            throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
        }
      }
      var i = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], o = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428], u = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], f = "Chosen SHA variant is not supported";
      function w(n2, r2) {
        var t2, e2, i2 = n2.binLen >>> 3, o2 = r2.binLen >>> 3, u2 = i2 << 3, f2 = 4 - i2 << 3;
        if (i2 % 4 != 0) {
          for (t2 = 0; t2 < o2; t2 += 4)
            e2 = i2 + t2 >>> 2, n2.value[e2] |= r2.value[t2 >>> 2] << u2, n2.value.push(0), n2.value[e2 + 1] |= r2.value[t2 >>> 2] >>> f2;
          return (n2.value.length << 2) - 4 >= o2 + i2 && n2.value.pop(), { value: n2.value, binLen: n2.binLen + r2.binLen };
        }
        return { value: n2.value.concat(r2.value), binLen: n2.binLen + r2.binLen };
      }
      function s(n2) {
        var r2 = { outputUpper: false, b64Pad: "=", outputLen: -1 }, t2 = n2 || {}, e2 = "Output length must be a multiple of 8";
        if (r2.outputUpper = t2.outputUpper || false, t2.b64Pad && (r2.b64Pad = t2.b64Pad), t2.outputLen) {
          if (t2.outputLen % 8 != 0)
            throw new Error(e2);
          r2.outputLen = t2.outputLen;
        } else if (t2.shakeLen) {
          if (t2.shakeLen % 8 != 0)
            throw new Error(e2);
          r2.outputLen = t2.shakeLen;
        }
        if ("boolean" != typeof r2.outputUpper)
          throw new Error("Invalid outputUpper formatting option");
        if ("string" != typeof r2.b64Pad)
          throw new Error("Invalid b64Pad formatting option");
        return r2;
      }
      function a(n2, r2, e2, i2) {
        var o2 = n2 + " must include a value and format";
        if (!r2) {
          if (!i2)
            throw new Error(o2);
          return i2;
        }
        if (void 0 === r2.value || !r2.format)
          throw new Error(o2);
        return t(r2.format, r2.encoding || "UTF8", e2)(r2.value);
      }
      var h = function() {
        function n2(n3, r2, t2) {
          var e2 = t2 || {};
          if (this.t = r2, this.i = e2.encoding || "UTF8", this.numRounds = e2.numRounds || 1, isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds)
            throw new Error("numRounds must a integer >= 1");
          this.o = n3, this.u = [], this.s = 0, this.h = false, this.v = 0, this.A = false, this.l = [], this.H = [];
        }
        return n2.prototype.update = function(n3) {
          var r2, t2 = 0, e2 = this.S >>> 5, i2 = this.p(n3, this.u, this.s), o2 = i2.binLen, u2 = i2.value, f2 = o2 >>> 5;
          for (r2 = 0; r2 < f2; r2 += e2)
            t2 + this.S <= o2 && (this.m = this.R(u2.slice(r2, r2 + e2), this.m), t2 += this.S);
          this.v += t2, this.u = u2.slice(t2 >>> 5), this.s = o2 % this.S, this.h = true;
        }, n2.prototype.getHash = function(n3, r2) {
          var t2, i2, o2 = this.U, u2 = s(r2);
          if (this.T) {
            if (-1 === u2.outputLen)
              throw new Error("Output length must be specified in options");
            o2 = u2.outputLen;
          }
          var f2 = e(n3, o2, this.C, u2);
          if (this.A && this.F)
            return f2(this.F(u2));
          for (i2 = this.K(this.u.slice(), this.s, this.v, this.B(this.m), o2), t2 = 1; t2 < this.numRounds; t2 += 1)
            this.T && o2 % 32 != 0 && (i2[i2.length - 1] &= 16777215 >>> 24 - o2 % 32), i2 = this.K(i2, o2, 0, this.L(this.o), o2);
          return f2(i2);
        }, n2.prototype.setHMACKey = function(n3, r2, e2) {
          if (!this.g)
            throw new Error("Variant does not support HMAC");
          if (this.h)
            throw new Error("Cannot set MAC key after calling update");
          var i2 = t(r2, (e2 || {}).encoding || "UTF8", this.C);
          this.k(i2(n3));
        }, n2.prototype.k = function(n3) {
          var r2, t2 = this.S >>> 3, e2 = t2 / 4 - 1;
          if (1 !== this.numRounds)
            throw new Error("Cannot set numRounds with MAC");
          if (this.A)
            throw new Error("MAC key already set");
          for (t2 < n3.binLen / 8 && (n3.value = this.K(n3.value, n3.binLen, 0, this.L(this.o), this.U)); n3.value.length <= e2; )
            n3.value.push(0);
          for (r2 = 0; r2 <= e2; r2 += 1)
            this.l[r2] = 909522486 ^ n3.value[r2], this.H[r2] = 1549556828 ^ n3.value[r2];
          this.m = this.R(this.l, this.m), this.v = this.S, this.A = true;
        }, n2.prototype.getHMAC = function(n3, r2) {
          var t2 = s(r2);
          return e(n3, this.U, this.C, t2)(this.Y());
        }, n2.prototype.Y = function() {
          var n3;
          if (!this.A)
            throw new Error("Cannot call getHMAC without first setting MAC key");
          var r2 = this.K(this.u.slice(), this.s, this.v, this.B(this.m), this.U);
          return n3 = this.R(this.H, this.L(this.o)), n3 = this.K(r2, this.U, this.S, n3, this.U);
        }, n2;
      }(), c = function(n2, r2) {
        return (c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n3, r3) {
          n3.__proto__ = r3;
        } || function(n3, r3) {
          for (var t2 in r3)
            Object.prototype.hasOwnProperty.call(r3, t2) && (n3[t2] = r3[t2]);
        })(n2, r2);
      };
      function v(n2, r2) {
        function t2() {
          this.constructor = n2;
        }
        c(n2, r2), n2.prototype = null === r2 ? Object.create(r2) : (t2.prototype = r2.prototype, new t2());
      }
      function A(n2, r2) {
        return n2 << r2 | n2 >>> 32 - r2;
      }
      function E(n2, r2) {
        return n2 >>> r2 | n2 << 32 - r2;
      }
      function l(n2, r2) {
        return n2 >>> r2;
      }
      function b(n2, r2, t2) {
        return n2 ^ r2 ^ t2;
      }
      function H(n2, r2, t2) {
        return n2 & r2 ^ ~n2 & t2;
      }
      function d(n2, r2, t2) {
        return n2 & r2 ^ n2 & t2 ^ r2 & t2;
      }
      function S(n2) {
        return E(n2, 2) ^ E(n2, 13) ^ E(n2, 22);
      }
      function p(n2, r2) {
        var t2 = (65535 & n2) + (65535 & r2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16)) << 16 | 65535 & t2;
      }
      function m(n2, r2, t2, e2) {
        var i2 = (65535 & n2) + (65535 & r2) + (65535 & t2) + (65535 & e2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16) + (e2 >>> 16) + (i2 >>> 16)) << 16 | 65535 & i2;
      }
      function y(n2, r2, t2, e2, i2) {
        var o2 = (65535 & n2) + (65535 & r2) + (65535 & t2) + (65535 & e2) + (65535 & i2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16) + (e2 >>> 16) + (i2 >>> 16) + (o2 >>> 16)) << 16 | 65535 & o2;
      }
      function R(n2) {
        return E(n2, 7) ^ E(n2, 18) ^ l(n2, 3);
      }
      function U(n2) {
        return E(n2, 6) ^ E(n2, 11) ^ E(n2, 25);
      }
      function T(n2) {
        return [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      }
      function C(n2, r2) {
        var t2, e2, i2, o2, u2, f2, w2, s2 = [];
        for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o2 = r2[3], u2 = r2[4], w2 = 0; w2 < 80; w2 += 1)
          s2[w2] = w2 < 16 ? n2[w2] : A(s2[w2 - 3] ^ s2[w2 - 8] ^ s2[w2 - 14] ^ s2[w2 - 16], 1), f2 = w2 < 20 ? y(A(t2, 5), H(e2, i2, o2), u2, 1518500249, s2[w2]) : w2 < 40 ? y(A(t2, 5), b(e2, i2, o2), u2, 1859775393, s2[w2]) : w2 < 60 ? y(A(t2, 5), d(e2, i2, o2), u2, 2400959708, s2[w2]) : y(A(t2, 5), b(e2, i2, o2), u2, 3395469782, s2[w2]), u2 = o2, o2 = i2, i2 = A(e2, 30), e2 = t2, t2 = f2;
        return r2[0] = p(t2, r2[0]), r2[1] = p(e2, r2[1]), r2[2] = p(i2, r2[2]), r2[3] = p(o2, r2[3]), r2[4] = p(u2, r2[4]), r2;
      }
      function F(n2, r2, t2, e2) {
        for (var i2, o2 = 15 + (r2 + 65 >>> 9 << 4), u2 = r2 + t2; n2.length <= o2; )
          n2.push(0);
        for (n2[r2 >>> 5] |= 128 << 24 - r2 % 32, n2[o2] = 4294967295 & u2, n2[o2 - 1] = u2 / 4294967296 | 0, i2 = 0; i2 < n2.length; i2 += 16)
          e2 = C(n2.slice(i2, i2 + 16), e2);
        return e2;
      }
      var K = function(n2) {
        function r2(r3, e2, i2) {
          var o2 = this;
          if ("SHA-1" !== r3)
            throw new Error(f);
          var u2 = i2 || {};
          return (o2 = n2.call(this, r3, e2, i2) || this).g = true, o2.F = o2.Y, o2.C = -1, o2.p = t(o2.t, o2.i, o2.C), o2.R = C, o2.B = function(n3) {
            return n3.slice();
          }, o2.L = T, o2.K = F, o2.m = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], o2.S = 512, o2.U = 160, o2.T = false, u2.hmacKey && o2.k(a("hmacKey", u2.hmacKey, o2.C)), o2;
        }
        return v(r2, n2), r2;
      }(h);
      function B(n2) {
        return "SHA-224" == n2 ? o.slice() : u.slice();
      }
      function L(n2, r2) {
        var t2, e2, o2, u2, f2, w2, s2, a2, h2, c2, v2, A2, b2 = [];
        for (t2 = r2[0], e2 = r2[1], o2 = r2[2], u2 = r2[3], f2 = r2[4], w2 = r2[5], s2 = r2[6], a2 = r2[7], v2 = 0; v2 < 64; v2 += 1)
          b2[v2] = v2 < 16 ? n2[v2] : m(E(A2 = b2[v2 - 2], 17) ^ E(A2, 19) ^ l(A2, 10), b2[v2 - 7], R(b2[v2 - 15]), b2[v2 - 16]), h2 = y(a2, U(f2), H(f2, w2, s2), i[v2], b2[v2]), c2 = p(S(t2), d(t2, e2, o2)), a2 = s2, s2 = w2, w2 = f2, f2 = p(u2, h2), u2 = o2, o2 = e2, e2 = t2, t2 = p(h2, c2);
        return r2[0] = p(t2, r2[0]), r2[1] = p(e2, r2[1]), r2[2] = p(o2, r2[2]), r2[3] = p(u2, r2[3]), r2[4] = p(f2, r2[4]), r2[5] = p(w2, r2[5]), r2[6] = p(s2, r2[6]), r2[7] = p(a2, r2[7]), r2;
      }
      var g = function(n2) {
        function r2(r3, e2, i2) {
          var o2 = this;
          if ("SHA-224" !== r3 && "SHA-256" !== r3)
            throw new Error(f);
          var u2 = i2 || {};
          return (o2 = n2.call(this, r3, e2, i2) || this).F = o2.Y, o2.g = true, o2.C = -1, o2.p = t(o2.t, o2.i, o2.C), o2.R = L, o2.B = function(n3) {
            return n3.slice();
          }, o2.L = B, o2.K = function(n3, t2, e3, i3) {
            return function(n4, r4, t3, e4, i4) {
              for (var o3, u3 = 15 + (r4 + 65 >>> 9 << 4), f2 = r4 + t3; n4.length <= u3; )
                n4.push(0);
              for (n4[r4 >>> 5] |= 128 << 24 - r4 % 32, n4[u3] = 4294967295 & f2, n4[u3 - 1] = f2 / 4294967296 | 0, o3 = 0; o3 < n4.length; o3 += 16)
                e4 = L(n4.slice(o3, o3 + 16), e4);
              return "SHA-224" === i4 ? [e4[0], e4[1], e4[2], e4[3], e4[4], e4[5], e4[6]] : e4;
            }(n3, t2, e3, i3, r3);
          }, o2.m = B(r3), o2.S = 512, o2.U = "SHA-224" === r3 ? 224 : 256, o2.T = false, u2.hmacKey && o2.k(a("hmacKey", u2.hmacKey, o2.C)), o2;
        }
        return v(r2, n2), r2;
      }(h), k = function(n2, r2) {
        this.N = n2, this.I = r2;
      };
      function Y(n2, r2) {
        var t2;
        return r2 > 32 ? (t2 = 64 - r2, new k(n2.I << r2 | n2.N >>> t2, n2.N << r2 | n2.I >>> t2)) : 0 !== r2 ? (t2 = 32 - r2, new k(n2.N << r2 | n2.I >>> t2, n2.I << r2 | n2.N >>> t2)) : n2;
      }
      function N(n2, r2) {
        var t2;
        return r2 < 32 ? (t2 = 32 - r2, new k(n2.N >>> r2 | n2.I << t2, n2.I >>> r2 | n2.N << t2)) : (t2 = 64 - r2, new k(n2.I >>> r2 | n2.N << t2, n2.N >>> r2 | n2.I << t2));
      }
      function I(n2, r2) {
        return new k(n2.N >>> r2, n2.I >>> r2 | n2.N << 32 - r2);
      }
      function M(n2, r2, t2) {
        return new k(n2.N & r2.N ^ ~n2.N & t2.N, n2.I & r2.I ^ ~n2.I & t2.I);
      }
      function X(n2, r2, t2) {
        return new k(n2.N & r2.N ^ n2.N & t2.N ^ r2.N & t2.N, n2.I & r2.I ^ n2.I & t2.I ^ r2.I & t2.I);
      }
      function z(n2) {
        var r2 = N(n2, 28), t2 = N(n2, 34), e2 = N(n2, 39);
        return new k(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
      }
      function O(n2, r2) {
        var t2, e2;
        t2 = (65535 & n2.I) + (65535 & r2.I);
        var i2 = (65535 & (e2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2 >>> 16))) << 16 | 65535 & t2;
        return t2 = (65535 & n2.N) + (65535 & r2.N) + (e2 >>> 16), e2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2 >>> 16), new k((65535 & e2) << 16 | 65535 & t2, i2);
      }
      function j(n2, r2, t2, e2) {
        var i2, o2;
        i2 = (65535 & n2.I) + (65535 & r2.I) + (65535 & t2.I) + (65535 & e2.I);
        var u2 = (65535 & (o2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2.I >>> 16) + (e2.I >>> 16) + (i2 >>> 16))) << 16 | 65535 & i2;
        return i2 = (65535 & n2.N) + (65535 & r2.N) + (65535 & t2.N) + (65535 & e2.N) + (o2 >>> 16), o2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2.N >>> 16) + (e2.N >>> 16) + (i2 >>> 16), new k((65535 & o2) << 16 | 65535 & i2, u2);
      }
      function _(n2, r2, t2, e2, i2) {
        var o2, u2;
        o2 = (65535 & n2.I) + (65535 & r2.I) + (65535 & t2.I) + (65535 & e2.I) + (65535 & i2.I);
        var f2 = (65535 & (u2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2.I >>> 16) + (e2.I >>> 16) + (i2.I >>> 16) + (o2 >>> 16))) << 16 | 65535 & o2;
        return o2 = (65535 & n2.N) + (65535 & r2.N) + (65535 & t2.N) + (65535 & e2.N) + (65535 & i2.N) + (u2 >>> 16), u2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2.N >>> 16) + (e2.N >>> 16) + (i2.N >>> 16) + (o2 >>> 16), new k((65535 & u2) << 16 | 65535 & o2, f2);
      }
      function P(n2, r2) {
        return new k(n2.N ^ r2.N, n2.I ^ r2.I);
      }
      function x(n2) {
        var r2 = N(n2, 1), t2 = N(n2, 8), e2 = I(n2, 7);
        return new k(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
      }
      function V(n2) {
        var r2 = N(n2, 14), t2 = N(n2, 18), e2 = N(n2, 41);
        return new k(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
      }
      var Z = [new k(i[0], 3609767458), new k(i[1], 602891725), new k(i[2], 3964484399), new k(i[3], 2173295548), new k(i[4], 4081628472), new k(i[5], 3053834265), new k(i[6], 2937671579), new k(i[7], 3664609560), new k(i[8], 2734883394), new k(i[9], 1164996542), new k(i[10], 1323610764), new k(i[11], 3590304994), new k(i[12], 4068182383), new k(i[13], 991336113), new k(i[14], 633803317), new k(i[15], 3479774868), new k(i[16], 2666613458), new k(i[17], 944711139), new k(i[18], 2341262773), new k(i[19], 2007800933), new k(i[20], 1495990901), new k(i[21], 1856431235), new k(i[22], 3175218132), new k(i[23], 2198950837), new k(i[24], 3999719339), new k(i[25], 766784016), new k(i[26], 2566594879), new k(i[27], 3203337956), new k(i[28], 1034457026), new k(i[29], 2466948901), new k(i[30], 3758326383), new k(i[31], 168717936), new k(i[32], 1188179964), new k(i[33], 1546045734), new k(i[34], 1522805485), new k(i[35], 2643833823), new k(i[36], 2343527390), new k(i[37], 1014477480), new k(i[38], 1206759142), new k(i[39], 344077627), new k(i[40], 1290863460), new k(i[41], 3158454273), new k(i[42], 3505952657), new k(i[43], 106217008), new k(i[44], 3606008344), new k(i[45], 1432725776), new k(i[46], 1467031594), new k(i[47], 851169720), new k(i[48], 3100823752), new k(i[49], 1363258195), new k(i[50], 3750685593), new k(i[51], 3785050280), new k(i[52], 3318307427), new k(i[53], 3812723403), new k(i[54], 2003034995), new k(i[55], 3602036899), new k(i[56], 1575990012), new k(i[57], 1125592928), new k(i[58], 2716904306), new k(i[59], 442776044), new k(i[60], 593698344), new k(i[61], 3733110249), new k(i[62], 2999351573), new k(i[63], 3815920427), new k(3391569614, 3928383900), new k(3515267271, 566280711), new k(3940187606, 3454069534), new k(4118630271, 4000239992), new k(116418474, 1914138554), new k(174292421, 2731055270), new k(289380356, 3203993006), new k(460393269, 320620315), new k(685471733, 587496836), new k(852142971, 1086792851), new k(1017036298, 365543100), new k(1126000580, 2618297676), new k(1288033470, 3409855158), new k(1501505948, 4234509866), new k(1607167915, 987167468), new k(1816402316, 1246189591)];
      function q(n2) {
        return "SHA-384" === n2 ? [new k(3418070365, o[0]), new k(1654270250, o[1]), new k(2438529370, o[2]), new k(355462360, o[3]), new k(1731405415, o[4]), new k(41048885895, o[5]), new k(3675008525, o[6]), new k(1203062813, o[7])] : [new k(u[0], 4089235720), new k(u[1], 2227873595), new k(u[2], 4271175723), new k(u[3], 1595750129), new k(u[4], 2917565137), new k(u[5], 725511199), new k(u[6], 4215389547), new k(u[7], 327033209)];
      }
      function D(n2, r2) {
        var t2, e2, i2, o2, u2, f2, w2, s2, a2, h2, c2, v2, A2, E2, l2, b2, H2 = [];
        for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o2 = r2[3], u2 = r2[4], f2 = r2[5], w2 = r2[6], s2 = r2[7], c2 = 0; c2 < 80; c2 += 1)
          c2 < 16 ? (v2 = 2 * c2, H2[c2] = new k(n2[v2], n2[v2 + 1])) : H2[c2] = j((A2 = H2[c2 - 2], E2 = void 0, l2 = void 0, b2 = void 0, E2 = N(A2, 19), l2 = N(A2, 61), b2 = I(A2, 6), new k(E2.N ^ l2.N ^ b2.N, E2.I ^ l2.I ^ b2.I)), H2[c2 - 7], x(H2[c2 - 15]), H2[c2 - 16]), a2 = _(s2, V(u2), M(u2, f2, w2), Z[c2], H2[c2]), h2 = O(z(t2), X(t2, e2, i2)), s2 = w2, w2 = f2, f2 = u2, u2 = O(o2, a2), o2 = i2, i2 = e2, e2 = t2, t2 = O(a2, h2);
        return r2[0] = O(t2, r2[0]), r2[1] = O(e2, r2[1]), r2[2] = O(i2, r2[2]), r2[3] = O(o2, r2[3]), r2[4] = O(u2, r2[4]), r2[5] = O(f2, r2[5]), r2[6] = O(w2, r2[6]), r2[7] = O(s2, r2[7]), r2;
      }
      var G = function(n2) {
        function r2(r3, e2, i2) {
          var o2 = this;
          if ("SHA-384" !== r3 && "SHA-512" !== r3)
            throw new Error(f);
          var u2 = i2 || {};
          return (o2 = n2.call(this, r3, e2, i2) || this).F = o2.Y, o2.g = true, o2.C = -1, o2.p = t(o2.t, o2.i, o2.C), o2.R = D, o2.B = function(n3) {
            return n3.slice();
          }, o2.L = q, o2.K = function(n3, t2, e3, i3) {
            return function(n4, r4, t3, e4, i4) {
              for (var o3, u3 = 31 + (r4 + 129 >>> 10 << 5), f2 = r4 + t3; n4.length <= u3; )
                n4.push(0);
              for (n4[r4 >>> 5] |= 128 << 24 - r4 % 32, n4[u3] = 4294967295 & f2, n4[u3 - 1] = f2 / 4294967296 | 0, o3 = 0; o3 < n4.length; o3 += 32)
                e4 = D(n4.slice(o3, o3 + 32), e4);
              return "SHA-384" === i4 ? [(e4 = e4)[0].N, e4[0].I, e4[1].N, e4[1].I, e4[2].N, e4[2].I, e4[3].N, e4[3].I, e4[4].N, e4[4].I, e4[5].N, e4[5].I] : [e4[0].N, e4[0].I, e4[1].N, e4[1].I, e4[2].N, e4[2].I, e4[3].N, e4[3].I, e4[4].N, e4[4].I, e4[5].N, e4[5].I, e4[6].N, e4[6].I, e4[7].N, e4[7].I];
            }(n3, t2, e3, i3, r3);
          }, o2.m = q(r3), o2.S = 1024, o2.U = "SHA-384" === r3 ? 384 : 512, o2.T = false, u2.hmacKey && o2.k(a("hmacKey", u2.hmacKey, o2.C)), o2;
        }
        return v(r2, n2), r2;
      }(h), J = [new k(0, 1), new k(0, 32898), new k(2147483648, 32906), new k(2147483648, 2147516416), new k(0, 32907), new k(0, 2147483649), new k(2147483648, 2147516545), new k(2147483648, 32777), new k(0, 138), new k(0, 136), new k(0, 2147516425), new k(0, 2147483658), new k(0, 2147516555), new k(2147483648, 139), new k(2147483648, 32905), new k(2147483648, 32771), new k(2147483648, 32770), new k(2147483648, 128), new k(0, 32778), new k(2147483648, 2147483658), new k(2147483648, 2147516545), new k(2147483648, 32896), new k(0, 2147483649), new k(2147483648, 2147516424)], Q = [[0, 36, 3, 41, 18], [1, 44, 10, 45, 2], [62, 6, 43, 15, 61], [28, 55, 25, 21, 56], [27, 20, 39, 8, 14]];
      function W(n2) {
        var r2, t2 = [];
        for (r2 = 0; r2 < 5; r2 += 1)
          t2[r2] = [new k(0, 0), new k(0, 0), new k(0, 0), new k(0, 0), new k(0, 0)];
        return t2;
      }
      function $(n2) {
        var r2, t2 = [];
        for (r2 = 0; r2 < 5; r2 += 1)
          t2[r2] = n2[r2].slice();
        return t2;
      }
      function nn(n2, r2) {
        var t2, e2, i2, o2, u2, f2, w2, s2, a2, h2 = [], c2 = [];
        if (null !== n2)
          for (e2 = 0; e2 < n2.length; e2 += 2)
            r2[(e2 >>> 1) % 5][(e2 >>> 1) / 5 | 0] = P(r2[(e2 >>> 1) % 5][(e2 >>> 1) / 5 | 0], new k(n2[e2 + 1], n2[e2]));
        for (t2 = 0; t2 < 24; t2 += 1) {
          for (o2 = W(), e2 = 0; e2 < 5; e2 += 1)
            h2[e2] = (u2 = r2[e2][0], f2 = r2[e2][1], w2 = r2[e2][2], s2 = r2[e2][3], a2 = r2[e2][4], new k(u2.N ^ f2.N ^ w2.N ^ s2.N ^ a2.N, u2.I ^ f2.I ^ w2.I ^ s2.I ^ a2.I));
          for (e2 = 0; e2 < 5; e2 += 1)
            c2[e2] = P(h2[(e2 + 4) % 5], Y(h2[(e2 + 1) % 5], 1));
          for (e2 = 0; e2 < 5; e2 += 1)
            for (i2 = 0; i2 < 5; i2 += 1)
              r2[e2][i2] = P(r2[e2][i2], c2[e2]);
          for (e2 = 0; e2 < 5; e2 += 1)
            for (i2 = 0; i2 < 5; i2 += 1)
              o2[i2][(2 * e2 + 3 * i2) % 5] = Y(r2[e2][i2], Q[e2][i2]);
          for (e2 = 0; e2 < 5; e2 += 1)
            for (i2 = 0; i2 < 5; i2 += 1)
              r2[e2][i2] = P(o2[e2][i2], new k(~o2[(e2 + 1) % 5][i2].N & o2[(e2 + 2) % 5][i2].N, ~o2[(e2 + 1) % 5][i2].I & o2[(e2 + 2) % 5][i2].I));
          r2[0][0] = P(r2[0][0], J[t2]);
        }
        return r2;
      }
      function rn(n2) {
        var r2, t2, e2 = 0, i2 = [0, 0], o2 = [4294967295 & n2, n2 / 4294967296 & 2097151];
        for (r2 = 6; r2 >= 0; r2--)
          0 === (t2 = o2[r2 >> 2] >>> 8 * r2 & 255) && 0 === e2 || (i2[e2 + 1 >> 2] |= t2 << 8 * (e2 + 1), e2 += 1);
        return e2 = 0 !== e2 ? e2 : 1, i2[0] |= e2, { value: e2 + 1 > 4 ? i2 : [i2[0]], binLen: 8 + 8 * e2 };
      }
      function tn(n2) {
        return w(rn(n2.binLen), n2);
      }
      function en(n2, r2) {
        var t2, e2 = rn(r2), i2 = r2 >>> 2, o2 = (i2 - (e2 = w(e2, n2)).value.length % i2) % i2;
        for (t2 = 0; t2 < o2; t2++)
          e2.value.push(0);
        return e2.value;
      }
      var on = function(n2) {
        function r2(r3, e2, i2) {
          var o2 = this, u2 = 6, w2 = 0, s2 = i2 || {};
          if (1 !== (o2 = n2.call(this, r3, e2, i2) || this).numRounds) {
            if (s2.kmacKey || s2.hmacKey)
              throw new Error("Cannot set numRounds with MAC");
            if ("CSHAKE128" === o2.o || "CSHAKE256" === o2.o)
              throw new Error("Cannot set numRounds for CSHAKE variants");
          }
          switch (o2.C = 1, o2.p = t(o2.t, o2.i, o2.C), o2.R = nn, o2.B = $, o2.L = W, o2.m = W(), o2.T = false, r3) {
            case "SHA3-224":
              o2.S = w2 = 1152, o2.U = 224, o2.g = true, o2.F = o2.Y;
              break;
            case "SHA3-256":
              o2.S = w2 = 1088, o2.U = 256, o2.g = true, o2.F = o2.Y;
              break;
            case "SHA3-384":
              o2.S = w2 = 832, o2.U = 384, o2.g = true, o2.F = o2.Y;
              break;
            case "SHA3-512":
              o2.S = w2 = 576, o2.U = 512, o2.g = true, o2.F = o2.Y;
              break;
            case "SHAKE128":
              u2 = 31, o2.S = w2 = 1344, o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
              break;
            case "SHAKE256":
              u2 = 31, o2.S = w2 = 1088, o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
              break;
            case "KMAC128":
              u2 = 4, o2.S = w2 = 1344, o2.M(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = o2.X;
              break;
            case "KMAC256":
              u2 = 4, o2.S = w2 = 1088, o2.M(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = o2.X;
              break;
            case "CSHAKE128":
              o2.S = w2 = 1344, u2 = o2.O(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
              break;
            case "CSHAKE256":
              o2.S = w2 = 1088, u2 = o2.O(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
              break;
            default:
              throw new Error(f);
          }
          return o2.K = function(n3, r4, t2, e3, i3) {
            return function(n4, r5, t3, e4, i4, o3, u3) {
              var f2, w3, s3 = 0, a2 = [], h2 = i4 >>> 5, c2 = r5 >>> 5;
              for (f2 = 0; f2 < c2 && r5 >= i4; f2 += h2)
                e4 = nn(n4.slice(f2, f2 + h2), e4), r5 -= i4;
              for (n4 = n4.slice(f2), r5 %= i4; n4.length < h2; )
                n4.push(0);
              for (n4[(f2 = r5 >>> 3) >> 2] ^= o3 << f2 % 4 * 8, n4[h2 - 1] ^= 2147483648, e4 = nn(n4, e4); 32 * a2.length < u3 && (w3 = e4[s3 % 5][s3 / 5 | 0], a2.push(w3.I), !(32 * a2.length >= u3)); )
                a2.push(w3.N), 0 == 64 * (s3 += 1) % i4 && (nn(null, e4), s3 = 0);
              return a2;
            }(n3, r4, 0, e3, w2, u2, i3);
          }, s2.hmacKey && o2.k(a("hmacKey", s2.hmacKey, o2.C)), o2;
        }
        return v(r2, n2), r2.prototype.O = function(n3, r3) {
          var t2 = function(n4) {
            var r4 = n4 || {};
            return { funcName: a("funcName", r4.funcName, 1, { value: [], binLen: 0 }), customization: a("Customization", r4.customization, 1, { value: [], binLen: 0 }) };
          }(n3 || {});
          r3 && (t2.funcName = r3);
          var e2 = w(tn(t2.funcName), tn(t2.customization));
          if (0 !== t2.customization.binLen || 0 !== t2.funcName.binLen) {
            for (var i2 = en(e2, this.S >>> 3), o2 = 0; o2 < i2.length; o2 += this.S >>> 5)
              this.m = this.R(i2.slice(o2, o2 + (this.S >>> 5)), this.m), this.v += this.S;
            return 4;
          }
          return 31;
        }, r2.prototype.M = function(n3) {
          var r3 = function(n4) {
            var r4 = n4 || {};
            return { kmacKey: a("kmacKey", r4.kmacKey, 1), funcName: { value: [1128353099], binLen: 32 }, customization: a("Customization", r4.customization, 1, { value: [], binLen: 0 }) };
          }(n3 || {});
          this.O(n3, r3.funcName);
          for (var t2 = en(tn(r3.kmacKey), this.S >>> 3), e2 = 0; e2 < t2.length; e2 += this.S >>> 5)
            this.m = this.R(t2.slice(e2, e2 + (this.S >>> 5)), this.m), this.v += this.S;
          this.A = true;
        }, r2.prototype.X = function(n3) {
          var r3 = w({ value: this.u.slice(), binLen: this.s }, function(n4) {
            var r4, t2, e2 = 0, i2 = [0, 0], o2 = [4294967295 & n4, n4 / 4294967296 & 2097151];
            for (r4 = 6; r4 >= 0; r4--)
              0 == (t2 = o2[r4 >> 2] >>> 8 * r4 & 255) && 0 === e2 || (i2[e2 >> 2] |= t2 << 8 * e2, e2 += 1);
            return i2[(e2 = 0 !== e2 ? e2 : 1) >> 2] |= e2 << 8 * e2, { value: e2 + 1 > 4 ? i2 : [i2[0]], binLen: 8 + 8 * e2 };
          }(n3.outputLen));
          return this.K(r3.value, r3.binLen, this.v, this.B(this.m), n3.outputLen);
        }, r2;
      }(h);
      return function() {
        function n2(n3, r2, t2) {
          if ("SHA-1" == n3)
            this.j = new K(n3, r2, t2);
          else if ("SHA-224" == n3 || "SHA-256" == n3)
            this.j = new g(n3, r2, t2);
          else if ("SHA-384" == n3 || "SHA-512" == n3)
            this.j = new G(n3, r2, t2);
          else {
            if ("SHA3-224" != n3 && "SHA3-256" != n3 && "SHA3-384" != n3 && "SHA3-512" != n3 && "SHAKE128" != n3 && "SHAKE256" != n3 && "CSHAKE128" != n3 && "CSHAKE256" != n3 && "KMAC128" != n3 && "KMAC256" != n3)
              throw new Error(f);
            this.j = new on(n3, r2, t2);
          }
        }
        return n2.prototype.update = function(n3) {
          this.j.update(n3);
        }, n2.prototype.getHash = function(n3, r2) {
          return this.j.getHash(n3, r2);
        }, n2.prototype.setHMACKey = function(n3, r2, t2) {
          this.j.setHMACKey(n3, r2, t2);
        }, n2.prototype.getHMAC = function(n3, r2) {
          return this.j.getHMAC(n3, r2);
        }, n2;
      }();
    });
  }
});

// node_modules/ton-crypto-primitives/dist/browser/getSecureRandom.js
var require_getSecureRandom = __commonJS({
  "node_modules/ton-crypto-primitives/dist/browser/getSecureRandom.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSecureRandomWords = exports.getSecureRandomBytes = void 0;
    function getSecureRandomBytes(size4) {
      return import_buffer.Buffer.from(window.crypto.getRandomValues(new Uint8Array(size4)));
    }
    exports.getSecureRandomBytes = getSecureRandomBytes;
    function getSecureRandomWords(size4) {
      return window.crypto.getRandomValues(new Uint16Array(size4));
    }
    exports.getSecureRandomWords = getSecureRandomWords;
  }
});

// node_modules/ton-crypto-primitives/dist/browser/hmac_sha512.js
var require_hmac_sha512 = __commonJS({
  "node_modules/ton-crypto-primitives/dist/browser/hmac_sha512.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac_sha512 = void 0;
    async function hmac_sha512(key, data) {
      let keyBuffer = typeof key === "string" ? import_buffer.Buffer.from(key, "utf-8") : key;
      let dataBuffer = typeof data === "string" ? import_buffer.Buffer.from(data, "utf-8") : data;
      const hmacAlgo = { name: "HMAC", hash: "SHA-512" };
      const hmacKey = await window.crypto.subtle.importKey("raw", keyBuffer, hmacAlgo, false, ["sign"]);
      return import_buffer.Buffer.from(await crypto.subtle.sign(hmacAlgo, hmacKey, dataBuffer));
    }
    exports.hmac_sha512 = hmac_sha512;
  }
});

// node_modules/ton-crypto-primitives/dist/browser/pbkdf2_sha512.js
var require_pbkdf2_sha512 = __commonJS({
  "node_modules/ton-crypto-primitives/dist/browser/pbkdf2_sha512.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf2_sha512 = void 0;
    async function pbkdf2_sha512(key, salt, iterations, keyLen) {
      const keyBuffer = typeof key === "string" ? import_buffer.Buffer.from(key, "utf-8") : key;
      const saltBuffer = typeof salt === "string" ? import_buffer.Buffer.from(salt, "utf-8") : salt;
      const pbkdf2_key = await window.crypto.subtle.importKey("raw", keyBuffer, { name: "PBKDF2" }, false, ["deriveBits"]);
      const derivedBits = await window.crypto.subtle.deriveBits({ name: "PBKDF2", hash: "SHA-512", salt: saltBuffer, iterations }, pbkdf2_key, keyLen * 8);
      return import_buffer.Buffer.from(derivedBits);
    }
    exports.pbkdf2_sha512 = pbkdf2_sha512;
  }
});

// node_modules/ton-crypto-primitives/dist/browser/sha256.js
var require_sha256 = __commonJS({
  "node_modules/ton-crypto-primitives/dist/browser/sha256.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha256 = void 0;
    async function sha256(source) {
      if (typeof source === "string") {
        return import_buffer.Buffer.from(await crypto.subtle.digest("SHA-256", import_buffer.Buffer.from(source, "utf-8")));
      }
      return import_buffer.Buffer.from(await crypto.subtle.digest("SHA-256", source));
    }
    exports.sha256 = sha256;
  }
});

// node_modules/ton-crypto-primitives/dist/browser/sha512.js
var require_sha512 = __commonJS({
  "node_modules/ton-crypto-primitives/dist/browser/sha512.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha512 = void 0;
    async function sha512(source) {
      if (typeof source === "string") {
        return import_buffer.Buffer.from(await crypto.subtle.digest("SHA-512", import_buffer.Buffer.from(source, "utf-8")));
      }
      return import_buffer.Buffer.from(await crypto.subtle.digest("SHA-512", source));
    }
    exports.sha512 = sha512;
  }
});

// node_modules/ton-crypto-primitives/dist/browser.js
var require_browser = __commonJS({
  "node_modules/ton-crypto-primitives/dist/browser.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha512 = exports.sha256 = exports.pbkdf2_sha512 = exports.hmac_sha512 = exports.getSecureRandomWords = exports.getSecureRandomBytes = void 0;
    var getSecureRandom_1 = require_getSecureRandom();
    Object.defineProperty(exports, "getSecureRandomBytes", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomBytes;
    } });
    Object.defineProperty(exports, "getSecureRandomWords", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomWords;
    } });
    var hmac_sha512_1 = require_hmac_sha512();
    Object.defineProperty(exports, "hmac_sha512", { enumerable: true, get: function() {
      return hmac_sha512_1.hmac_sha512;
    } });
    var pbkdf2_sha512_1 = require_pbkdf2_sha512();
    Object.defineProperty(exports, "pbkdf2_sha512", { enumerable: true, get: function() {
      return pbkdf2_sha512_1.pbkdf2_sha512;
    } });
    var sha256_1 = require_sha256();
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha256_1.sha256;
    } });
    var sha512_1 = require_sha512();
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha512_1.sha512;
    } });
  }
});

// node_modules/ton-crypto/dist/primitives/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/ton-crypto/dist/primitives/sha256.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha256 = exports.sha256_fallback = exports.sha256_sync = void 0;
    var jssha_1 = __importDefault(require_sha());
    var ton_crypto_primitives_1 = require_browser();
    function sha256_sync(source) {
      let src;
      if (typeof source === "string") {
        src = import_buffer.Buffer.from(source, "utf-8").toString("hex");
      } else {
        src = source.toString("hex");
      }
      let hasher = new jssha_1.default("SHA-256", "HEX");
      hasher.update(src);
      let res = hasher.getHash("HEX");
      return import_buffer.Buffer.from(res, "hex");
    }
    exports.sha256_sync = sha256_sync;
    async function sha256_fallback(source) {
      return sha256_sync(source);
    }
    exports.sha256_fallback = sha256_fallback;
    function sha256(source) {
      return (0, ton_crypto_primitives_1.sha256)(source);
    }
    exports.sha256 = sha256;
  }
});

// node_modules/ton-crypto/dist/primitives/sha512.js
var require_sha5122 = __commonJS({
  "node_modules/ton-crypto/dist/primitives/sha512.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha512 = exports.sha512_fallback = exports.sha512_sync = void 0;
    var jssha_1 = __importDefault(require_sha());
    var ton_crypto_primitives_1 = require_browser();
    function sha512_sync(source) {
      let src;
      if (typeof source === "string") {
        src = import_buffer.Buffer.from(source, "utf-8").toString("hex");
      } else {
        src = source.toString("hex");
      }
      let hasher = new jssha_1.default("SHA-512", "HEX");
      hasher.update(src);
      let res = hasher.getHash("HEX");
      return import_buffer.Buffer.from(res, "hex");
    }
    exports.sha512_sync = sha512_sync;
    async function sha512_fallback(source) {
      return sha512_sync(source);
    }
    exports.sha512_fallback = sha512_fallback;
    async function sha512(source) {
      return (0, ton_crypto_primitives_1.sha512)(source);
    }
    exports.sha512 = sha512;
  }
});

// node_modules/ton-crypto/dist/primitives/pbkdf2_sha512.js
var require_pbkdf2_sha5122 = __commonJS({
  "node_modules/ton-crypto/dist/primitives/pbkdf2_sha512.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf2_sha512 = void 0;
    var ton_crypto_primitives_1 = require_browser();
    function pbkdf2_sha512(key, salt, iterations, keyLen) {
      return (0, ton_crypto_primitives_1.pbkdf2_sha512)(key, salt, iterations, keyLen);
    }
    exports.pbkdf2_sha512 = pbkdf2_sha512;
  }
});

// node_modules/ton-crypto/dist/primitives/hmac_sha512.js
var require_hmac_sha5122 = __commonJS({
  "node_modules/ton-crypto/dist/primitives/hmac_sha512.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac_sha512 = exports.hmac_sha512_fallback = void 0;
    var jssha_1 = __importDefault(require_sha());
    var ton_crypto_primitives_1 = require_browser();
    async function hmac_sha512_fallback(key, data) {
      let keyBuffer = typeof key === "string" ? import_buffer.Buffer.from(key, "utf-8") : key;
      let dataBuffer = typeof data === "string" ? import_buffer.Buffer.from(data, "utf-8") : data;
      const shaObj = new jssha_1.default("SHA-512", "HEX", {
        hmacKey: { value: keyBuffer.toString("hex"), format: "HEX" }
      });
      shaObj.update(dataBuffer.toString("hex"));
      const hmac = shaObj.getHash("HEX");
      return import_buffer.Buffer.from(hmac, "hex");
    }
    exports.hmac_sha512_fallback = hmac_sha512_fallback;
    function hmac_sha512(key, data) {
      return (0, ton_crypto_primitives_1.hmac_sha512)(key, data);
    }
    exports.hmac_sha512 = hmac_sha512;
  }
});

// node_modules/ton-crypto/dist/primitives/getSecureRandom.js
var require_getSecureRandom2 = __commonJS({
  "node_modules/ton-crypto/dist/primitives/getSecureRandom.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSecureRandomNumber = exports.getSecureRandomWords = exports.getSecureRandomBytes = void 0;
    var ton_crypto_primitives_1 = require_browser();
    async function getSecureRandomBytes(size4) {
      return (0, ton_crypto_primitives_1.getSecureRandomBytes)(size4);
    }
    exports.getSecureRandomBytes = getSecureRandomBytes;
    async function getSecureRandomWords(size4) {
      return getSecureRandomWords(size4);
    }
    exports.getSecureRandomWords = getSecureRandomWords;
    async function getSecureRandomNumber(min5, max5) {
      let range4 = max5 - min5;
      var bitsNeeded = Math.ceil(Math.log2(range4));
      if (bitsNeeded > 53) {
        throw new Error("Range is too large");
      }
      var bytesNeeded = Math.ceil(bitsNeeded / 8);
      var mask = Math.pow(2, bitsNeeded) - 1;
      while (true) {
        let res = await getSecureRandomBytes(bitsNeeded);
        let power = (bytesNeeded - 1) * 8;
        let numberValue = 0;
        for (var i = 0; i < bytesNeeded; i++) {
          numberValue += res[i] * Math.pow(2, power);
          power -= 8;
        }
        numberValue = numberValue & mask;
        if (numberValue >= range4) {
          continue;
        }
        return min5 + numberValue;
      }
    }
    exports.getSecureRandomNumber = getSecureRandomNumber;
  }
});

// node_modules/ton-crypto/dist/passwords/wordlist.js
var require_wordlist = __commonJS({
  "node_modules/ton-crypto/dist/passwords/wordlist.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wordlist = void 0;
    exports.wordlist = [
      "abacus",
      "abdomen",
      "abdominal",
      "abide",
      "abiding",
      "ability",
      "ablaze",
      "able",
      "abnormal",
      "abrasion",
      "abrasive",
      "abreast",
      "abridge",
      "abroad",
      "abruptly",
      "absence",
      "absentee",
      "absently",
      "absinthe",
      "absolute",
      "absolve",
      "abstain",
      "abstract",
      "absurd",
      "accent",
      "acclaim",
      "acclimate",
      "accompany",
      "account",
      "accuracy",
      "accurate",
      "accustom",
      "acetone",
      "achiness",
      "aching",
      "acid",
      "acorn",
      "acquaint",
      "acquire",
      "acre",
      "acrobat",
      "acronym",
      "acting",
      "action",
      "activate",
      "activator",
      "active",
      "activism",
      "activist",
      "activity",
      "actress",
      "acts",
      "acutely",
      "acuteness",
      "aeration",
      "aerobics",
      "aerosol",
      "aerospace",
      "afar",
      "affair",
      "affected",
      "affecting",
      "affection",
      "affidavit",
      "affiliate",
      "affirm",
      "affix",
      "afflicted",
      "affluent",
      "afford",
      "affront",
      "aflame",
      "afloat",
      "aflutter",
      "afoot",
      "afraid",
      "afterglow",
      "afterlife",
      "aftermath",
      "aftermost",
      "afternoon",
      "aged",
      "ageless",
      "agency",
      "agenda",
      "agent",
      "aggregate",
      "aghast",
      "agile",
      "agility",
      "aging",
      "agnostic",
      "agonize",
      "agonizing",
      "agony",
      "agreeable",
      "agreeably",
      "agreed",
      "agreeing",
      "agreement",
      "aground",
      "ahead",
      "ahoy",
      "aide",
      "aids",
      "aim",
      "ajar",
      "alabaster",
      "alarm",
      "albatross",
      "album",
      "alfalfa",
      "algebra",
      "algorithm",
      "alias",
      "alibi",
      "alienable",
      "alienate",
      "aliens",
      "alike",
      "alive",
      "alkaline",
      "alkalize",
      "almanac",
      "almighty",
      "almost",
      "aloe",
      "aloft",
      "aloha",
      "alone",
      "alongside",
      "aloof",
      "alphabet",
      "alright",
      "although",
      "altitude",
      "alto",
      "aluminum",
      "alumni",
      "always",
      "amaretto",
      "amaze",
      "amazingly",
      "amber",
      "ambiance",
      "ambiguity",
      "ambiguous",
      "ambition",
      "ambitious",
      "ambulance",
      "ambush",
      "amendable",
      "amendment",
      "amends",
      "amenity",
      "amiable",
      "amicably",
      "amid",
      "amigo",
      "amino",
      "amiss",
      "ammonia",
      "ammonium",
      "amnesty",
      "amniotic",
      "among",
      "amount",
      "amperage",
      "ample",
      "amplifier",
      "amplify",
      "amply",
      "amuck",
      "amulet",
      "amusable",
      "amused",
      "amusement",
      "amuser",
      "amusing",
      "anaconda",
      "anaerobic",
      "anagram",
      "anatomist",
      "anatomy",
      "anchor",
      "anchovy",
      "ancient",
      "android",
      "anemia",
      "anemic",
      "aneurism",
      "anew",
      "angelfish",
      "angelic",
      "anger",
      "angled",
      "angler",
      "angles",
      "angling",
      "angrily",
      "angriness",
      "anguished",
      "angular",
      "animal",
      "animate",
      "animating",
      "animation",
      "animator",
      "anime",
      "animosity",
      "ankle",
      "annex",
      "annotate",
      "announcer",
      "annoying",
      "annually",
      "annuity",
      "anointer",
      "another",
      "answering",
      "antacid",
      "antarctic",
      "anteater",
      "antelope",
      "antennae",
      "anthem",
      "anthill",
      "anthology",
      "antibody",
      "antics",
      "antidote",
      "antihero",
      "antiquely",
      "antiques",
      "antiquity",
      "antirust",
      "antitoxic",
      "antitrust",
      "antiviral",
      "antivirus",
      "antler",
      "antonym",
      "antsy",
      "anvil",
      "anybody",
      "anyhow",
      "anymore",
      "anyone",
      "anyplace",
      "anything",
      "anytime",
      "anyway",
      "anywhere",
      "aorta",
      "apache",
      "apostle",
      "appealing",
      "appear",
      "appease",
      "appeasing",
      "appendage",
      "appendix",
      "appetite",
      "appetizer",
      "applaud",
      "applause",
      "apple",
      "appliance",
      "applicant",
      "applied",
      "apply",
      "appointee",
      "appraisal",
      "appraiser",
      "apprehend",
      "approach",
      "approval",
      "approve",
      "apricot",
      "april",
      "apron",
      "aptitude",
      "aptly",
      "aqua",
      "aqueduct",
      "arbitrary",
      "arbitrate",
      "ardently",
      "area",
      "arena",
      "arguable",
      "arguably",
      "argue",
      "arise",
      "armadillo",
      "armband",
      "armchair",
      "armed",
      "armful",
      "armhole",
      "arming",
      "armless",
      "armoire",
      "armored",
      "armory",
      "armrest",
      "army",
      "aroma",
      "arose",
      "around",
      "arousal",
      "arrange",
      "array",
      "arrest",
      "arrival",
      "arrive",
      "arrogance",
      "arrogant",
      "arson",
      "art",
      "ascend",
      "ascension",
      "ascent",
      "ascertain",
      "ashamed",
      "ashen",
      "ashes",
      "ashy",
      "aside",
      "askew",
      "asleep",
      "asparagus",
      "aspect",
      "aspirate",
      "aspire",
      "aspirin",
      "astonish",
      "astound",
      "astride",
      "astrology",
      "astronaut",
      "astronomy",
      "astute",
      "atlantic",
      "atlas",
      "atom",
      "atonable",
      "atop",
      "atrium",
      "atrocious",
      "atrophy",
      "attach",
      "attain",
      "attempt",
      "attendant",
      "attendee",
      "attention",
      "attentive",
      "attest",
      "attic",
      "attire",
      "attitude",
      "attractor",
      "attribute",
      "atypical",
      "auction",
      "audacious",
      "audacity",
      "audible",
      "audibly",
      "audience",
      "audio",
      "audition",
      "augmented",
      "august",
      "authentic",
      "author",
      "autism",
      "autistic",
      "autograph",
      "automaker",
      "automated",
      "automatic",
      "autopilot",
      "available",
      "avalanche",
      "avatar",
      "avenge",
      "avenging",
      "avenue",
      "average",
      "aversion",
      "avert",
      "aviation",
      "aviator",
      "avid",
      "avoid",
      "await",
      "awaken",
      "award",
      "aware",
      "awhile",
      "awkward",
      "awning",
      "awoke",
      "awry",
      "axis",
      "babble",
      "babbling",
      "babied",
      "baboon",
      "backache",
      "backboard",
      "backboned",
      "backdrop",
      "backed",
      "backer",
      "backfield",
      "backfire",
      "backhand",
      "backing",
      "backlands",
      "backlash",
      "backless",
      "backlight",
      "backlit",
      "backlog",
      "backpack",
      "backpedal",
      "backrest",
      "backroom",
      "backshift",
      "backside",
      "backslid",
      "backspace",
      "backspin",
      "backstab",
      "backstage",
      "backtalk",
      "backtrack",
      "backup",
      "backward",
      "backwash",
      "backwater",
      "backyard",
      "bacon",
      "bacteria",
      "bacterium",
      "badass",
      "badge",
      "badland",
      "badly",
      "badness",
      "baffle",
      "baffling",
      "bagel",
      "bagful",
      "baggage",
      "bagged",
      "baggie",
      "bagginess",
      "bagging",
      "baggy",
      "bagpipe",
      "baguette",
      "baked",
      "bakery",
      "bakeshop",
      "baking",
      "balance",
      "balancing",
      "balcony",
      "balmy",
      "balsamic",
      "bamboo",
      "banana",
      "banish",
      "banister",
      "banjo",
      "bankable",
      "bankbook",
      "banked",
      "banker",
      "banking",
      "banknote",
      "bankroll",
      "banner",
      "bannister",
      "banshee",
      "banter",
      "barbecue",
      "barbed",
      "barbell",
      "barber",
      "barcode",
      "barge",
      "bargraph",
      "barista",
      "baritone",
      "barley",
      "barmaid",
      "barman",
      "barn",
      "barometer",
      "barrack",
      "barracuda",
      "barrel",
      "barrette",
      "barricade",
      "barrier",
      "barstool",
      "bartender",
      "barterer",
      "bash",
      "basically",
      "basics",
      "basil",
      "basin",
      "basis",
      "basket",
      "batboy",
      "batch",
      "bath",
      "baton",
      "bats",
      "battalion",
      "battered",
      "battering",
      "battery",
      "batting",
      "battle",
      "bauble",
      "bazooka",
      "blabber",
      "bladder",
      "blade",
      "blah",
      "blame",
      "blaming",
      "blanching",
      "blandness",
      "blank",
      "blaspheme",
      "blasphemy",
      "blast",
      "blatancy",
      "blatantly",
      "blazer",
      "blazing",
      "bleach",
      "bleak",
      "bleep",
      "blemish",
      "blend",
      "bless",
      "blighted",
      "blimp",
      "bling",
      "blinked",
      "blinker",
      "blinking",
      "blinks",
      "blip",
      "blissful",
      "blitz",
      "blizzard",
      "bloated",
      "bloating",
      "blob",
      "blog",
      "bloomers",
      "blooming",
      "blooper",
      "blot",
      "blouse",
      "blubber",
      "bluff",
      "bluish",
      "blunderer",
      "blunt",
      "blurb",
      "blurred",
      "blurry",
      "blurt",
      "blush",
      "blustery",
      "boaster",
      "boastful",
      "boasting",
      "boat",
      "bobbed",
      "bobbing",
      "bobble",
      "bobcat",
      "bobsled",
      "bobtail",
      "bodacious",
      "body",
      "bogged",
      "boggle",
      "bogus",
      "boil",
      "bok",
      "bolster",
      "bolt",
      "bonanza",
      "bonded",
      "bonding",
      "bondless",
      "boned",
      "bonehead",
      "boneless",
      "bonelike",
      "boney",
      "bonfire",
      "bonnet",
      "bonsai",
      "bonus",
      "bony",
      "boogeyman",
      "boogieman",
      "book",
      "boondocks",
      "booted",
      "booth",
      "bootie",
      "booting",
      "bootlace",
      "bootleg",
      "boots",
      "boozy",
      "borax",
      "boring",
      "borough",
      "borrower",
      "borrowing",
      "boss",
      "botanical",
      "botanist",
      "botany",
      "botch",
      "both",
      "bottle",
      "bottling",
      "bottom",
      "bounce",
      "bouncing",
      "bouncy",
      "bounding",
      "boundless",
      "bountiful",
      "bovine",
      "boxcar",
      "boxer",
      "boxing",
      "boxlike",
      "boxy",
      "breach",
      "breath",
      "breeches",
      "breeching",
      "breeder",
      "breeding",
      "breeze",
      "breezy",
      "brethren",
      "brewery",
      "brewing",
      "briar",
      "bribe",
      "brick",
      "bride",
      "bridged",
      "brigade",
      "bright",
      "brilliant",
      "brim",
      "bring",
      "brink",
      "brisket",
      "briskly",
      "briskness",
      "bristle",
      "brittle",
      "broadband",
      "broadcast",
      "broaden",
      "broadly",
      "broadness",
      "broadside",
      "broadways",
      "broiler",
      "broiling",
      "broken",
      "broker",
      "bronchial",
      "bronco",
      "bronze",
      "bronzing",
      "brook",
      "broom",
      "brought",
      "browbeat",
      "brownnose",
      "browse",
      "browsing",
      "bruising",
      "brunch",
      "brunette",
      "brunt",
      "brush",
      "brussels",
      "brute",
      "brutishly",
      "bubble",
      "bubbling",
      "bubbly",
      "buccaneer",
      "bucked",
      "bucket",
      "buckle",
      "buckshot",
      "buckskin",
      "bucktooth",
      "buckwheat",
      "buddhism",
      "buddhist",
      "budding",
      "buddy",
      "budget",
      "buffalo",
      "buffed",
      "buffer",
      "buffing",
      "buffoon",
      "buggy",
      "bulb",
      "bulge",
      "bulginess",
      "bulgur",
      "bulk",
      "bulldog",
      "bulldozer",
      "bullfight",
      "bullfrog",
      "bullhorn",
      "bullion",
      "bullish",
      "bullpen",
      "bullring",
      "bullseye",
      "bullwhip",
      "bully",
      "bunch",
      "bundle",
      "bungee",
      "bunion",
      "bunkbed",
      "bunkhouse",
      "bunkmate",
      "bunny",
      "bunt",
      "busboy",
      "bush",
      "busily",
      "busload",
      "bust",
      "busybody",
      "buzz",
      "cabana",
      "cabbage",
      "cabbie",
      "cabdriver",
      "cable",
      "caboose",
      "cache",
      "cackle",
      "cacti",
      "cactus",
      "caddie",
      "caddy",
      "cadet",
      "cadillac",
      "cadmium",
      "cage",
      "cahoots",
      "cake",
      "calamari",
      "calamity",
      "calcium",
      "calculate",
      "calculus",
      "caliber",
      "calibrate",
      "calm",
      "caloric",
      "calorie",
      "calzone",
      "camcorder",
      "cameo",
      "camera",
      "camisole",
      "camper",
      "campfire",
      "camping",
      "campsite",
      "campus",
      "canal",
      "canary",
      "cancel",
      "candied",
      "candle",
      "candy",
      "cane",
      "canine",
      "canister",
      "cannabis",
      "canned",
      "canning",
      "cannon",
      "cannot",
      "canola",
      "canon",
      "canopener",
      "canopy",
      "canteen",
      "canyon",
      "capable",
      "capably",
      "capacity",
      "cape",
      "capillary",
      "capital",
      "capitol",
      "capped",
      "capricorn",
      "capsize",
      "capsule",
      "caption",
      "captivate",
      "captive",
      "captivity",
      "capture",
      "caramel",
      "carat",
      "caravan",
      "carbon",
      "cardboard",
      "carded",
      "cardiac",
      "cardigan",
      "cardinal",
      "cardstock",
      "carefully",
      "caregiver",
      "careless",
      "caress",
      "caretaker",
      "cargo",
      "caring",
      "carless",
      "carload",
      "carmaker",
      "carnage",
      "carnation",
      "carnival",
      "carnivore",
      "carol",
      "carpenter",
      "carpentry",
      "carpool",
      "carport",
      "carried",
      "carrot",
      "carrousel",
      "carry",
      "cartel",
      "cartload",
      "carton",
      "cartoon",
      "cartridge",
      "cartwheel",
      "carve",
      "carving",
      "carwash",
      "cascade",
      "case",
      "cash",
      "casing",
      "casino",
      "casket",
      "cassette",
      "casually",
      "casualty",
      "catacomb",
      "catalog",
      "catalyst",
      "catalyze",
      "catapult",
      "cataract",
      "catatonic",
      "catcall",
      "catchable",
      "catcher",
      "catching",
      "catchy",
      "caterer",
      "catering",
      "catfight",
      "catfish",
      "cathedral",
      "cathouse",
      "catlike",
      "catnap",
      "catnip",
      "catsup",
      "cattail",
      "cattishly",
      "cattle",
      "catty",
      "catwalk",
      "caucasian",
      "caucus",
      "causal",
      "causation",
      "cause",
      "causing",
      "cauterize",
      "caution",
      "cautious",
      "cavalier",
      "cavalry",
      "caviar",
      "cavity",
      "cedar",
      "celery",
      "celestial",
      "celibacy",
      "celibate",
      "celtic",
      "cement",
      "census",
      "ceramics",
      "ceremony",
      "certainly",
      "certainty",
      "certified",
      "certify",
      "cesarean",
      "cesspool",
      "chafe",
      "chaffing",
      "chain",
      "chair",
      "chalice",
      "challenge",
      "chamber",
      "chamomile",
      "champion",
      "chance",
      "change",
      "channel",
      "chant",
      "chaos",
      "chaperone",
      "chaplain",
      "chapped",
      "chaps",
      "chapter",
      "character",
      "charbroil",
      "charcoal",
      "charger",
      "charging",
      "chariot",
      "charity",
      "charm",
      "charred",
      "charter",
      "charting",
      "chase",
      "chasing",
      "chaste",
      "chastise",
      "chastity",
      "chatroom",
      "chatter",
      "chatting",
      "chatty",
      "cheating",
      "cheddar",
      "cheek",
      "cheer",
      "cheese",
      "cheesy",
      "chef",
      "chemicals",
      "chemist",
      "chemo",
      "cherisher",
      "cherub",
      "chess",
      "chest",
      "chevron",
      "chevy",
      "chewable",
      "chewer",
      "chewing",
      "chewy",
      "chief",
      "chihuahua",
      "childcare",
      "childhood",
      "childish",
      "childless",
      "childlike",
      "chili",
      "chill",
      "chimp",
      "chip",
      "chirping",
      "chirpy",
      "chitchat",
      "chivalry",
      "chive",
      "chloride",
      "chlorine",
      "choice",
      "chokehold",
      "choking",
      "chomp",
      "chooser",
      "choosing",
      "choosy",
      "chop",
      "chosen",
      "chowder",
      "chowtime",
      "chrome",
      "chubby",
      "chuck",
      "chug",
      "chummy",
      "chump",
      "chunk",
      "churn",
      "chute",
      "cider",
      "cilantro",
      "cinch",
      "cinema",
      "cinnamon",
      "circle",
      "circling",
      "circular",
      "circulate",
      "circus",
      "citable",
      "citadel",
      "citation",
      "citizen",
      "citric",
      "citrus",
      "city",
      "civic",
      "civil",
      "clad",
      "claim",
      "clambake",
      "clammy",
      "clamor",
      "clamp",
      "clamshell",
      "clang",
      "clanking",
      "clapped",
      "clapper",
      "clapping",
      "clarify",
      "clarinet",
      "clarity",
      "clash",
      "clasp",
      "class",
      "clatter",
      "clause",
      "clavicle",
      "claw",
      "clay",
      "clean",
      "clear",
      "cleat",
      "cleaver",
      "cleft",
      "clench",
      "clergyman",
      "clerical",
      "clerk",
      "clever",
      "clicker",
      "client",
      "climate",
      "climatic",
      "cling",
      "clinic",
      "clinking",
      "clip",
      "clique",
      "cloak",
      "clobber",
      "clock",
      "clone",
      "cloning",
      "closable",
      "closure",
      "clothes",
      "clothing",
      "cloud",
      "clover",
      "clubbed",
      "clubbing",
      "clubhouse",
      "clump",
      "clumsily",
      "clumsy",
      "clunky",
      "clustered",
      "clutch",
      "clutter",
      "coach",
      "coagulant",
      "coastal",
      "coaster",
      "coasting",
      "coastland",
      "coastline",
      "coat",
      "coauthor",
      "cobalt",
      "cobbler",
      "cobweb",
      "cocoa",
      "coconut",
      "cod",
      "coeditor",
      "coerce",
      "coexist",
      "coffee",
      "cofounder",
      "cognition",
      "cognitive",
      "cogwheel",
      "coherence",
      "coherent",
      "cohesive",
      "coil",
      "coke",
      "cola",
      "cold",
      "coleslaw",
      "coliseum",
      "collage",
      "collapse",
      "collar",
      "collected",
      "collector",
      "collide",
      "collie",
      "collision",
      "colonial",
      "colonist",
      "colonize",
      "colony",
      "colossal",
      "colt",
      "coma",
      "come",
      "comfort",
      "comfy",
      "comic",
      "coming",
      "comma",
      "commence",
      "commend",
      "comment",
      "commerce",
      "commode",
      "commodity",
      "commodore",
      "common",
      "commotion",
      "commute",
      "commuting",
      "compacted",
      "compacter",
      "compactly",
      "compactor",
      "companion",
      "company",
      "compare",
      "compel",
      "compile",
      "comply",
      "component",
      "composed",
      "composer",
      "composite",
      "compost",
      "composure",
      "compound",
      "compress",
      "comprised",
      "computer",
      "computing",
      "comrade",
      "concave",
      "conceal",
      "conceded",
      "concept",
      "concerned",
      "concert",
      "conch",
      "concierge",
      "concise",
      "conclude",
      "concrete",
      "concur",
      "condense",
      "condiment",
      "condition",
      "condone",
      "conducive",
      "conductor",
      "conduit",
      "cone",
      "confess",
      "confetti",
      "confidant",
      "confident",
      "confider",
      "confiding",
      "configure",
      "confined",
      "confining",
      "confirm",
      "conflict",
      "conform",
      "confound",
      "confront",
      "confused",
      "confusing",
      "confusion",
      "congenial",
      "congested",
      "congrats",
      "congress",
      "conical",
      "conjoined",
      "conjure",
      "conjuror",
      "connected",
      "connector",
      "consensus",
      "consent",
      "console",
      "consoling",
      "consonant",
      "constable",
      "constant",
      "constrain",
      "constrict",
      "construct",
      "consult",
      "consumer",
      "consuming",
      "contact",
      "container",
      "contempt",
      "contend",
      "contented",
      "contently",
      "contents",
      "contest",
      "context",
      "contort",
      "contour",
      "contrite",
      "control",
      "contusion",
      "convene",
      "convent",
      "copartner",
      "cope",
      "copied",
      "copier",
      "copilot",
      "coping",
      "copious",
      "copper",
      "copy",
      "coral",
      "cork",
      "cornball",
      "cornbread",
      "corncob",
      "cornea",
      "corned",
      "corner",
      "cornfield",
      "cornflake",
      "cornhusk",
      "cornmeal",
      "cornstalk",
      "corny",
      "coronary",
      "coroner",
      "corporal",
      "corporate",
      "corral",
      "correct",
      "corridor",
      "corrode",
      "corroding",
      "corrosive",
      "corsage",
      "corset",
      "cortex",
      "cosigner",
      "cosmetics",
      "cosmic",
      "cosmos",
      "cosponsor",
      "cost",
      "cottage",
      "cotton",
      "couch",
      "cough",
      "could",
      "countable",
      "countdown",
      "counting",
      "countless",
      "country",
      "county",
      "courier",
      "covenant",
      "cover",
      "coveted",
      "coveting",
      "coyness",
      "cozily",
      "coziness",
      "cozy",
      "crabbing",
      "crabgrass",
      "crablike",
      "crabmeat",
      "cradle",
      "cradling",
      "crafter",
      "craftily",
      "craftsman",
      "craftwork",
      "crafty",
      "cramp",
      "cranberry",
      "crane",
      "cranial",
      "cranium",
      "crank",
      "crate",
      "crave",
      "craving",
      "crawfish",
      "crawlers",
      "crawling",
      "crayfish",
      "crayon",
      "crazed",
      "crazily",
      "craziness",
      "crazy",
      "creamed",
      "creamer",
      "creamlike",
      "crease",
      "creasing",
      "creatable",
      "create",
      "creation",
      "creative",
      "creature",
      "credible",
      "credibly",
      "credit",
      "creed",
      "creme",
      "creole",
      "crepe",
      "crept",
      "crescent",
      "crested",
      "cresting",
      "crestless",
      "crevice",
      "crewless",
      "crewman",
      "crewmate",
      "crib",
      "cricket",
      "cried",
      "crier",
      "crimp",
      "crimson",
      "cringe",
      "cringing",
      "crinkle",
      "crinkly",
      "crisped",
      "crisping",
      "crisply",
      "crispness",
      "crispy",
      "criteria",
      "critter",
      "croak",
      "crock",
      "crook",
      "croon",
      "crop",
      "cross",
      "crouch",
      "crouton",
      "crowbar",
      "crowd",
      "crown",
      "crucial",
      "crudely",
      "crudeness",
      "cruelly",
      "cruelness",
      "cruelty",
      "crumb",
      "crummiest",
      "crummy",
      "crumpet",
      "crumpled",
      "cruncher",
      "crunching",
      "crunchy",
      "crusader",
      "crushable",
      "crushed",
      "crusher",
      "crushing",
      "crust",
      "crux",
      "crying",
      "cryptic",
      "crystal",
      "cubbyhole",
      "cube",
      "cubical",
      "cubicle",
      "cucumber",
      "cuddle",
      "cuddly",
      "cufflink",
      "culinary",
      "culminate",
      "culpable",
      "culprit",
      "cultivate",
      "cultural",
      "culture",
      "cupbearer",
      "cupcake",
      "cupid",
      "cupped",
      "cupping",
      "curable",
      "curator",
      "curdle",
      "cure",
      "curfew",
      "curing",
      "curled",
      "curler",
      "curliness",
      "curling",
      "curly",
      "curry",
      "curse",
      "cursive",
      "cursor",
      "curtain",
      "curtly",
      "curtsy",
      "curvature",
      "curve",
      "curvy",
      "cushy",
      "cusp",
      "cussed",
      "custard",
      "custodian",
      "custody",
      "customary",
      "customer",
      "customize",
      "customs",
      "cut",
      "cycle",
      "cyclic",
      "cycling",
      "cyclist",
      "cylinder",
      "cymbal",
      "cytoplasm",
      "cytoplast",
      "dab",
      "dad",
      "daffodil",
      "dagger",
      "daily",
      "daintily",
      "dainty",
      "dairy",
      "daisy",
      "dallying",
      "dance",
      "dancing",
      "dandelion",
      "dander",
      "dandruff",
      "dandy",
      "danger",
      "dangle",
      "dangling",
      "daredevil",
      "dares",
      "daringly",
      "darkened",
      "darkening",
      "darkish",
      "darkness",
      "darkroom",
      "darling",
      "darn",
      "dart",
      "darwinism",
      "dash",
      "dastardly",
      "data",
      "datebook",
      "dating",
      "daughter",
      "daunting",
      "dawdler",
      "dawn",
      "daybed",
      "daybreak",
      "daycare",
      "daydream",
      "daylight",
      "daylong",
      "dayroom",
      "daytime",
      "dazzler",
      "dazzling",
      "deacon",
      "deafening",
      "deafness",
      "dealer",
      "dealing",
      "dealmaker",
      "dealt",
      "dean",
      "debatable",
      "debate",
      "debating",
      "debit",
      "debrief",
      "debtless",
      "debtor",
      "debug",
      "debunk",
      "decade",
      "decaf",
      "decal",
      "decathlon",
      "decay",
      "deceased",
      "deceit",
      "deceiver",
      "deceiving",
      "december",
      "decency",
      "decent",
      "deception",
      "deceptive",
      "decibel",
      "decidable",
      "decimal",
      "decimeter",
      "decipher",
      "deck",
      "declared",
      "decline",
      "decode",
      "decompose",
      "decorated",
      "decorator",
      "decoy",
      "decrease",
      "decree",
      "dedicate",
      "dedicator",
      "deduce",
      "deduct",
      "deed",
      "deem",
      "deepen",
      "deeply",
      "deepness",
      "deface",
      "defacing",
      "defame",
      "default",
      "defeat",
      "defection",
      "defective",
      "defendant",
      "defender",
      "defense",
      "defensive",
      "deferral",
      "deferred",
      "defiance",
      "defiant",
      "defile",
      "defiling",
      "define",
      "definite",
      "deflate",
      "deflation",
      "deflator",
      "deflected",
      "deflector",
      "defog",
      "deforest",
      "defraud",
      "defrost",
      "deftly",
      "defuse",
      "defy",
      "degraded",
      "degrading",
      "degrease",
      "degree",
      "dehydrate",
      "deity",
      "dejected",
      "delay",
      "delegate",
      "delegator",
      "delete",
      "deletion",
      "delicacy",
      "delicate",
      "delicious",
      "delighted",
      "delirious",
      "delirium",
      "deliverer",
      "delivery",
      "delouse",
      "delta",
      "deluge",
      "delusion",
      "deluxe",
      "demanding",
      "demeaning",
      "demeanor",
      "demise",
      "democracy",
      "democrat",
      "demote",
      "demotion",
      "demystify",
      "denatured",
      "deniable",
      "denial",
      "denim",
      "denote",
      "dense",
      "density",
      "dental",
      "dentist",
      "denture",
      "deny",
      "deodorant",
      "deodorize",
      "departed",
      "departure",
      "depict",
      "deplete",
      "depletion",
      "deplored",
      "deploy",
      "deport",
      "depose",
      "depraved",
      "depravity",
      "deprecate",
      "depress",
      "deprive",
      "depth",
      "deputize",
      "deputy",
      "derail",
      "deranged",
      "derby",
      "derived",
      "desecrate",
      "deserve",
      "deserving",
      "designate",
      "designed",
      "designer",
      "designing",
      "deskbound",
      "desktop",
      "deskwork",
      "desolate",
      "despair",
      "despise",
      "despite",
      "destiny",
      "destitute",
      "destruct",
      "detached",
      "detail",
      "detection",
      "detective",
      "detector",
      "detention",
      "detergent",
      "detest",
      "detonate",
      "detonator",
      "detoxify",
      "detract",
      "deuce",
      "devalue",
      "deviancy",
      "deviant",
      "deviate",
      "deviation",
      "deviator",
      "device",
      "devious",
      "devotedly",
      "devotee",
      "devotion",
      "devourer",
      "devouring",
      "devoutly",
      "dexterity",
      "dexterous",
      "diabetes",
      "diabetic",
      "diabolic",
      "diagnoses",
      "diagnosis",
      "diagram",
      "dial",
      "diameter",
      "diaper",
      "diaphragm",
      "diary",
      "dice",
      "dicing",
      "dictate",
      "dictation",
      "dictator",
      "difficult",
      "diffused",
      "diffuser",
      "diffusion",
      "diffusive",
      "dig",
      "dilation",
      "diligence",
      "diligent",
      "dill",
      "dilute",
      "dime",
      "diminish",
      "dimly",
      "dimmed",
      "dimmer",
      "dimness",
      "dimple",
      "diner",
      "dingbat",
      "dinghy",
      "dinginess",
      "dingo",
      "dingy",
      "dining",
      "dinner",
      "diocese",
      "dioxide",
      "diploma",
      "dipped",
      "dipper",
      "dipping",
      "directed",
      "direction",
      "directive",
      "directly",
      "directory",
      "direness",
      "dirtiness",
      "disabled",
      "disagree",
      "disallow",
      "disarm",
      "disarray",
      "disaster",
      "disband",
      "disbelief",
      "disburse",
      "discard",
      "discern",
      "discharge",
      "disclose",
      "discolor",
      "discount",
      "discourse",
      "discover",
      "discuss",
      "disdain",
      "disengage",
      "disfigure",
      "disgrace",
      "dish",
      "disinfect",
      "disjoin",
      "disk",
      "dislike",
      "disliking",
      "dislocate",
      "dislodge",
      "disloyal",
      "dismantle",
      "dismay",
      "dismiss",
      "dismount",
      "disobey",
      "disorder",
      "disown",
      "disparate",
      "disparity",
      "dispatch",
      "dispense",
      "dispersal",
      "dispersed",
      "disperser",
      "displace",
      "display",
      "displease",
      "disposal",
      "dispose",
      "disprove",
      "dispute",
      "disregard",
      "disrupt",
      "dissuade",
      "distance",
      "distant",
      "distaste",
      "distill",
      "distinct",
      "distort",
      "distract",
      "distress",
      "district",
      "distrust",
      "ditch",
      "ditto",
      "ditzy",
      "dividable",
      "divided",
      "dividend",
      "dividers",
      "dividing",
      "divinely",
      "diving",
      "divinity",
      "divisible",
      "divisibly",
      "division",
      "divisive",
      "divorcee",
      "dizziness",
      "dizzy",
      "doable",
      "docile",
      "dock",
      "doctrine",
      "document",
      "dodge",
      "dodgy",
      "doily",
      "doing",
      "dole",
      "dollar",
      "dollhouse",
      "dollop",
      "dolly",
      "dolphin",
      "domain",
      "domelike",
      "domestic",
      "dominion",
      "dominoes",
      "donated",
      "donation",
      "donator",
      "donor",
      "donut",
      "doodle",
      "doorbell",
      "doorframe",
      "doorknob",
      "doorman",
      "doormat",
      "doornail",
      "doorpost",
      "doorstep",
      "doorstop",
      "doorway",
      "doozy",
      "dork",
      "dormitory",
      "dorsal",
      "dosage",
      "dose",
      "dotted",
      "doubling",
      "douche",
      "dove",
      "down",
      "dowry",
      "doze",
      "drab",
      "dragging",
      "dragonfly",
      "dragonish",
      "dragster",
      "drainable",
      "drainage",
      "drained",
      "drainer",
      "drainpipe",
      "dramatic",
      "dramatize",
      "drank",
      "drapery",
      "drastic",
      "draw",
      "dreaded",
      "dreadful",
      "dreadlock",
      "dreamboat",
      "dreamily",
      "dreamland",
      "dreamless",
      "dreamlike",
      "dreamt",
      "dreamy",
      "drearily",
      "dreary",
      "drench",
      "dress",
      "drew",
      "dribble",
      "dried",
      "drier",
      "drift",
      "driller",
      "drilling",
      "drinkable",
      "drinking",
      "dripping",
      "drippy",
      "drivable",
      "driven",
      "driver",
      "driveway",
      "driving",
      "drizzle",
      "drizzly",
      "drone",
      "drool",
      "droop",
      "drop-down",
      "dropbox",
      "dropkick",
      "droplet",
      "dropout",
      "dropper",
      "drove",
      "drown",
      "drowsily",
      "drudge",
      "drum",
      "dry",
      "dubbed",
      "dubiously",
      "duchess",
      "duckbill",
      "ducking",
      "duckling",
      "ducktail",
      "ducky",
      "duct",
      "dude",
      "duffel",
      "dugout",
      "duh",
      "duke",
      "duller",
      "dullness",
      "duly",
      "dumping",
      "dumpling",
      "dumpster",
      "duo",
      "dupe",
      "duplex",
      "duplicate",
      "duplicity",
      "durable",
      "durably",
      "duration",
      "duress",
      "during",
      "dusk",
      "dust",
      "dutiful",
      "duty",
      "duvet",
      "dwarf",
      "dweeb",
      "dwelled",
      "dweller",
      "dwelling",
      "dwindle",
      "dwindling",
      "dynamic",
      "dynamite",
      "dynasty",
      "dyslexia",
      "dyslexic",
      "each",
      "eagle",
      "earache",
      "eardrum",
      "earflap",
      "earful",
      "earlobe",
      "early",
      "earmark",
      "earmuff",
      "earphone",
      "earpiece",
      "earplugs",
      "earring",
      "earshot",
      "earthen",
      "earthlike",
      "earthling",
      "earthly",
      "earthworm",
      "earthy",
      "earwig",
      "easeful",
      "easel",
      "easiest",
      "easily",
      "easiness",
      "easing",
      "eastbound",
      "eastcoast",
      "easter",
      "eastward",
      "eatable",
      "eaten",
      "eatery",
      "eating",
      "eats",
      "ebay",
      "ebony",
      "ebook",
      "ecard",
      "eccentric",
      "echo",
      "eclair",
      "eclipse",
      "ecologist",
      "ecology",
      "economic",
      "economist",
      "economy",
      "ecosphere",
      "ecosystem",
      "edge",
      "edginess",
      "edging",
      "edgy",
      "edition",
      "editor",
      "educated",
      "education",
      "educator",
      "eel",
      "effective",
      "effects",
      "efficient",
      "effort",
      "eggbeater",
      "egging",
      "eggnog",
      "eggplant",
      "eggshell",
      "egomaniac",
      "egotism",
      "egotistic",
      "either",
      "eject",
      "elaborate",
      "elastic",
      "elated",
      "elbow",
      "eldercare",
      "elderly",
      "eldest",
      "electable",
      "election",
      "elective",
      "elephant",
      "elevate",
      "elevating",
      "elevation",
      "elevator",
      "eleven",
      "elf",
      "eligible",
      "eligibly",
      "eliminate",
      "elite",
      "elitism",
      "elixir",
      "elk",
      "ellipse",
      "elliptic",
      "elm",
      "elongated",
      "elope",
      "eloquence",
      "eloquent",
      "elsewhere",
      "elude",
      "elusive",
      "elves",
      "email",
      "embargo",
      "embark",
      "embassy",
      "embattled",
      "embellish",
      "ember",
      "embezzle",
      "emblaze",
      "emblem",
      "embody",
      "embolism",
      "emboss",
      "embroider",
      "emcee",
      "emerald",
      "emergency",
      "emission",
      "emit",
      "emote",
      "emoticon",
      "emotion",
      "empathic",
      "empathy",
      "emperor",
      "emphases",
      "emphasis",
      "emphasize",
      "emphatic",
      "empirical",
      "employed",
      "employee",
      "employer",
      "emporium",
      "empower",
      "emptier",
      "emptiness",
      "empty",
      "emu",
      "enable",
      "enactment",
      "enamel",
      "enchanted",
      "enchilada",
      "encircle",
      "enclose",
      "enclosure",
      "encode",
      "encore",
      "encounter",
      "encourage",
      "encroach",
      "encrust",
      "encrypt",
      "endanger",
      "endeared",
      "endearing",
      "ended",
      "ending",
      "endless",
      "endnote",
      "endocrine",
      "endorphin",
      "endorse",
      "endowment",
      "endpoint",
      "endurable",
      "endurance",
      "enduring",
      "energetic",
      "energize",
      "energy",
      "enforced",
      "enforcer",
      "engaged",
      "engaging",
      "engine",
      "engorge",
      "engraved",
      "engraver",
      "engraving",
      "engross",
      "engulf",
      "enhance",
      "enigmatic",
      "enjoyable",
      "enjoyably",
      "enjoyer",
      "enjoying",
      "enjoyment",
      "enlarged",
      "enlarging",
      "enlighten",
      "enlisted",
      "enquirer",
      "enrage",
      "enrich",
      "enroll",
      "enslave",
      "ensnare",
      "ensure",
      "entail",
      "entangled",
      "entering",
      "entertain",
      "enticing",
      "entire",
      "entitle",
      "entity",
      "entomb",
      "entourage",
      "entrap",
      "entree",
      "entrench",
      "entrust",
      "entryway",
      "entwine",
      "enunciate",
      "envelope",
      "enviable",
      "enviably",
      "envious",
      "envision",
      "envoy",
      "envy",
      "enzyme",
      "epic",
      "epidemic",
      "epidermal",
      "epidermis",
      "epidural",
      "epilepsy",
      "epileptic",
      "epilogue",
      "epiphany",
      "episode",
      "equal",
      "equate",
      "equation",
      "equator",
      "equinox",
      "equipment",
      "equity",
      "equivocal",
      "eradicate",
      "erasable",
      "erased",
      "eraser",
      "erasure",
      "ergonomic",
      "errand",
      "errant",
      "erratic",
      "error",
      "erupt",
      "escalate",
      "escalator",
      "escapable",
      "escapade",
      "escapist",
      "escargot",
      "eskimo",
      "esophagus",
      "espionage",
      "espresso",
      "esquire",
      "essay",
      "essence",
      "essential",
      "establish",
      "estate",
      "esteemed",
      "estimate",
      "estimator",
      "estranged",
      "estrogen",
      "etching",
      "eternal",
      "eternity",
      "ethanol",
      "ether",
      "ethically",
      "ethics",
      "euphemism",
      "evacuate",
      "evacuee",
      "evade",
      "evaluate",
      "evaluator",
      "evaporate",
      "evasion",
      "evasive",
      "even",
      "everglade",
      "evergreen",
      "everybody",
      "everyday",
      "everyone",
      "evict",
      "evidence",
      "evident",
      "evil",
      "evoke",
      "evolution",
      "evolve",
      "exact",
      "exalted",
      "example",
      "excavate",
      "excavator",
      "exceeding",
      "exception",
      "excess",
      "exchange",
      "excitable",
      "exciting",
      "exclaim",
      "exclude",
      "excluding",
      "exclusion",
      "exclusive",
      "excretion",
      "excretory",
      "excursion",
      "excusable",
      "excusably",
      "excuse",
      "exemplary",
      "exemplify",
      "exemption",
      "exerciser",
      "exert",
      "exes",
      "exfoliate",
      "exhale",
      "exhaust",
      "exhume",
      "exile",
      "existing",
      "exit",
      "exodus",
      "exonerate",
      "exorcism",
      "exorcist",
      "expand",
      "expanse",
      "expansion",
      "expansive",
      "expectant",
      "expedited",
      "expediter",
      "expel",
      "expend",
      "expenses",
      "expensive",
      "expert",
      "expire",
      "expiring",
      "explain",
      "expletive",
      "explicit",
      "explode",
      "exploit",
      "explore",
      "exploring",
      "exponent",
      "exporter",
      "exposable",
      "expose",
      "exposure",
      "express",
      "expulsion",
      "exquisite",
      "extended",
      "extending",
      "extent",
      "extenuate",
      "exterior",
      "external",
      "extinct",
      "extortion",
      "extradite",
      "extras",
      "extrovert",
      "extrude",
      "extruding",
      "exuberant",
      "fable",
      "fabric",
      "fabulous",
      "facebook",
      "facecloth",
      "facedown",
      "faceless",
      "facelift",
      "faceplate",
      "faceted",
      "facial",
      "facility",
      "facing",
      "facsimile",
      "faction",
      "factoid",
      "factor",
      "factsheet",
      "factual",
      "faculty",
      "fade",
      "fading",
      "failing",
      "falcon",
      "fall",
      "false",
      "falsify",
      "fame",
      "familiar",
      "family",
      "famine",
      "famished",
      "fanatic",
      "fancied",
      "fanciness",
      "fancy",
      "fanfare",
      "fang",
      "fanning",
      "fantasize",
      "fantastic",
      "fantasy",
      "fascism",
      "fastball",
      "faster",
      "fasting",
      "fastness",
      "faucet",
      "favorable",
      "favorably",
      "favored",
      "favoring",
      "favorite",
      "fax",
      "feast",
      "federal",
      "fedora",
      "feeble",
      "feed",
      "feel",
      "feisty",
      "feline",
      "felt-tip",
      "feminine",
      "feminism",
      "feminist",
      "feminize",
      "femur",
      "fence",
      "fencing",
      "fender",
      "ferment",
      "fernlike",
      "ferocious",
      "ferocity",
      "ferret",
      "ferris",
      "ferry",
      "fervor",
      "fester",
      "festival",
      "festive",
      "festivity",
      "fetal",
      "fetch",
      "fever",
      "fiber",
      "fiction",
      "fiddle",
      "fiddling",
      "fidelity",
      "fidgeting",
      "fidgety",
      "fifteen",
      "fifth",
      "fiftieth",
      "fifty",
      "figment",
      "figure",
      "figurine",
      "filing",
      "filled",
      "filler",
      "filling",
      "film",
      "filter",
      "filth",
      "filtrate",
      "finale",
      "finalist",
      "finalize",
      "finally",
      "finance",
      "financial",
      "finch",
      "fineness",
      "finer",
      "finicky",
      "finished",
      "finisher",
      "finishing",
      "finite",
      "finless",
      "finlike",
      "fiscally",
      "fit",
      "five",
      "flaccid",
      "flagman",
      "flagpole",
      "flagship",
      "flagstick",
      "flagstone",
      "flail",
      "flakily",
      "flaky",
      "flame",
      "flammable",
      "flanked",
      "flanking",
      "flannels",
      "flap",
      "flaring",
      "flashback",
      "flashbulb",
      "flashcard",
      "flashily",
      "flashing",
      "flashy",
      "flask",
      "flatbed",
      "flatfoot",
      "flatly",
      "flatness",
      "flatten",
      "flattered",
      "flatterer",
      "flattery",
      "flattop",
      "flatware",
      "flatworm",
      "flavored",
      "flavorful",
      "flavoring",
      "flaxseed",
      "fled",
      "fleshed",
      "fleshy",
      "flick",
      "flier",
      "flight",
      "flinch",
      "fling",
      "flint",
      "flip",
      "flirt",
      "float",
      "flock",
      "flogging",
      "flop",
      "floral",
      "florist",
      "floss",
      "flounder",
      "flyable",
      "flyaway",
      "flyer",
      "flying",
      "flyover",
      "flypaper",
      "foam",
      "foe",
      "fog",
      "foil",
      "folic",
      "folk",
      "follicle",
      "follow",
      "fondling",
      "fondly",
      "fondness",
      "fondue",
      "font",
      "food",
      "fool",
      "footage",
      "football",
      "footbath",
      "footboard",
      "footer",
      "footgear",
      "foothill",
      "foothold",
      "footing",
      "footless",
      "footman",
      "footnote",
      "footpad",
      "footpath",
      "footprint",
      "footrest",
      "footsie",
      "footsore",
      "footwear",
      "footwork",
      "fossil",
      "foster",
      "founder",
      "founding",
      "fountain",
      "fox",
      "foyer",
      "fraction",
      "fracture",
      "fragile",
      "fragility",
      "fragment",
      "fragrance",
      "fragrant",
      "frail",
      "frame",
      "framing",
      "frantic",
      "fraternal",
      "frayed",
      "fraying",
      "frays",
      "freckled",
      "freckles",
      "freebase",
      "freebee",
      "freebie",
      "freedom",
      "freefall",
      "freehand",
      "freeing",
      "freeload",
      "freely",
      "freemason",
      "freeness",
      "freestyle",
      "freeware",
      "freeway",
      "freewill",
      "freezable",
      "freezing",
      "freight",
      "french",
      "frenzied",
      "frenzy",
      "frequency",
      "frequent",
      "fresh",
      "fretful",
      "fretted",
      "friction",
      "friday",
      "fridge",
      "fried",
      "friend",
      "frighten",
      "frightful",
      "frigidity",
      "frigidly",
      "frill",
      "fringe",
      "frisbee",
      "frisk",
      "fritter",
      "frivolous",
      "frolic",
      "from",
      "front",
      "frostbite",
      "frosted",
      "frostily",
      "frosting",
      "frostlike",
      "frosty",
      "froth",
      "frown",
      "frozen",
      "fructose",
      "frugality",
      "frugally",
      "fruit",
      "frustrate",
      "frying",
      "gab",
      "gaffe",
      "gag",
      "gainfully",
      "gaining",
      "gains",
      "gala",
      "gallantly",
      "galleria",
      "gallery",
      "galley",
      "gallon",
      "gallows",
      "gallstone",
      "galore",
      "galvanize",
      "gambling",
      "game",
      "gaming",
      "gamma",
      "gander",
      "gangly",
      "gangrene",
      "gangway",
      "gap",
      "garage",
      "garbage",
      "garden",
      "gargle",
      "garland",
      "garlic",
      "garment",
      "garnet",
      "garnish",
      "garter",
      "gas",
      "gatherer",
      "gathering",
      "gating",
      "gauging",
      "gauntlet",
      "gauze",
      "gave",
      "gawk",
      "gazing",
      "gear",
      "gecko",
      "geek",
      "geiger",
      "gem",
      "gender",
      "generic",
      "generous",
      "genetics",
      "genre",
      "gentile",
      "gentleman",
      "gently",
      "gents",
      "geography",
      "geologic",
      "geologist",
      "geology",
      "geometric",
      "geometry",
      "geranium",
      "gerbil",
      "geriatric",
      "germicide",
      "germinate",
      "germless",
      "germproof",
      "gestate",
      "gestation",
      "gesture",
      "getaway",
      "getting",
      "getup",
      "giant",
      "gibberish",
      "giblet",
      "giddily",
      "giddiness",
      "giddy",
      "gift",
      "gigabyte",
      "gigahertz",
      "gigantic",
      "giggle",
      "giggling",
      "giggly",
      "gigolo",
      "gilled",
      "gills",
      "gimmick",
      "girdle",
      "giveaway",
      "given",
      "giver",
      "giving",
      "gizmo",
      "gizzard",
      "glacial",
      "glacier",
      "glade",
      "gladiator",
      "gladly",
      "glamorous",
      "glamour",
      "glance",
      "glancing",
      "glandular",
      "glare",
      "glaring",
      "glass",
      "glaucoma",
      "glazing",
      "gleaming",
      "gleeful",
      "glider",
      "gliding",
      "glimmer",
      "glimpse",
      "glisten",
      "glitch",
      "glitter",
      "glitzy",
      "gloater",
      "gloating",
      "gloomily",
      "gloomy",
      "glorified",
      "glorifier",
      "glorify",
      "glorious",
      "glory",
      "gloss",
      "glove",
      "glowing",
      "glowworm",
      "glucose",
      "glue",
      "gluten",
      "glutinous",
      "glutton",
      "gnarly",
      "gnat",
      "goal",
      "goatskin",
      "goes",
      "goggles",
      "going",
      "goldfish",
      "goldmine",
      "goldsmith",
      "golf",
      "goliath",
      "gonad",
      "gondola",
      "gone",
      "gong",
      "good",
      "gooey",
      "goofball",
      "goofiness",
      "goofy",
      "google",
      "goon",
      "gopher",
      "gore",
      "gorged",
      "gorgeous",
      "gory",
      "gosling",
      "gossip",
      "gothic",
      "gotten",
      "gout",
      "gown",
      "grab",
      "graceful",
      "graceless",
      "gracious",
      "gradation",
      "graded",
      "grader",
      "gradient",
      "grading",
      "gradually",
      "graduate",
      "graffiti",
      "grafted",
      "grafting",
      "grain",
      "granddad",
      "grandkid",
      "grandly",
      "grandma",
      "grandpa",
      "grandson",
      "granite",
      "granny",
      "granola",
      "grant",
      "granular",
      "grape",
      "graph",
      "grapple",
      "grappling",
      "grasp",
      "grass",
      "gratified",
      "gratify",
      "grating",
      "gratitude",
      "gratuity",
      "gravel",
      "graveness",
      "graves",
      "graveyard",
      "gravitate",
      "gravity",
      "gravy",
      "gray",
      "grazing",
      "greasily",
      "greedily",
      "greedless",
      "greedy",
      "green",
      "greeter",
      "greeting",
      "grew",
      "greyhound",
      "grid",
      "grief",
      "grievance",
      "grieving",
      "grievous",
      "grill",
      "grimace",
      "grimacing",
      "grime",
      "griminess",
      "grimy",
      "grinch",
      "grinning",
      "grip",
      "gristle",
      "grit",
      "groggily",
      "groggy",
      "groin",
      "groom",
      "groove",
      "grooving",
      "groovy",
      "grope",
      "ground",
      "grouped",
      "grout",
      "grove",
      "grower",
      "growing",
      "growl",
      "grub",
      "grudge",
      "grudging",
      "grueling",
      "gruffly",
      "grumble",
      "grumbling",
      "grumbly",
      "grumpily",
      "grunge",
      "grunt",
      "guacamole",
      "guidable",
      "guidance",
      "guide",
      "guiding",
      "guileless",
      "guise",
      "gulf",
      "gullible",
      "gully",
      "gulp",
      "gumball",
      "gumdrop",
      "gumminess",
      "gumming",
      "gummy",
      "gurgle",
      "gurgling",
      "guru",
      "gush",
      "gusto",
      "gusty",
      "gutless",
      "guts",
      "gutter",
      "guy",
      "guzzler",
      "gyration",
      "habitable",
      "habitant",
      "habitat",
      "habitual",
      "hacked",
      "hacker",
      "hacking",
      "hacksaw",
      "had",
      "haggler",
      "haiku",
      "half",
      "halogen",
      "halt",
      "halved",
      "halves",
      "hamburger",
      "hamlet",
      "hammock",
      "hamper",
      "hamster",
      "hamstring",
      "handbag",
      "handball",
      "handbook",
      "handbrake",
      "handcart",
      "handclap",
      "handclasp",
      "handcraft",
      "handcuff",
      "handed",
      "handful",
      "handgrip",
      "handgun",
      "handheld",
      "handiness",
      "handiwork",
      "handlebar",
      "handled",
      "handler",
      "handling",
      "handmade",
      "handoff",
      "handpick",
      "handprint",
      "handrail",
      "handsaw",
      "handset",
      "handsfree",
      "handshake",
      "handstand",
      "handwash",
      "handwork",
      "handwoven",
      "handwrite",
      "handyman",
      "hangnail",
      "hangout",
      "hangover",
      "hangup",
      "hankering",
      "hankie",
      "hanky",
      "haphazard",
      "happening",
      "happier",
      "happiest",
      "happily",
      "happiness",
      "happy",
      "harbor",
      "hardcopy",
      "hardcore",
      "hardcover",
      "harddisk",
      "hardened",
      "hardener",
      "hardening",
      "hardhat",
      "hardhead",
      "hardiness",
      "hardly",
      "hardness",
      "hardship",
      "hardware",
      "hardwired",
      "hardwood",
      "hardy",
      "harmful",
      "harmless",
      "harmonica",
      "harmonics",
      "harmonize",
      "harmony",
      "harness",
      "harpist",
      "harsh",
      "harvest",
      "hash",
      "hassle",
      "haste",
      "hastily",
      "hastiness",
      "hasty",
      "hatbox",
      "hatchback",
      "hatchery",
      "hatchet",
      "hatching",
      "hatchling",
      "hate",
      "hatless",
      "hatred",
      "haunt",
      "haven",
      "hazard",
      "hazelnut",
      "hazily",
      "haziness",
      "hazing",
      "hazy",
      "headache",
      "headband",
      "headboard",
      "headcount",
      "headdress",
      "headed",
      "header",
      "headfirst",
      "headgear",
      "heading",
      "headlamp",
      "headless",
      "headlock",
      "headphone",
      "headpiece",
      "headrest",
      "headroom",
      "headscarf",
      "headset",
      "headsman",
      "headstand",
      "headstone",
      "headway",
      "headwear",
      "heap",
      "heat",
      "heave",
      "heavily",
      "heaviness",
      "heaving",
      "hedge",
      "hedging",
      "heftiness",
      "hefty",
      "helium",
      "helmet",
      "helper",
      "helpful",
      "helping",
      "helpless",
      "helpline",
      "hemlock",
      "hemstitch",
      "hence",
      "henchman",
      "henna",
      "herald",
      "herbal",
      "herbicide",
      "herbs",
      "heritage",
      "hermit",
      "heroics",
      "heroism",
      "herring",
      "herself",
      "hertz",
      "hesitancy",
      "hesitant",
      "hesitate",
      "hexagon",
      "hexagram",
      "hubcap",
      "huddle",
      "huddling",
      "huff",
      "hug",
      "hula",
      "hulk",
      "hull",
      "human",
      "humble",
      "humbling",
      "humbly",
      "humid",
      "humiliate",
      "humility",
      "humming",
      "hummus",
      "humongous",
      "humorist",
      "humorless",
      "humorous",
      "humpback",
      "humped",
      "humvee",
      "hunchback",
      "hundredth",
      "hunger",
      "hungrily",
      "hungry",
      "hunk",
      "hunter",
      "hunting",
      "huntress",
      "huntsman",
      "hurdle",
      "hurled",
      "hurler",
      "hurling",
      "hurray",
      "hurricane",
      "hurried",
      "hurry",
      "hurt",
      "husband",
      "hush",
      "husked",
      "huskiness",
      "hut",
      "hybrid",
      "hydrant",
      "hydrated",
      "hydration",
      "hydrogen",
      "hydroxide",
      "hyperlink",
      "hypertext",
      "hyphen",
      "hypnoses",
      "hypnosis",
      "hypnotic",
      "hypnotism",
      "hypnotist",
      "hypnotize",
      "hypocrisy",
      "hypocrite",
      "ibuprofen",
      "ice",
      "iciness",
      "icing",
      "icky",
      "icon",
      "icy",
      "idealism",
      "idealist",
      "idealize",
      "ideally",
      "idealness",
      "identical",
      "identify",
      "identity",
      "ideology",
      "idiocy",
      "idiom",
      "idly",
      "igloo",
      "ignition",
      "ignore",
      "iguana",
      "illicitly",
      "illusion",
      "illusive",
      "image",
      "imaginary",
      "imagines",
      "imaging",
      "imbecile",
      "imitate",
      "imitation",
      "immature",
      "immerse",
      "immersion",
      "imminent",
      "immobile",
      "immodest",
      "immorally",
      "immortal",
      "immovable",
      "immovably",
      "immunity",
      "immunize",
      "impaired",
      "impale",
      "impart",
      "impatient",
      "impeach",
      "impeding",
      "impending",
      "imperfect",
      "imperial",
      "impish",
      "implant",
      "implement",
      "implicate",
      "implicit",
      "implode",
      "implosion",
      "implosive",
      "imply",
      "impolite",
      "important",
      "importer",
      "impose",
      "imposing",
      "impotence",
      "impotency",
      "impotent",
      "impound",
      "imprecise",
      "imprint",
      "imprison",
      "impromptu",
      "improper",
      "improve",
      "improving",
      "improvise",
      "imprudent",
      "impulse",
      "impulsive",
      "impure",
      "impurity",
      "iodine",
      "iodize",
      "ion",
      "ipad",
      "iphone",
      "ipod",
      "irate",
      "irk",
      "iron",
      "irregular",
      "irrigate",
      "irritable",
      "irritably",
      "irritant",
      "irritate",
      "islamic",
      "islamist",
      "isolated",
      "isolating",
      "isolation",
      "isotope",
      "issue",
      "issuing",
      "italicize",
      "italics",
      "item",
      "itinerary",
      "itunes",
      "ivory",
      "ivy",
      "jab",
      "jackal",
      "jacket",
      "jackknife",
      "jackpot",
      "jailbird",
      "jailbreak",
      "jailer",
      "jailhouse",
      "jalapeno",
      "jam",
      "janitor",
      "january",
      "jargon",
      "jarring",
      "jasmine",
      "jaundice",
      "jaunt",
      "java",
      "jawed",
      "jawless",
      "jawline",
      "jaws",
      "jaybird",
      "jaywalker",
      "jazz",
      "jeep",
      "jeeringly",
      "jellied",
      "jelly",
      "jersey",
      "jester",
      "jet",
      "jiffy",
      "jigsaw",
      "jimmy",
      "jingle",
      "jingling",
      "jinx",
      "jitters",
      "jittery",
      "job",
      "jockey",
      "jockstrap",
      "jogger",
      "jogging",
      "john",
      "joining",
      "jokester",
      "jokingly",
      "jolliness",
      "jolly",
      "jolt",
      "jot",
      "jovial",
      "joyfully",
      "joylessly",
      "joyous",
      "joyride",
      "joystick",
      "jubilance",
      "jubilant",
      "judge",
      "judgingly",
      "judicial",
      "judiciary",
      "judo",
      "juggle",
      "juggling",
      "jugular",
      "juice",
      "juiciness",
      "juicy",
      "jujitsu",
      "jukebox",
      "july",
      "jumble",
      "jumbo",
      "jump",
      "junction",
      "juncture",
      "june",
      "junior",
      "juniper",
      "junkie",
      "junkman",
      "junkyard",
      "jurist",
      "juror",
      "jury",
      "justice",
      "justifier",
      "justify",
      "justly",
      "justness",
      "juvenile",
      "kabob",
      "kangaroo",
      "karaoke",
      "karate",
      "karma",
      "kebab",
      "keenly",
      "keenness",
      "keep",
      "keg",
      "kelp",
      "kennel",
      "kept",
      "kerchief",
      "kerosene",
      "kettle",
      "kick",
      "kiln",
      "kilobyte",
      "kilogram",
      "kilometer",
      "kilowatt",
      "kilt",
      "kimono",
      "kindle",
      "kindling",
      "kindly",
      "kindness",
      "kindred",
      "kinetic",
      "kinfolk",
      "king",
      "kinship",
      "kinsman",
      "kinswoman",
      "kissable",
      "kisser",
      "kissing",
      "kitchen",
      "kite",
      "kitten",
      "kitty",
      "kiwi",
      "kleenex",
      "knapsack",
      "knee",
      "knelt",
      "knickers",
      "knoll",
      "koala",
      "kooky",
      "kosher",
      "krypton",
      "kudos",
      "kung",
      "labored",
      "laborer",
      "laboring",
      "laborious",
      "labrador",
      "ladder",
      "ladies",
      "ladle",
      "ladybug",
      "ladylike",
      "lagged",
      "lagging",
      "lagoon",
      "lair",
      "lake",
      "lance",
      "landed",
      "landfall",
      "landfill",
      "landing",
      "landlady",
      "landless",
      "landline",
      "landlord",
      "landmark",
      "landmass",
      "landmine",
      "landowner",
      "landscape",
      "landside",
      "landslide",
      "language",
      "lankiness",
      "lanky",
      "lantern",
      "lapdog",
      "lapel",
      "lapped",
      "lapping",
      "laptop",
      "lard",
      "large",
      "lark",
      "lash",
      "lasso",
      "last",
      "latch",
      "late",
      "lather",
      "latitude",
      "latrine",
      "latter",
      "latticed",
      "launch",
      "launder",
      "laundry",
      "laurel",
      "lavender",
      "lavish",
      "laxative",
      "lazily",
      "laziness",
      "lazy",
      "lecturer",
      "left",
      "legacy",
      "legal",
      "legend",
      "legged",
      "leggings",
      "legible",
      "legibly",
      "legislate",
      "lego",
      "legroom",
      "legume",
      "legwarmer",
      "legwork",
      "lemon",
      "lend",
      "length",
      "lens",
      "lent",
      "leotard",
      "lesser",
      "letdown",
      "lethargic",
      "lethargy",
      "letter",
      "lettuce",
      "level",
      "leverage",
      "levers",
      "levitate",
      "levitator",
      "liability",
      "liable",
      "liberty",
      "librarian",
      "library",
      "licking",
      "licorice",
      "lid",
      "life",
      "lifter",
      "lifting",
      "liftoff",
      "ligament",
      "likely",
      "likeness",
      "likewise",
      "liking",
      "lilac",
      "lilly",
      "lily",
      "limb",
      "limeade",
      "limelight",
      "limes",
      "limit",
      "limping",
      "limpness",
      "line",
      "lingo",
      "linguini",
      "linguist",
      "lining",
      "linked",
      "linoleum",
      "linseed",
      "lint",
      "lion",
      "lip",
      "liquefy",
      "liqueur",
      "liquid",
      "lisp",
      "list",
      "litigate",
      "litigator",
      "litmus",
      "litter",
      "little",
      "livable",
      "lived",
      "lively",
      "liver",
      "livestock",
      "lividly",
      "living",
      "lizard",
      "lubricant",
      "lubricate",
      "lucid",
      "luckily",
      "luckiness",
      "luckless",
      "lucrative",
      "ludicrous",
      "lugged",
      "lukewarm",
      "lullaby",
      "lumber",
      "luminance",
      "luminous",
      "lumpiness",
      "lumping",
      "lumpish",
      "lunacy",
      "lunar",
      "lunchbox",
      "luncheon",
      "lunchroom",
      "lunchtime",
      "lung",
      "lurch",
      "lure",
      "luridness",
      "lurk",
      "lushly",
      "lushness",
      "luster",
      "lustfully",
      "lustily",
      "lustiness",
      "lustrous",
      "lusty",
      "luxurious",
      "luxury",
      "lying",
      "lyrically",
      "lyricism",
      "lyricist",
      "lyrics",
      "macarena",
      "macaroni",
      "macaw",
      "mace",
      "machine",
      "machinist",
      "magazine",
      "magenta",
      "maggot",
      "magical",
      "magician",
      "magma",
      "magnesium",
      "magnetic",
      "magnetism",
      "magnetize",
      "magnifier",
      "magnify",
      "magnitude",
      "magnolia",
      "mahogany",
      "maimed",
      "majestic",
      "majesty",
      "majorette",
      "majority",
      "makeover",
      "maker",
      "makeshift",
      "making",
      "malformed",
      "malt",
      "mama",
      "mammal",
      "mammary",
      "mammogram",
      "manager",
      "managing",
      "manatee",
      "mandarin",
      "mandate",
      "mandatory",
      "mandolin",
      "manger",
      "mangle",
      "mango",
      "mangy",
      "manhandle",
      "manhole",
      "manhood",
      "manhunt",
      "manicotti",
      "manicure",
      "manifesto",
      "manila",
      "mankind",
      "manlike",
      "manliness",
      "manly",
      "manmade",
      "manned",
      "mannish",
      "manor",
      "manpower",
      "mantis",
      "mantra",
      "manual",
      "many",
      "map",
      "marathon",
      "marauding",
      "marbled",
      "marbles",
      "marbling",
      "march",
      "mardi",
      "margarine",
      "margarita",
      "margin",
      "marigold",
      "marina",
      "marine",
      "marital",
      "maritime",
      "marlin",
      "marmalade",
      "maroon",
      "married",
      "marrow",
      "marry",
      "marshland",
      "marshy",
      "marsupial",
      "marvelous",
      "marxism",
      "mascot",
      "masculine",
      "mashed",
      "mashing",
      "massager",
      "masses",
      "massive",
      "mastiff",
      "matador",
      "matchbook",
      "matchbox",
      "matcher",
      "matching",
      "matchless",
      "material",
      "maternal",
      "maternity",
      "math",
      "mating",
      "matriarch",
      "matrimony",
      "matrix",
      "matron",
      "matted",
      "matter",
      "maturely",
      "maturing",
      "maturity",
      "mauve",
      "maverick",
      "maximize",
      "maximum",
      "maybe",
      "mayday",
      "mayflower",
      "moaner",
      "moaning",
      "mobile",
      "mobility",
      "mobilize",
      "mobster",
      "mocha",
      "mocker",
      "mockup",
      "modified",
      "modify",
      "modular",
      "modulator",
      "module",
      "moisten",
      "moistness",
      "moisture",
      "molar",
      "molasses",
      "mold",
      "molecular",
      "molecule",
      "molehill",
      "mollusk",
      "mom",
      "monastery",
      "monday",
      "monetary",
      "monetize",
      "moneybags",
      "moneyless",
      "moneywise",
      "mongoose",
      "mongrel",
      "monitor",
      "monkhood",
      "monogamy",
      "monogram",
      "monologue",
      "monopoly",
      "monorail",
      "monotone",
      "monotype",
      "monoxide",
      "monsieur",
      "monsoon",
      "monstrous",
      "monthly",
      "monument",
      "moocher",
      "moodiness",
      "moody",
      "mooing",
      "moonbeam",
      "mooned",
      "moonlight",
      "moonlike",
      "moonlit",
      "moonrise",
      "moonscape",
      "moonshine",
      "moonstone",
      "moonwalk",
      "mop",
      "morale",
      "morality",
      "morally",
      "morbidity",
      "morbidly",
      "morphine",
      "morphing",
      "morse",
      "mortality",
      "mortally",
      "mortician",
      "mortified",
      "mortify",
      "mortuary",
      "mosaic",
      "mossy",
      "most",
      "mothball",
      "mothproof",
      "motion",
      "motivate",
      "motivator",
      "motive",
      "motocross",
      "motor",
      "motto",
      "mountable",
      "mountain",
      "mounted",
      "mounting",
      "mourner",
      "mournful",
      "mouse",
      "mousiness",
      "moustache",
      "mousy",
      "mouth",
      "movable",
      "move",
      "movie",
      "moving",
      "mower",
      "mowing",
      "much",
      "muck",
      "mud",
      "mug",
      "mulberry",
      "mulch",
      "mule",
      "mulled",
      "mullets",
      "multiple",
      "multiply",
      "multitask",
      "multitude",
      "mumble",
      "mumbling",
      "mumbo",
      "mummified",
      "mummify",
      "mummy",
      "mumps",
      "munchkin",
      "mundane",
      "municipal",
      "muppet",
      "mural",
      "murkiness",
      "murky",
      "murmuring",
      "muscular",
      "museum",
      "mushily",
      "mushiness",
      "mushroom",
      "mushy",
      "music",
      "musket",
      "muskiness",
      "musky",
      "mustang",
      "mustard",
      "muster",
      "mustiness",
      "musty",
      "mutable",
      "mutate",
      "mutation",
      "mute",
      "mutilated",
      "mutilator",
      "mutiny",
      "mutt",
      "mutual",
      "muzzle",
      "myself",
      "myspace",
      "mystified",
      "mystify",
      "myth",
      "nacho",
      "nag",
      "nail",
      "name",
      "naming",
      "nanny",
      "nanometer",
      "nape",
      "napkin",
      "napped",
      "napping",
      "nappy",
      "narrow",
      "nastily",
      "nastiness",
      "national",
      "native",
      "nativity",
      "natural",
      "nature",
      "naturist",
      "nautical",
      "navigate",
      "navigator",
      "navy",
      "nearby",
      "nearest",
      "nearly",
      "nearness",
      "neatly",
      "neatness",
      "nebula",
      "nebulizer",
      "nectar",
      "negate",
      "negation",
      "negative",
      "neglector",
      "negligee",
      "negligent",
      "negotiate",
      "nemeses",
      "nemesis",
      "neon",
      "nephew",
      "nerd",
      "nervous",
      "nervy",
      "nest",
      "net",
      "neurology",
      "neuron",
      "neurosis",
      "neurotic",
      "neuter",
      "neutron",
      "never",
      "next",
      "nibble",
      "nickname",
      "nicotine",
      "niece",
      "nifty",
      "nimble",
      "nimbly",
      "nineteen",
      "ninetieth",
      "ninja",
      "nintendo",
      "ninth",
      "nuclear",
      "nuclei",
      "nucleus",
      "nugget",
      "nullify",
      "number",
      "numbing",
      "numbly",
      "numbness",
      "numeral",
      "numerate",
      "numerator",
      "numeric",
      "numerous",
      "nuptials",
      "nursery",
      "nursing",
      "nurture",
      "nutcase",
      "nutlike",
      "nutmeg",
      "nutrient",
      "nutshell",
      "nuttiness",
      "nutty",
      "nuzzle",
      "nylon",
      "oaf",
      "oak",
      "oasis",
      "oat",
      "obedience",
      "obedient",
      "obituary",
      "object",
      "obligate",
      "obliged",
      "oblivion",
      "oblivious",
      "oblong",
      "obnoxious",
      "oboe",
      "obscure",
      "obscurity",
      "observant",
      "observer",
      "observing",
      "obsessed",
      "obsession",
      "obsessive",
      "obsolete",
      "obstacle",
      "obstinate",
      "obstruct",
      "obtain",
      "obtrusive",
      "obtuse",
      "obvious",
      "occultist",
      "occupancy",
      "occupant",
      "occupier",
      "occupy",
      "ocean",
      "ocelot",
      "octagon",
      "octane",
      "october",
      "octopus",
      "ogle",
      "oil",
      "oink",
      "ointment",
      "okay",
      "old",
      "olive",
      "olympics",
      "omega",
      "omen",
      "ominous",
      "omission",
      "omit",
      "omnivore",
      "onboard",
      "oncoming",
      "ongoing",
      "onion",
      "online",
      "onlooker",
      "only",
      "onscreen",
      "onset",
      "onshore",
      "onslaught",
      "onstage",
      "onto",
      "onward",
      "onyx",
      "oops",
      "ooze",
      "oozy",
      "opacity",
      "opal",
      "open",
      "operable",
      "operate",
      "operating",
      "operation",
      "operative",
      "operator",
      "opium",
      "opossum",
      "opponent",
      "oppose",
      "opposing",
      "opposite",
      "oppressed",
      "oppressor",
      "opt",
      "opulently",
      "osmosis",
      "other",
      "otter",
      "ouch",
      "ought",
      "ounce",
      "outage",
      "outback",
      "outbid",
      "outboard",
      "outbound",
      "outbreak",
      "outburst",
      "outcast",
      "outclass",
      "outcome",
      "outdated",
      "outdoors",
      "outer",
      "outfield",
      "outfit",
      "outflank",
      "outgoing",
      "outgrow",
      "outhouse",
      "outing",
      "outlast",
      "outlet",
      "outline",
      "outlook",
      "outlying",
      "outmatch",
      "outmost",
      "outnumber",
      "outplayed",
      "outpost",
      "outpour",
      "output",
      "outrage",
      "outrank",
      "outreach",
      "outright",
      "outscore",
      "outsell",
      "outshine",
      "outshoot",
      "outsider",
      "outskirts",
      "outsmart",
      "outsource",
      "outspoken",
      "outtakes",
      "outthink",
      "outward",
      "outweigh",
      "outwit",
      "oval",
      "ovary",
      "oven",
      "overact",
      "overall",
      "overarch",
      "overbid",
      "overbill",
      "overbite",
      "overblown",
      "overboard",
      "overbook",
      "overbuilt",
      "overcast",
      "overcoat",
      "overcome",
      "overcook",
      "overcrowd",
      "overdraft",
      "overdrawn",
      "overdress",
      "overdrive",
      "overdue",
      "overeager",
      "overeater",
      "overexert",
      "overfed",
      "overfeed",
      "overfill",
      "overflow",
      "overfull",
      "overgrown",
      "overhand",
      "overhang",
      "overhaul",
      "overhead",
      "overhear",
      "overheat",
      "overhung",
      "overjoyed",
      "overkill",
      "overlabor",
      "overlaid",
      "overlap",
      "overlay",
      "overload",
      "overlook",
      "overlord",
      "overlying",
      "overnight",
      "overpass",
      "overpay",
      "overplant",
      "overplay",
      "overpower",
      "overprice",
      "overrate",
      "overreach",
      "overreact",
      "override",
      "overripe",
      "overrule",
      "overrun",
      "overshoot",
      "overshot",
      "oversight",
      "oversized",
      "oversleep",
      "oversold",
      "overspend",
      "overstate",
      "overstay",
      "overstep",
      "overstock",
      "overstuff",
      "oversweet",
      "overtake",
      "overthrow",
      "overtime",
      "overtly",
      "overtone",
      "overture",
      "overturn",
      "overuse",
      "overvalue",
      "overview",
      "overwrite",
      "owl",
      "oxford",
      "oxidant",
      "oxidation",
      "oxidize",
      "oxidizing",
      "oxygen",
      "oxymoron",
      "oyster",
      "ozone",
      "paced",
      "pacemaker",
      "pacific",
      "pacifier",
      "pacifism",
      "pacifist",
      "pacify",
      "padded",
      "padding",
      "paddle",
      "paddling",
      "padlock",
      "pagan",
      "pager",
      "paging",
      "pajamas",
      "palace",
      "palatable",
      "palm",
      "palpable",
      "palpitate",
      "paltry",
      "pampered",
      "pamperer",
      "pampers",
      "pamphlet",
      "panama",
      "pancake",
      "pancreas",
      "panda",
      "pandemic",
      "pang",
      "panhandle",
      "panic",
      "panning",
      "panorama",
      "panoramic",
      "panther",
      "pantomime",
      "pantry",
      "pants",
      "pantyhose",
      "paparazzi",
      "papaya",
      "paper",
      "paprika",
      "papyrus",
      "parabola",
      "parachute",
      "parade",
      "paradox",
      "paragraph",
      "parakeet",
      "paralegal",
      "paralyses",
      "paralysis",
      "paralyze",
      "paramedic",
      "parameter",
      "paramount",
      "parasail",
      "parasite",
      "parasitic",
      "parcel",
      "parched",
      "parchment",
      "pardon",
      "parish",
      "parka",
      "parking",
      "parkway",
      "parlor",
      "parmesan",
      "parole",
      "parrot",
      "parsley",
      "parsnip",
      "partake",
      "parted",
      "parting",
      "partition",
      "partly",
      "partner",
      "partridge",
      "party",
      "passable",
      "passably",
      "passage",
      "passcode",
      "passenger",
      "passerby",
      "passing",
      "passion",
      "passive",
      "passivism",
      "passover",
      "passport",
      "password",
      "pasta",
      "pasted",
      "pastel",
      "pastime",
      "pastor",
      "pastrami",
      "pasture",
      "pasty",
      "patchwork",
      "patchy",
      "paternal",
      "paternity",
      "path",
      "patience",
      "patient",
      "patio",
      "patriarch",
      "patriot",
      "patrol",
      "patronage",
      "patronize",
      "pauper",
      "pavement",
      "paver",
      "pavestone",
      "pavilion",
      "paving",
      "pawing",
      "payable",
      "payback",
      "paycheck",
      "payday",
      "payee",
      "payer",
      "paying",
      "payment",
      "payphone",
      "payroll",
      "pebble",
      "pebbly",
      "pecan",
      "pectin",
      "peculiar",
      "peddling",
      "pediatric",
      "pedicure",
      "pedigree",
      "pedometer",
      "pegboard",
      "pelican",
      "pellet",
      "pelt",
      "pelvis",
      "penalize",
      "penalty",
      "pencil",
      "pendant",
      "pending",
      "penholder",
      "penknife",
      "pennant",
      "penniless",
      "penny",
      "penpal",
      "pension",
      "pentagon",
      "pentagram",
      "pep",
      "perceive",
      "percent",
      "perch",
      "percolate",
      "perennial",
      "perfected",
      "perfectly",
      "perfume",
      "periscope",
      "perish",
      "perjurer",
      "perjury",
      "perkiness",
      "perky",
      "perm",
      "peroxide",
      "perpetual",
      "perplexed",
      "persecute",
      "persevere",
      "persuaded",
      "persuader",
      "pesky",
      "peso",
      "pessimism",
      "pessimist",
      "pester",
      "pesticide",
      "petal",
      "petite",
      "petition",
      "petri",
      "petroleum",
      "petted",
      "petticoat",
      "pettiness",
      "petty",
      "petunia",
      "phantom",
      "phobia",
      "phoenix",
      "phonebook",
      "phoney",
      "phonics",
      "phoniness",
      "phony",
      "phosphate",
      "photo",
      "phrase",
      "phrasing",
      "placard",
      "placate",
      "placidly",
      "plank",
      "planner",
      "plant",
      "plasma",
      "plaster",
      "plastic",
      "plated",
      "platform",
      "plating",
      "platinum",
      "platonic",
      "platter",
      "platypus",
      "plausible",
      "plausibly",
      "playable",
      "playback",
      "player",
      "playful",
      "playgroup",
      "playhouse",
      "playing",
      "playlist",
      "playmaker",
      "playmate",
      "playoff",
      "playpen",
      "playroom",
      "playset",
      "plaything",
      "playtime",
      "plaza",
      "pleading",
      "pleat",
      "pledge",
      "plentiful",
      "plenty",
      "plethora",
      "plexiglas",
      "pliable",
      "plod",
      "plop",
      "plot",
      "plow",
      "ploy",
      "pluck",
      "plug",
      "plunder",
      "plunging",
      "plural",
      "plus",
      "plutonium",
      "plywood",
      "poach",
      "pod",
      "poem",
      "poet",
      "pogo",
      "pointed",
      "pointer",
      "pointing",
      "pointless",
      "pointy",
      "poise",
      "poison",
      "poker",
      "poking",
      "polar",
      "police",
      "policy",
      "polio",
      "polish",
      "politely",
      "polka",
      "polo",
      "polyester",
      "polygon",
      "polygraph",
      "polymer",
      "poncho",
      "pond",
      "pony",
      "popcorn",
      "pope",
      "poplar",
      "popper",
      "poppy",
      "popsicle",
      "populace",
      "popular",
      "populate",
      "porcupine",
      "pork",
      "porous",
      "porridge",
      "portable",
      "portal",
      "portfolio",
      "porthole",
      "portion",
      "portly",
      "portside",
      "poser",
      "posh",
      "posing",
      "possible",
      "possibly",
      "possum",
      "postage",
      "postal",
      "postbox",
      "postcard",
      "posted",
      "poster",
      "posting",
      "postnasal",
      "posture",
      "postwar",
      "pouch",
      "pounce",
      "pouncing",
      "pound",
      "pouring",
      "pout",
      "powdered",
      "powdering",
      "powdery",
      "power",
      "powwow",
      "pox",
      "praising",
      "prance",
      "prancing",
      "pranker",
      "prankish",
      "prankster",
      "prayer",
      "praying",
      "preacher",
      "preaching",
      "preachy",
      "preamble",
      "precinct",
      "precise",
      "precision",
      "precook",
      "precut",
      "predator",
      "predefine",
      "predict",
      "preface",
      "prefix",
      "preflight",
      "preformed",
      "pregame",
      "pregnancy",
      "pregnant",
      "preheated",
      "prelaunch",
      "prelaw",
      "prelude",
      "premiere",
      "premises",
      "premium",
      "prenatal",
      "preoccupy",
      "preorder",
      "prepaid",
      "prepay",
      "preplan",
      "preppy",
      "preschool",
      "prescribe",
      "preseason",
      "preset",
      "preshow",
      "president",
      "presoak",
      "press",
      "presume",
      "presuming",
      "preteen",
      "pretended",
      "pretender",
      "pretense",
      "pretext",
      "pretty",
      "pretzel",
      "prevail",
      "prevalent",
      "prevent",
      "preview",
      "previous",
      "prewar",
      "prewashed",
      "prideful",
      "pried",
      "primal",
      "primarily",
      "primary",
      "primate",
      "primer",
      "primp",
      "princess",
      "print",
      "prior",
      "prism",
      "prison",
      "prissy",
      "pristine",
      "privacy",
      "private",
      "privatize",
      "prize",
      "proactive",
      "probable",
      "probably",
      "probation",
      "probe",
      "probing",
      "probiotic",
      "problem",
      "procedure",
      "process",
      "proclaim",
      "procreate",
      "procurer",
      "prodigal",
      "prodigy",
      "produce",
      "product",
      "profane",
      "profanity",
      "professed",
      "professor",
      "profile",
      "profound",
      "profusely",
      "progeny",
      "prognosis",
      "program",
      "progress",
      "projector",
      "prologue",
      "prolonged",
      "promenade",
      "prominent",
      "promoter",
      "promotion",
      "prompter",
      "promptly",
      "prone",
      "prong",
      "pronounce",
      "pronto",
      "proofing",
      "proofread",
      "proofs",
      "propeller",
      "properly",
      "property",
      "proponent",
      "proposal",
      "propose",
      "props",
      "prorate",
      "protector",
      "protegee",
      "proton",
      "prototype",
      "protozoan",
      "protract",
      "protrude",
      "proud",
      "provable",
      "proved",
      "proven",
      "provided",
      "provider",
      "providing",
      "province",
      "proving",
      "provoke",
      "provoking",
      "provolone",
      "prowess",
      "prowler",
      "prowling",
      "proximity",
      "proxy",
      "prozac",
      "prude",
      "prudishly",
      "prune",
      "pruning",
      "pry",
      "psychic",
      "public",
      "publisher",
      "pucker",
      "pueblo",
      "pug",
      "pull",
      "pulmonary",
      "pulp",
      "pulsate",
      "pulse",
      "pulverize",
      "puma",
      "pumice",
      "pummel",
      "punch",
      "punctual",
      "punctuate",
      "punctured",
      "pungent",
      "punisher",
      "punk",
      "pupil",
      "puppet",
      "puppy",
      "purchase",
      "pureblood",
      "purebred",
      "purely",
      "pureness",
      "purgatory",
      "purge",
      "purging",
      "purifier",
      "purify",
      "purist",
      "puritan",
      "purity",
      "purple",
      "purplish",
      "purposely",
      "purr",
      "purse",
      "pursuable",
      "pursuant",
      "pursuit",
      "purveyor",
      "pushcart",
      "pushchair",
      "pusher",
      "pushiness",
      "pushing",
      "pushover",
      "pushpin",
      "pushup",
      "pushy",
      "putdown",
      "putt",
      "puzzle",
      "puzzling",
      "pyramid",
      "pyromania",
      "python",
      "quack",
      "quadrant",
      "quail",
      "quaintly",
      "quake",
      "quaking",
      "qualified",
      "qualifier",
      "qualify",
      "quality",
      "qualm",
      "quantum",
      "quarrel",
      "quarry",
      "quartered",
      "quarterly",
      "quarters",
      "quartet",
      "quench",
      "query",
      "quicken",
      "quickly",
      "quickness",
      "quicksand",
      "quickstep",
      "quiet",
      "quill",
      "quilt",
      "quintet",
      "quintuple",
      "quirk",
      "quit",
      "quiver",
      "quizzical",
      "quotable",
      "quotation",
      "quote",
      "rabid",
      "race",
      "racing",
      "racism",
      "rack",
      "racoon",
      "radar",
      "radial",
      "radiance",
      "radiantly",
      "radiated",
      "radiation",
      "radiator",
      "radio",
      "radish",
      "raffle",
      "raft",
      "rage",
      "ragged",
      "raging",
      "ragweed",
      "raider",
      "railcar",
      "railing",
      "railroad",
      "railway",
      "raisin",
      "rake",
      "raking",
      "rally",
      "ramble",
      "rambling",
      "ramp",
      "ramrod",
      "ranch",
      "rancidity",
      "random",
      "ranged",
      "ranger",
      "ranging",
      "ranked",
      "ranking",
      "ransack",
      "ranting",
      "rants",
      "rare",
      "rarity",
      "rascal",
      "rash",
      "rasping",
      "ravage",
      "raven",
      "ravine",
      "raving",
      "ravioli",
      "ravishing",
      "reabsorb",
      "reach",
      "reacquire",
      "reaction",
      "reactive",
      "reactor",
      "reaffirm",
      "ream",
      "reanalyze",
      "reappear",
      "reapply",
      "reappoint",
      "reapprove",
      "rearrange",
      "rearview",
      "reason",
      "reassign",
      "reassure",
      "reattach",
      "reawake",
      "rebalance",
      "rebate",
      "rebel",
      "rebirth",
      "reboot",
      "reborn",
      "rebound",
      "rebuff",
      "rebuild",
      "rebuilt",
      "reburial",
      "rebuttal",
      "recall",
      "recant",
      "recapture",
      "recast",
      "recede",
      "recent",
      "recess",
      "recharger",
      "recipient",
      "recital",
      "recite",
      "reckless",
      "reclaim",
      "recliner",
      "reclining",
      "recluse",
      "reclusive",
      "recognize",
      "recoil",
      "recollect",
      "recolor",
      "reconcile",
      "reconfirm",
      "reconvene",
      "recopy",
      "record",
      "recount",
      "recoup",
      "recovery",
      "recreate",
      "rectal",
      "rectangle",
      "rectified",
      "rectify",
      "recycled",
      "recycler",
      "recycling",
      "reemerge",
      "reenact",
      "reenter",
      "reentry",
      "reexamine",
      "referable",
      "referee",
      "reference",
      "refill",
      "refinance",
      "refined",
      "refinery",
      "refining",
      "refinish",
      "reflected",
      "reflector",
      "reflex",
      "reflux",
      "refocus",
      "refold",
      "reforest",
      "reformat",
      "reformed",
      "reformer",
      "reformist",
      "refract",
      "refrain",
      "refreeze",
      "refresh",
      "refried",
      "refueling",
      "refund",
      "refurbish",
      "refurnish",
      "refusal",
      "refuse",
      "refusing",
      "refutable",
      "refute",
      "regain",
      "regalia",
      "regally",
      "reggae",
      "regime",
      "region",
      "register",
      "registrar",
      "registry",
      "regress",
      "regretful",
      "regroup",
      "regular",
      "regulate",
      "regulator",
      "rehab",
      "reheat",
      "rehire",
      "rehydrate",
      "reimburse",
      "reissue",
      "reiterate",
      "rejoice",
      "rejoicing",
      "rejoin",
      "rekindle",
      "relapse",
      "relapsing",
      "relatable",
      "related",
      "relation",
      "relative",
      "relax",
      "relay",
      "relearn",
      "release",
      "relenting",
      "reliable",
      "reliably",
      "reliance",
      "reliant",
      "relic",
      "relieve",
      "relieving",
      "relight",
      "relish",
      "relive",
      "reload",
      "relocate",
      "relock",
      "reluctant",
      "rely",
      "remake",
      "remark",
      "remarry",
      "rematch",
      "remedial",
      "remedy",
      "remember",
      "reminder",
      "remindful",
      "remission",
      "remix",
      "remnant",
      "remodeler",
      "remold",
      "remorse",
      "remote",
      "removable",
      "removal",
      "removed",
      "remover",
      "removing",
      "rename",
      "renderer",
      "rendering",
      "rendition",
      "renegade",
      "renewable",
      "renewably",
      "renewal",
      "renewed",
      "renounce",
      "renovate",
      "renovator",
      "rentable",
      "rental",
      "rented",
      "renter",
      "reoccupy",
      "reoccur",
      "reopen",
      "reorder",
      "repackage",
      "repacking",
      "repaint",
      "repair",
      "repave",
      "repaying",
      "repayment",
      "repeal",
      "repeated",
      "repeater",
      "repent",
      "rephrase",
      "replace",
      "replay",
      "replica",
      "reply",
      "reporter",
      "repose",
      "repossess",
      "repost",
      "repressed",
      "reprimand",
      "reprint",
      "reprise",
      "reproach",
      "reprocess",
      "reproduce",
      "reprogram",
      "reps",
      "reptile",
      "reptilian",
      "repugnant",
      "repulsion",
      "repulsive",
      "repurpose",
      "reputable",
      "reputably",
      "request",
      "require",
      "requisite",
      "reroute",
      "rerun",
      "resale",
      "resample",
      "rescuer",
      "reseal",
      "research",
      "reselect",
      "reseller",
      "resemble",
      "resend",
      "resent",
      "reset",
      "reshape",
      "reshoot",
      "reshuffle",
      "residence",
      "residency",
      "resident",
      "residual",
      "residue",
      "resigned",
      "resilient",
      "resistant",
      "resisting",
      "resize",
      "resolute",
      "resolved",
      "resonant",
      "resonate",
      "resort",
      "resource",
      "respect",
      "resubmit",
      "result",
      "resume",
      "resupply",
      "resurface",
      "resurrect",
      "retail",
      "retainer",
      "retaining",
      "retake",
      "retaliate",
      "retention",
      "rethink",
      "retinal",
      "retired",
      "retiree",
      "retiring",
      "retold",
      "retool",
      "retorted",
      "retouch",
      "retrace",
      "retract",
      "retrain",
      "retread",
      "retreat",
      "retrial",
      "retrieval",
      "retriever",
      "retry",
      "return",
      "retying",
      "retype",
      "reunion",
      "reunite",
      "reusable",
      "reuse",
      "reveal",
      "reveler",
      "revenge",
      "revenue",
      "reverb",
      "revered",
      "reverence",
      "reverend",
      "reversal",
      "reverse",
      "reversing",
      "reversion",
      "revert",
      "revisable",
      "revise",
      "revision",
      "revisit",
      "revivable",
      "revival",
      "reviver",
      "reviving",
      "revocable",
      "revoke",
      "revolt",
      "revolver",
      "revolving",
      "reward",
      "rewash",
      "rewind",
      "rewire",
      "reword",
      "rework",
      "rewrap",
      "rewrite",
      "rhyme",
      "ribbon",
      "ribcage",
      "rice",
      "riches",
      "richly",
      "richness",
      "rickety",
      "ricotta",
      "riddance",
      "ridden",
      "ride",
      "riding",
      "rifling",
      "rift",
      "rigging",
      "rigid",
      "rigor",
      "rimless",
      "rimmed",
      "rind",
      "rink",
      "rinse",
      "rinsing",
      "riot",
      "ripcord",
      "ripeness",
      "ripening",
      "ripping",
      "ripple",
      "rippling",
      "riptide",
      "rise",
      "rising",
      "risk",
      "risotto",
      "ritalin",
      "ritzy",
      "rival",
      "riverbank",
      "riverbed",
      "riverboat",
      "riverside",
      "riveter",
      "riveting",
      "roamer",
      "roaming",
      "roast",
      "robbing",
      "robe",
      "robin",
      "robotics",
      "robust",
      "rockband",
      "rocker",
      "rocket",
      "rockfish",
      "rockiness",
      "rocking",
      "rocklike",
      "rockslide",
      "rockstar",
      "rocky",
      "rogue",
      "roman",
      "romp",
      "rope",
      "roping",
      "roster",
      "rosy",
      "rotten",
      "rotting",
      "rotunda",
      "roulette",
      "rounding",
      "roundish",
      "roundness",
      "roundup",
      "roundworm",
      "routine",
      "routing",
      "rover",
      "roving",
      "royal",
      "rubbed",
      "rubber",
      "rubbing",
      "rubble",
      "rubdown",
      "ruby",
      "ruckus",
      "rudder",
      "rug",
      "ruined",
      "rule",
      "rumble",
      "rumbling",
      "rummage",
      "rumor",
      "runaround",
      "rundown",
      "runner",
      "running",
      "runny",
      "runt",
      "runway",
      "rupture",
      "rural",
      "ruse",
      "rush",
      "rust",
      "rut",
      "sabbath",
      "sabotage",
      "sacrament",
      "sacred",
      "sacrifice",
      "sadden",
      "saddlebag",
      "saddled",
      "saddling",
      "sadly",
      "sadness",
      "safari",
      "safeguard",
      "safehouse",
      "safely",
      "safeness",
      "saffron",
      "saga",
      "sage",
      "sagging",
      "saggy",
      "said",
      "saint",
      "sake",
      "salad",
      "salami",
      "salaried",
      "salary",
      "saline",
      "salon",
      "saloon",
      "salsa",
      "salt",
      "salutary",
      "salute",
      "salvage",
      "salvaging",
      "salvation",
      "same",
      "sample",
      "sampling",
      "sanction",
      "sanctity",
      "sanctuary",
      "sandal",
      "sandbag",
      "sandbank",
      "sandbar",
      "sandblast",
      "sandbox",
      "sanded",
      "sandfish",
      "sanding",
      "sandlot",
      "sandpaper",
      "sandpit",
      "sandstone",
      "sandstorm",
      "sandworm",
      "sandy",
      "sanitary",
      "sanitizer",
      "sank",
      "santa",
      "sapling",
      "sappiness",
      "sappy",
      "sarcasm",
      "sarcastic",
      "sardine",
      "sash",
      "sasquatch",
      "sassy",
      "satchel",
      "satiable",
      "satin",
      "satirical",
      "satisfied",
      "satisfy",
      "saturate",
      "saturday",
      "sauciness",
      "saucy",
      "sauna",
      "savage",
      "savanna",
      "saved",
      "savings",
      "savior",
      "savor",
      "saxophone",
      "say",
      "scabbed",
      "scabby",
      "scalded",
      "scalding",
      "scale",
      "scaling",
      "scallion",
      "scallop",
      "scalping",
      "scam",
      "scandal",
      "scanner",
      "scanning",
      "scant",
      "scapegoat",
      "scarce",
      "scarcity",
      "scarecrow",
      "scared",
      "scarf",
      "scarily",
      "scariness",
      "scarring",
      "scary",
      "scavenger",
      "scenic",
      "schedule",
      "schematic",
      "scheme",
      "scheming",
      "schilling",
      "schnapps",
      "scholar",
      "science",
      "scientist",
      "scion",
      "scoff",
      "scolding",
      "scone",
      "scoop",
      "scooter",
      "scope",
      "scorch",
      "scorebook",
      "scorecard",
      "scored",
      "scoreless",
      "scorer",
      "scoring",
      "scorn",
      "scorpion",
      "scotch",
      "scoundrel",
      "scoured",
      "scouring",
      "scouting",
      "scouts",
      "scowling",
      "scrabble",
      "scraggly",
      "scrambled",
      "scrambler",
      "scrap",
      "scratch",
      "scrawny",
      "screen",
      "scribble",
      "scribe",
      "scribing",
      "scrimmage",
      "script",
      "scroll",
      "scrooge",
      "scrounger",
      "scrubbed",
      "scrubber",
      "scruffy",
      "scrunch",
      "scrutiny",
      "scuba",
      "scuff",
      "sculptor",
      "sculpture",
      "scurvy",
      "scuttle",
      "secluded",
      "secluding",
      "seclusion",
      "second",
      "secrecy",
      "secret",
      "sectional",
      "sector",
      "secular",
      "securely",
      "security",
      "sedan",
      "sedate",
      "sedation",
      "sedative",
      "sediment",
      "seduce",
      "seducing",
      "segment",
      "seismic",
      "seizing",
      "seldom",
      "selected",
      "selection",
      "selective",
      "selector",
      "self",
      "seltzer",
      "semantic",
      "semester",
      "semicolon",
      "semifinal",
      "seminar",
      "semisoft",
      "semisweet",
      "senate",
      "senator",
      "send",
      "senior",
      "senorita",
      "sensation",
      "sensitive",
      "sensitize",
      "sensually",
      "sensuous",
      "sepia",
      "september",
      "septic",
      "septum",
      "sequel",
      "sequence",
      "sequester",
      "series",
      "sermon",
      "serotonin",
      "serpent",
      "serrated",
      "serve",
      "service",
      "serving",
      "sesame",
      "sessions",
      "setback",
      "setting",
      "settle",
      "settling",
      "setup",
      "sevenfold",
      "seventeen",
      "seventh",
      "seventy",
      "severity",
      "shabby",
      "shack",
      "shaded",
      "shadily",
      "shadiness",
      "shading",
      "shadow",
      "shady",
      "shaft",
      "shakable",
      "shakily",
      "shakiness",
      "shaking",
      "shaky",
      "shale",
      "shallot",
      "shallow",
      "shame",
      "shampoo",
      "shamrock",
      "shank",
      "shanty",
      "shape",
      "shaping",
      "share",
      "sharpener",
      "sharper",
      "sharpie",
      "sharply",
      "sharpness",
      "shawl",
      "sheath",
      "shed",
      "sheep",
      "sheet",
      "shelf",
      "shell",
      "shelter",
      "shelve",
      "shelving",
      "sherry",
      "shield",
      "shifter",
      "shifting",
      "shiftless",
      "shifty",
      "shimmer",
      "shimmy",
      "shindig",
      "shine",
      "shingle",
      "shininess",
      "shining",
      "shiny",
      "ship",
      "shirt",
      "shivering",
      "shock",
      "shone",
      "shoplift",
      "shopper",
      "shopping",
      "shoptalk",
      "shore",
      "shortage",
      "shortcake",
      "shortcut",
      "shorten",
      "shorter",
      "shorthand",
      "shortlist",
      "shortly",
      "shortness",
      "shorts",
      "shortwave",
      "shorty",
      "shout",
      "shove",
      "showbiz",
      "showcase",
      "showdown",
      "shower",
      "showgirl",
      "showing",
      "showman",
      "shown",
      "showoff",
      "showpiece",
      "showplace",
      "showroom",
      "showy",
      "shrank",
      "shrapnel",
      "shredder",
      "shredding",
      "shrewdly",
      "shriek",
      "shrill",
      "shrimp",
      "shrine",
      "shrink",
      "shrivel",
      "shrouded",
      "shrubbery",
      "shrubs",
      "shrug",
      "shrunk",
      "shucking",
      "shudder",
      "shuffle",
      "shuffling",
      "shun",
      "shush",
      "shut",
      "shy",
      "siamese",
      "siberian",
      "sibling",
      "siding",
      "sierra",
      "siesta",
      "sift",
      "sighing",
      "silenced",
      "silencer",
      "silent",
      "silica",
      "silicon",
      "silk",
      "silliness",
      "silly",
      "silo",
      "silt",
      "silver",
      "similarly",
      "simile",
      "simmering",
      "simple",
      "simplify",
      "simply",
      "sincere",
      "sincerity",
      "singer",
      "singing",
      "single",
      "singular",
      "sinister",
      "sinless",
      "sinner",
      "sinuous",
      "sip",
      "siren",
      "sister",
      "sitcom",
      "sitter",
      "sitting",
      "situated",
      "situation",
      "sixfold",
      "sixteen",
      "sixth",
      "sixties",
      "sixtieth",
      "sixtyfold",
      "sizable",
      "sizably",
      "size",
      "sizing",
      "sizzle",
      "sizzling",
      "skater",
      "skating",
      "skedaddle",
      "skeletal",
      "skeleton",
      "skeptic",
      "sketch",
      "skewed",
      "skewer",
      "skid",
      "skied",
      "skier",
      "skies",
      "skiing",
      "skilled",
      "skillet",
      "skillful",
      "skimmed",
      "skimmer",
      "skimming",
      "skimpily",
      "skincare",
      "skinhead",
      "skinless",
      "skinning",
      "skinny",
      "skintight",
      "skipper",
      "skipping",
      "skirmish",
      "skirt",
      "skittle",
      "skydiver",
      "skylight",
      "skyline",
      "skype",
      "skyrocket",
      "skyward",
      "slab",
      "slacked",
      "slacker",
      "slacking",
      "slackness",
      "slacks",
      "slain",
      "slam",
      "slander",
      "slang",
      "slapping",
      "slapstick",
      "slashed",
      "slashing",
      "slate",
      "slather",
      "slaw",
      "sled",
      "sleek",
      "sleep",
      "sleet",
      "sleeve",
      "slept",
      "sliceable",
      "sliced",
      "slicer",
      "slicing",
      "slick",
      "slider",
      "slideshow",
      "sliding",
      "slighted",
      "slighting",
      "slightly",
      "slimness",
      "slimy",
      "slinging",
      "slingshot",
      "slinky",
      "slip",
      "slit",
      "sliver",
      "slobbery",
      "slogan",
      "sloped",
      "sloping",
      "sloppily",
      "sloppy",
      "slot",
      "slouching",
      "slouchy",
      "sludge",
      "slug",
      "slum",
      "slurp",
      "slush",
      "sly",
      "small",
      "smartly",
      "smartness",
      "smasher",
      "smashing",
      "smashup",
      "smell",
      "smelting",
      "smile",
      "smilingly",
      "smirk",
      "smite",
      "smith",
      "smitten",
      "smock",
      "smog",
      "smoked",
      "smokeless",
      "smokiness",
      "smoking",
      "smoky",
      "smolder",
      "smooth",
      "smother",
      "smudge",
      "smudgy",
      "smuggler",
      "smuggling",
      "smugly",
      "smugness",
      "snack",
      "snagged",
      "snaking",
      "snap",
      "snare",
      "snarl",
      "snazzy",
      "sneak",
      "sneer",
      "sneeze",
      "sneezing",
      "snide",
      "sniff",
      "snippet",
      "snipping",
      "snitch",
      "snooper",
      "snooze",
      "snore",
      "snoring",
      "snorkel",
      "snort",
      "snout",
      "snowbird",
      "snowboard",
      "snowbound",
      "snowcap",
      "snowdrift",
      "snowdrop",
      "snowfall",
      "snowfield",
      "snowflake",
      "snowiness",
      "snowless",
      "snowman",
      "snowplow",
      "snowshoe",
      "snowstorm",
      "snowsuit",
      "snowy",
      "snub",
      "snuff",
      "snuggle",
      "snugly",
      "snugness",
      "speak",
      "spearfish",
      "spearhead",
      "spearman",
      "spearmint",
      "species",
      "specimen",
      "specked",
      "speckled",
      "specks",
      "spectacle",
      "spectator",
      "spectrum",
      "speculate",
      "speech",
      "speed",
      "spellbind",
      "speller",
      "spelling",
      "spendable",
      "spender",
      "spending",
      "spent",
      "spew",
      "sphere",
      "spherical",
      "sphinx",
      "spider",
      "spied",
      "spiffy",
      "spill",
      "spilt",
      "spinach",
      "spinal",
      "spindle",
      "spinner",
      "spinning",
      "spinout",
      "spinster",
      "spiny",
      "spiral",
      "spirited",
      "spiritism",
      "spirits",
      "spiritual",
      "splashed",
      "splashing",
      "splashy",
      "splatter",
      "spleen",
      "splendid",
      "splendor",
      "splice",
      "splicing",
      "splinter",
      "splotchy",
      "splurge",
      "spoilage",
      "spoiled",
      "spoiler",
      "spoiling",
      "spoils",
      "spoken",
      "spokesman",
      "sponge",
      "spongy",
      "sponsor",
      "spoof",
      "spookily",
      "spooky",
      "spool",
      "spoon",
      "spore",
      "sporting",
      "sports",
      "sporty",
      "spotless",
      "spotlight",
      "spotted",
      "spotter",
      "spotting",
      "spotty",
      "spousal",
      "spouse",
      "spout",
      "sprain",
      "sprang",
      "sprawl",
      "spray",
      "spree",
      "sprig",
      "spring",
      "sprinkled",
      "sprinkler",
      "sprint",
      "sprite",
      "sprout",
      "spruce",
      "sprung",
      "spry",
      "spud",
      "spur",
      "sputter",
      "spyglass",
      "squabble",
      "squad",
      "squall",
      "squander",
      "squash",
      "squatted",
      "squatter",
      "squatting",
      "squeak",
      "squealer",
      "squealing",
      "squeamish",
      "squeegee",
      "squeeze",
      "squeezing",
      "squid",
      "squiggle",
      "squiggly",
      "squint",
      "squire",
      "squirt",
      "squishier",
      "squishy",
      "stability",
      "stabilize",
      "stable",
      "stack",
      "stadium",
      "staff",
      "stage",
      "staging",
      "stagnant",
      "stagnate",
      "stainable",
      "stained",
      "staining",
      "stainless",
      "stalemate",
      "staleness",
      "stalling",
      "stallion",
      "stamina",
      "stammer",
      "stamp",
      "stand",
      "stank",
      "staple",
      "stapling",
      "starboard",
      "starch",
      "stardom",
      "stardust",
      "starfish",
      "stargazer",
      "staring",
      "stark",
      "starless",
      "starlet",
      "starlight",
      "starlit",
      "starring",
      "starry",
      "starship",
      "starter",
      "starting",
      "startle",
      "startling",
      "startup",
      "starved",
      "starving",
      "stash",
      "state",
      "static",
      "statistic",
      "statue",
      "stature",
      "status",
      "statute",
      "statutory",
      "staunch",
      "stays",
      "steadfast",
      "steadier",
      "steadily",
      "steadying",
      "steam",
      "steed",
      "steep",
      "steerable",
      "steering",
      "steersman",
      "stegosaur",
      "stellar",
      "stem",
      "stench",
      "stencil",
      "step",
      "stereo",
      "sterile",
      "sterility",
      "sterilize",
      "sterling",
      "sternness",
      "sternum",
      "stew",
      "stick",
      "stiffen",
      "stiffly",
      "stiffness",
      "stifle",
      "stifling",
      "stillness",
      "stilt",
      "stimulant",
      "stimulate",
      "stimuli",
      "stimulus",
      "stinger",
      "stingily",
      "stinging",
      "stingray",
      "stingy",
      "stinking",
      "stinky",
      "stipend",
      "stipulate",
      "stir",
      "stitch",
      "stock",
      "stoic",
      "stoke",
      "stole",
      "stomp",
      "stonewall",
      "stoneware",
      "stonework",
      "stoning",
      "stony",
      "stood",
      "stooge",
      "stool",
      "stoop",
      "stoplight",
      "stoppable",
      "stoppage",
      "stopped",
      "stopper",
      "stopping",
      "stopwatch",
      "storable",
      "storage",
      "storeroom",
      "storewide",
      "storm",
      "stout",
      "stove",
      "stowaway",
      "stowing",
      "straddle",
      "straggler",
      "strained",
      "strainer",
      "straining",
      "strangely",
      "stranger",
      "strangle",
      "strategic",
      "strategy",
      "stratus",
      "straw",
      "stray",
      "streak",
      "stream",
      "street",
      "strength",
      "strenuous",
      "strep",
      "stress",
      "stretch",
      "strewn",
      "stricken",
      "strict",
      "stride",
      "strife",
      "strike",
      "striking",
      "strive",
      "striving",
      "strobe",
      "strode",
      "stroller",
      "strongbox",
      "strongly",
      "strongman",
      "struck",
      "structure",
      "strudel",
      "struggle",
      "strum",
      "strung",
      "strut",
      "stubbed",
      "stubble",
      "stubbly",
      "stubborn",
      "stucco",
      "stuck",
      "student",
      "studied",
      "studio",
      "study",
      "stuffed",
      "stuffing",
      "stuffy",
      "stumble",
      "stumbling",
      "stump",
      "stung",
      "stunned",
      "stunner",
      "stunning",
      "stunt",
      "stupor",
      "sturdily",
      "sturdy",
      "styling",
      "stylishly",
      "stylist",
      "stylized",
      "stylus",
      "suave",
      "subarctic",
      "subatomic",
      "subdivide",
      "subdued",
      "subduing",
      "subfloor",
      "subgroup",
      "subheader",
      "subject",
      "sublease",
      "sublet",
      "sublevel",
      "sublime",
      "submarine",
      "submerge",
      "submersed",
      "submitter",
      "subpanel",
      "subpar",
      "subplot",
      "subprime",
      "subscribe",
      "subscript",
      "subsector",
      "subside",
      "subsiding",
      "subsidize",
      "subsidy",
      "subsoil",
      "subsonic",
      "substance",
      "subsystem",
      "subtext",
      "subtitle",
      "subtly",
      "subtotal",
      "subtract",
      "subtype",
      "suburb",
      "subway",
      "subwoofer",
      "subzero",
      "succulent",
      "such",
      "suction",
      "sudden",
      "sudoku",
      "suds",
      "sufferer",
      "suffering",
      "suffice",
      "suffix",
      "suffocate",
      "suffrage",
      "sugar",
      "suggest",
      "suing",
      "suitable",
      "suitably",
      "suitcase",
      "suitor",
      "sulfate",
      "sulfide",
      "sulfite",
      "sulfur",
      "sulk",
      "sullen",
      "sulphate",
      "sulphuric",
      "sultry",
      "superbowl",
      "superglue",
      "superhero",
      "superior",
      "superjet",
      "superman",
      "supermom",
      "supernova",
      "supervise",
      "supper",
      "supplier",
      "supply",
      "support",
      "supremacy",
      "supreme",
      "surcharge",
      "surely",
      "sureness",
      "surface",
      "surfacing",
      "surfboard",
      "surfer",
      "surgery",
      "surgical",
      "surging",
      "surname",
      "surpass",
      "surplus",
      "surprise",
      "surreal",
      "surrender",
      "surrogate",
      "surround",
      "survey",
      "survival",
      "survive",
      "surviving",
      "survivor",
      "sushi",
      "suspect",
      "suspend",
      "suspense",
      "sustained",
      "sustainer",
      "swab",
      "swaddling",
      "swagger",
      "swampland",
      "swan",
      "swapping",
      "swarm",
      "sway",
      "swear",
      "sweat",
      "sweep",
      "swell",
      "swept",
      "swerve",
      "swifter",
      "swiftly",
      "swiftness",
      "swimmable",
      "swimmer",
      "swimming",
      "swimsuit",
      "swimwear",
      "swinger",
      "swinging",
      "swipe",
      "swirl",
      "switch",
      "swivel",
      "swizzle",
      "swooned",
      "swoop",
      "swoosh",
      "swore",
      "sworn",
      "swung",
      "sycamore",
      "sympathy",
      "symphonic",
      "symphony",
      "symptom",
      "synapse",
      "syndrome",
      "synergy",
      "synopses",
      "synopsis",
      "synthesis",
      "synthetic",
      "syrup",
      "system",
      "t-shirt",
      "tabasco",
      "tabby",
      "tableful",
      "tables",
      "tablet",
      "tableware",
      "tabloid",
      "tackiness",
      "tacking",
      "tackle",
      "tackling",
      "tacky",
      "taco",
      "tactful",
      "tactical",
      "tactics",
      "tactile",
      "tactless",
      "tadpole",
      "taekwondo",
      "tag",
      "tainted",
      "take",
      "taking",
      "talcum",
      "talisman",
      "tall",
      "talon",
      "tamale",
      "tameness",
      "tamer",
      "tamper",
      "tank",
      "tanned",
      "tannery",
      "tanning",
      "tantrum",
      "tapeless",
      "tapered",
      "tapering",
      "tapestry",
      "tapioca",
      "tapping",
      "taps",
      "tarantula",
      "target",
      "tarmac",
      "tarnish",
      "tarot",
      "tartar",
      "tartly",
      "tartness",
      "task",
      "tassel",
      "taste",
      "tastiness",
      "tasting",
      "tasty",
      "tattered",
      "tattle",
      "tattling",
      "tattoo",
      "taunt",
      "tavern",
      "thank",
      "that",
      "thaw",
      "theater",
      "theatrics",
      "thee",
      "theft",
      "theme",
      "theology",
      "theorize",
      "thermal",
      "thermos",
      "thesaurus",
      "these",
      "thesis",
      "thespian",
      "thicken",
      "thicket",
      "thickness",
      "thieving",
      "thievish",
      "thigh",
      "thimble",
      "thing",
      "think",
      "thinly",
      "thinner",
      "thinness",
      "thinning",
      "thirstily",
      "thirsting",
      "thirsty",
      "thirteen",
      "thirty",
      "thong",
      "thorn",
      "those",
      "thousand",
      "thrash",
      "thread",
      "threaten",
      "threefold",
      "thrift",
      "thrill",
      "thrive",
      "thriving",
      "throat",
      "throbbing",
      "throng",
      "throttle",
      "throwaway",
      "throwback",
      "thrower",
      "throwing",
      "thud",
      "thumb",
      "thumping",
      "thursday",
      "thus",
      "thwarting",
      "thyself",
      "tiara",
      "tibia",
      "tidal",
      "tidbit",
      "tidiness",
      "tidings",
      "tidy",
      "tiger",
      "tighten",
      "tightly",
      "tightness",
      "tightrope",
      "tightwad",
      "tigress",
      "tile",
      "tiling",
      "till",
      "tilt",
      "timid",
      "timing",
      "timothy",
      "tinderbox",
      "tinfoil",
      "tingle",
      "tingling",
      "tingly",
      "tinker",
      "tinkling",
      "tinsel",
      "tinsmith",
      "tint",
      "tinwork",
      "tiny",
      "tipoff",
      "tipped",
      "tipper",
      "tipping",
      "tiptoeing",
      "tiptop",
      "tiring",
      "tissue",
      "trace",
      "tracing",
      "track",
      "traction",
      "tractor",
      "trade",
      "trading",
      "tradition",
      "traffic",
      "tragedy",
      "trailing",
      "trailside",
      "train",
      "traitor",
      "trance",
      "tranquil",
      "transfer",
      "transform",
      "translate",
      "transpire",
      "transport",
      "transpose",
      "trapdoor",
      "trapeze",
      "trapezoid",
      "trapped",
      "trapper",
      "trapping",
      "traps",
      "trash",
      "travel",
      "traverse",
      "travesty",
      "tray",
      "treachery",
      "treading",
      "treadmill",
      "treason",
      "treat",
      "treble",
      "tree",
      "trekker",
      "tremble",
      "trembling",
      "tremor",
      "trench",
      "trend",
      "trespass",
      "triage",
      "trial",
      "triangle",
      "tribesman",
      "tribunal",
      "tribune",
      "tributary",
      "tribute",
      "triceps",
      "trickery",
      "trickily",
      "tricking",
      "trickle",
      "trickster",
      "tricky",
      "tricolor",
      "tricycle",
      "trident",
      "tried",
      "trifle",
      "trifocals",
      "trillion",
      "trilogy",
      "trimester",
      "trimmer",
      "trimming",
      "trimness",
      "trinity",
      "trio",
      "tripod",
      "tripping",
      "triumph",
      "trivial",
      "trodden",
      "trolling",
      "trombone",
      "trophy",
      "tropical",
      "tropics",
      "trouble",
      "troubling",
      "trough",
      "trousers",
      "trout",
      "trowel",
      "truce",
      "truck",
      "truffle",
      "trump",
      "trunks",
      "trustable",
      "trustee",
      "trustful",
      "trusting",
      "trustless",
      "truth",
      "try",
      "tubby",
      "tubeless",
      "tubular",
      "tucking",
      "tuesday",
      "tug",
      "tuition",
      "tulip",
      "tumble",
      "tumbling",
      "tummy",
      "turban",
      "turbine",
      "turbofan",
      "turbojet",
      "turbulent",
      "turf",
      "turkey",
      "turmoil",
      "turret",
      "turtle",
      "tusk",
      "tutor",
      "tutu",
      "tux",
      "tweak",
      "tweed",
      "tweet",
      "tweezers",
      "twelve",
      "twentieth",
      "twenty",
      "twerp",
      "twice",
      "twiddle",
      "twiddling",
      "twig",
      "twilight",
      "twine",
      "twins",
      "twirl",
      "twistable",
      "twisted",
      "twister",
      "twisting",
      "twisty",
      "twitch",
      "twitter",
      "tycoon",
      "tying",
      "tyke",
      "udder",
      "ultimate",
      "ultimatum",
      "ultra",
      "umbilical",
      "umbrella",
      "umpire",
      "unabashed",
      "unable",
      "unadorned",
      "unadvised",
      "unafraid",
      "unaired",
      "unaligned",
      "unaltered",
      "unarmored",
      "unashamed",
      "unaudited",
      "unawake",
      "unaware",
      "unbaked",
      "unbalance",
      "unbeaten",
      "unbend",
      "unbent",
      "unbiased",
      "unbitten",
      "unblended",
      "unblessed",
      "unblock",
      "unbolted",
      "unbounded",
      "unboxed",
      "unbraided",
      "unbridle",
      "unbroken",
      "unbuckled",
      "unbundle",
      "unburned",
      "unbutton",
      "uncanny",
      "uncapped",
      "uncaring",
      "uncertain",
      "unchain",
      "unchanged",
      "uncharted",
      "uncheck",
      "uncivil",
      "unclad",
      "unclaimed",
      "unclamped",
      "unclasp",
      "uncle",
      "unclip",
      "uncloak",
      "unclog",
      "unclothed",
      "uncoated",
      "uncoiled",
      "uncolored",
      "uncombed",
      "uncommon",
      "uncooked",
      "uncork",
      "uncorrupt",
      "uncounted",
      "uncouple",
      "uncouth",
      "uncover",
      "uncross",
      "uncrown",
      "uncrushed",
      "uncured",
      "uncurious",
      "uncurled",
      "uncut",
      "undamaged",
      "undated",
      "undaunted",
      "undead",
      "undecided",
      "undefined",
      "underage",
      "underarm",
      "undercoat",
      "undercook",
      "undercut",
      "underdog",
      "underdone",
      "underfed",
      "underfeed",
      "underfoot",
      "undergo",
      "undergrad",
      "underhand",
      "underline",
      "underling",
      "undermine",
      "undermost",
      "underpaid",
      "underpass",
      "underpay",
      "underrate",
      "undertake",
      "undertone",
      "undertook",
      "undertow",
      "underuse",
      "underwear",
      "underwent",
      "underwire",
      "undesired",
      "undiluted",
      "undivided",
      "undocked",
      "undoing",
      "undone",
      "undrafted",
      "undress",
      "undrilled",
      "undusted",
      "undying",
      "unearned",
      "unearth",
      "unease",
      "uneasily",
      "uneasy",
      "uneatable",
      "uneaten",
      "unedited",
      "unelected",
      "unending",
      "unengaged",
      "unenvied",
      "unequal",
      "unethical",
      "uneven",
      "unexpired",
      "unexposed",
      "unfailing",
      "unfair",
      "unfasten",
      "unfazed",
      "unfeeling",
      "unfiled",
      "unfilled",
      "unfitted",
      "unfitting",
      "unfixable",
      "unfixed",
      "unflawed",
      "unfocused",
      "unfold",
      "unfounded",
      "unframed",
      "unfreeze",
      "unfrosted",
      "unfrozen",
      "unfunded",
      "unglazed",
      "ungloved",
      "unglue",
      "ungodly",
      "ungraded",
      "ungreased",
      "unguarded",
      "unguided",
      "unhappily",
      "unhappy",
      "unharmed",
      "unhealthy",
      "unheard",
      "unhearing",
      "unheated",
      "unhelpful",
      "unhidden",
      "unhinge",
      "unhitched",
      "unholy",
      "unhook",
      "unicorn",
      "unicycle",
      "unified",
      "unifier",
      "uniformed",
      "uniformly",
      "unify",
      "unimpeded",
      "uninjured",
      "uninstall",
      "uninsured",
      "uninvited",
      "union",
      "uniquely",
      "unisexual",
      "unison",
      "unissued",
      "unit",
      "universal",
      "universe",
      "unjustly",
      "unkempt",
      "unkind",
      "unknotted",
      "unknowing",
      "unknown",
      "unlaced",
      "unlatch",
      "unlawful",
      "unleaded",
      "unlearned",
      "unleash",
      "unless",
      "unleveled",
      "unlighted",
      "unlikable",
      "unlimited",
      "unlined",
      "unlinked",
      "unlisted",
      "unlit",
      "unlivable",
      "unloaded",
      "unloader",
      "unlocked",
      "unlocking",
      "unlovable",
      "unloved",
      "unlovely",
      "unloving",
      "unluckily",
      "unlucky",
      "unmade",
      "unmanaged",
      "unmanned",
      "unmapped",
      "unmarked",
      "unmasked",
      "unmasking",
      "unmatched",
      "unmindful",
      "unmixable",
      "unmixed",
      "unmolded",
      "unmoral",
      "unmovable",
      "unmoved",
      "unmoving",
      "unnamable",
      "unnamed",
      "unnatural",
      "unneeded",
      "unnerve",
      "unnerving",
      "unnoticed",
      "unopened",
      "unopposed",
      "unpack",
      "unpadded",
      "unpaid",
      "unpainted",
      "unpaired",
      "unpaved",
      "unpeeled",
      "unpicked",
      "unpiloted",
      "unpinned",
      "unplanned",
      "unplanted",
      "unpleased",
      "unpledged",
      "unplowed",
      "unplug",
      "unpopular",
      "unproven",
      "unquote",
      "unranked",
      "unrated",
      "unraveled",
      "unreached",
      "unread",
      "unreal",
      "unreeling",
      "unrefined",
      "unrelated",
      "unrented",
      "unrest",
      "unretired",
      "unrevised",
      "unrigged",
      "unripe",
      "unrivaled",
      "unroasted",
      "unrobed",
      "unroll",
      "unruffled",
      "unruly",
      "unrushed",
      "unsaddle",
      "unsafe",
      "unsaid",
      "unsalted",
      "unsaved",
      "unsavory",
      "unscathed",
      "unscented",
      "unscrew",
      "unsealed",
      "unseated",
      "unsecured",
      "unseeing",
      "unseemly",
      "unseen",
      "unselect",
      "unselfish",
      "unsent",
      "unsettled",
      "unshackle",
      "unshaken",
      "unshaved",
      "unshaven",
      "unsheathe",
      "unshipped",
      "unsightly",
      "unsigned",
      "unskilled",
      "unsliced",
      "unsmooth",
      "unsnap",
      "unsocial",
      "unsoiled",
      "unsold",
      "unsolved",
      "unsorted",
      "unspoiled",
      "unspoken",
      "unstable",
      "unstaffed",
      "unstamped",
      "unsteady",
      "unsterile",
      "unstirred",
      "unstitch",
      "unstopped",
      "unstuck",
      "unstuffed",
      "unstylish",
      "unsubtle",
      "unsubtly",
      "unsuited",
      "unsure",
      "unsworn",
      "untagged",
      "untainted",
      "untaken",
      "untamed",
      "untangled",
      "untapped",
      "untaxed",
      "unthawed",
      "unthread",
      "untidy",
      "untie",
      "until",
      "untimed",
      "untimely",
      "untitled",
      "untoasted",
      "untold",
      "untouched",
      "untracked",
      "untrained",
      "untreated",
      "untried",
      "untrimmed",
      "untrue",
      "untruth",
      "unturned",
      "untwist",
      "untying",
      "unusable",
      "unused",
      "unusual",
      "unvalued",
      "unvaried",
      "unvarying",
      "unveiled",
      "unveiling",
      "unvented",
      "unviable",
      "unvisited",
      "unvocal",
      "unwanted",
      "unwarlike",
      "unwary",
      "unwashed",
      "unwatched",
      "unweave",
      "unwed",
      "unwelcome",
      "unwell",
      "unwieldy",
      "unwilling",
      "unwind",
      "unwired",
      "unwitting",
      "unwomanly",
      "unworldly",
      "unworn",
      "unworried",
      "unworthy",
      "unwound",
      "unwoven",
      "unwrapped",
      "unwritten",
      "unzip",
      "upbeat",
      "upchuck",
      "upcoming",
      "upcountry",
      "update",
      "upfront",
      "upgrade",
      "upheaval",
      "upheld",
      "uphill",
      "uphold",
      "uplifted",
      "uplifting",
      "upload",
      "upon",
      "upper",
      "upright",
      "uprising",
      "upriver",
      "uproar",
      "uproot",
      "upscale",
      "upside",
      "upstage",
      "upstairs",
      "upstart",
      "upstate",
      "upstream",
      "upstroke",
      "upswing",
      "uptake",
      "uptight",
      "uptown",
      "upturned",
      "upward",
      "upwind",
      "uranium",
      "urban",
      "urchin",
      "urethane",
      "urgency",
      "urgent",
      "urging",
      "urologist",
      "urology",
      "usable",
      "usage",
      "useable",
      "used",
      "uselessly",
      "user",
      "usher",
      "usual",
      "utensil",
      "utility",
      "utilize",
      "utmost",
      "utopia",
      "utter",
      "vacancy",
      "vacant",
      "vacate",
      "vacation",
      "vagabond",
      "vagrancy",
      "vagrantly",
      "vaguely",
      "vagueness",
      "valiant",
      "valid",
      "valium",
      "valley",
      "valuables",
      "value",
      "vanilla",
      "vanish",
      "vanity",
      "vanquish",
      "vantage",
      "vaporizer",
      "variable",
      "variably",
      "varied",
      "variety",
      "various",
      "varmint",
      "varnish",
      "varsity",
      "varying",
      "vascular",
      "vaseline",
      "vastly",
      "vastness",
      "veal",
      "vegan",
      "veggie",
      "vehicular",
      "velcro",
      "velocity",
      "velvet",
      "vendetta",
      "vending",
      "vendor",
      "veneering",
      "vengeful",
      "venomous",
      "ventricle",
      "venture",
      "venue",
      "venus",
      "verbalize",
      "verbally",
      "verbose",
      "verdict",
      "verify",
      "verse",
      "version",
      "versus",
      "vertebrae",
      "vertical",
      "vertigo",
      "very",
      "vessel",
      "vest",
      "veteran",
      "veto",
      "vexingly",
      "viability",
      "viable",
      "vibes",
      "vice",
      "vicinity",
      "victory",
      "video",
      "viewable",
      "viewer",
      "viewing",
      "viewless",
      "viewpoint",
      "vigorous",
      "village",
      "villain",
      "vindicate",
      "vineyard",
      "vintage",
      "violate",
      "violation",
      "violator",
      "violet",
      "violin",
      "viper",
      "viral",
      "virtual",
      "virtuous",
      "virus",
      "visa",
      "viscosity",
      "viscous",
      "viselike",
      "visible",
      "visibly",
      "vision",
      "visiting",
      "visitor",
      "visor",
      "vista",
      "vitality",
      "vitalize",
      "vitally",
      "vitamins",
      "vivacious",
      "vividly",
      "vividness",
      "vixen",
      "vocalist",
      "vocalize",
      "vocally",
      "vocation",
      "voice",
      "voicing",
      "void",
      "volatile",
      "volley",
      "voltage",
      "volumes",
      "voter",
      "voting",
      "voucher",
      "vowed",
      "vowel",
      "voyage",
      "wackiness",
      "wad",
      "wafer",
      "waffle",
      "waged",
      "wager",
      "wages",
      "waggle",
      "wagon",
      "wake",
      "waking",
      "walk",
      "walmart",
      "walnut",
      "walrus",
      "waltz",
      "wand",
      "wannabe",
      "wanted",
      "wanting",
      "wasabi",
      "washable",
      "washbasin",
      "washboard",
      "washbowl",
      "washcloth",
      "washday",
      "washed",
      "washer",
      "washhouse",
      "washing",
      "washout",
      "washroom",
      "washstand",
      "washtub",
      "wasp",
      "wasting",
      "watch",
      "water",
      "waviness",
      "waving",
      "wavy",
      "whacking",
      "whacky",
      "wham",
      "wharf",
      "wheat",
      "whenever",
      "whiff",
      "whimsical",
      "whinny",
      "whiny",
      "whisking",
      "whoever",
      "whole",
      "whomever",
      "whoopee",
      "whooping",
      "whoops",
      "why",
      "wick",
      "widely",
      "widen",
      "widget",
      "widow",
      "width",
      "wieldable",
      "wielder",
      "wife",
      "wifi",
      "wikipedia",
      "wildcard",
      "wildcat",
      "wilder",
      "wildfire",
      "wildfowl",
      "wildland",
      "wildlife",
      "wildly",
      "wildness",
      "willed",
      "willfully",
      "willing",
      "willow",
      "willpower",
      "wilt",
      "wimp",
      "wince",
      "wincing",
      "wind",
      "wing",
      "winking",
      "winner",
      "winnings",
      "winter",
      "wipe",
      "wired",
      "wireless",
      "wiring",
      "wiry",
      "wisdom",
      "wise",
      "wish",
      "wisplike",
      "wispy",
      "wistful",
      "wizard",
      "wobble",
      "wobbling",
      "wobbly",
      "wok",
      "wolf",
      "wolverine",
      "womanhood",
      "womankind",
      "womanless",
      "womanlike",
      "womanly",
      "womb",
      "woof",
      "wooing",
      "wool",
      "woozy",
      "word",
      "work",
      "worried",
      "worrier",
      "worrisome",
      "worry",
      "worsening",
      "worshiper",
      "worst",
      "wound",
      "woven",
      "wow",
      "wrangle",
      "wrath",
      "wreath",
      "wreckage",
      "wrecker",
      "wrecking",
      "wrench",
      "wriggle",
      "wriggly",
      "wrinkle",
      "wrinkly",
      "wrist",
      "writing",
      "written",
      "wrongdoer",
      "wronged",
      "wrongful",
      "wrongly",
      "wrongness",
      "wrought",
      "xbox",
      "xerox",
      "yahoo",
      "yam",
      "yanking",
      "yapping",
      "yard",
      "yarn",
      "yeah",
      "yearbook",
      "yearling",
      "yearly",
      "yearning",
      "yeast",
      "yelling",
      "yelp",
      "yen",
      "yesterday",
      "yiddish",
      "yield",
      "yin",
      "yippee",
      "yo-yo",
      "yodel",
      "yoga",
      "yogurt",
      "yonder",
      "yoyo",
      "yummy",
      "zap",
      "zealous",
      "zebra",
      "zen",
      "zeppelin",
      "zero",
      "zestfully",
      "zesty",
      "zigzagged",
      "zipfile",
      "zipping",
      "zippy",
      "zips",
      "zit",
      "zodiac",
      "zombie",
      "zone",
      "zoning",
      "zookeeper",
      "zoologist",
      "zoology",
      "zoom"
    ];
  }
});

// node_modules/ton-crypto/dist/passwords/newSecureWords.js
var require_newSecureWords = __commonJS({
  "node_modules/ton-crypto/dist/passwords/newSecureWords.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.newSecureWords = void 0;
    var getSecureRandom_1 = require_getSecureRandom2();
    var wordlist_1 = require_wordlist();
    async function newSecureWords(size4 = 6) {
      let words = [];
      for (let i = 0; i < size4; i++) {
        words.push(wordlist_1.wordlist[await (0, getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length)]);
      }
      return words;
    }
    exports.newSecureWords = newSecureWords;
  }
});

// node_modules/ton-crypto/dist/passwords/newSecurePassphrase.js
var require_newSecurePassphrase = __commonJS({
  "node_modules/ton-crypto/dist/passwords/newSecurePassphrase.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.newSecurePassphrase = void 0;
    var __1 = require_dist();
    async function newSecurePassphrase(size4 = 6) {
      return (await (0, __1.newSecureWords)(size4)).join("-");
    }
    exports.newSecurePassphrase = newSecurePassphrase;
  }
});

// node_modules/ton-crypto/dist/utils/binary.js
var require_binary = __commonJS({
  "node_modules/ton-crypto/dist/utils/binary.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bitsToBytes = exports.bytesToBits = exports.lpad = void 0;
    function lpad(str, padString, length) {
      while (str.length < length) {
        str = padString + str;
      }
      return str;
    }
    exports.lpad = lpad;
    function bytesToBits(bytes) {
      let res = "";
      for (let i = 0; i < bytes.length; i++) {
        let x = bytes.at(i);
        res += lpad(x.toString(2), "0", 8);
      }
      return res;
    }
    exports.bytesToBits = bytesToBits;
    function bitsToBytes(src) {
      if (src.length % 8 !== 0) {
        throw Error("Uneven bits");
      }
      let res = [];
      while (src.length > 0) {
        res.push(parseInt(src.slice(0, 8), 2));
        src = src.slice(8);
      }
      return import_buffer.Buffer.from(res);
    }
    exports.bitsToBytes = bitsToBytes;
  }
});

// node_modules/ton-crypto/dist/mnemonic/wordlist.js
var require_wordlist2 = __commonJS({
  "node_modules/ton-crypto/dist/mnemonic/wordlist.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wordlist = void 0;
    var EN = [
      "abandon",
      "ability",
      "able",
      "about",
      "above",
      "absent",
      "absorb",
      "abstract",
      "absurd",
      "abuse",
      "access",
      "accident",
      "account",
      "accuse",
      "achieve",
      "acid",
      "acoustic",
      "acquire",
      "across",
      "act",
      "action",
      "actor",
      "actress",
      "actual",
      "adapt",
      "add",
      "addict",
      "address",
      "adjust",
      "admit",
      "adult",
      "advance",
      "advice",
      "aerobic",
      "affair",
      "afford",
      "afraid",
      "again",
      "age",
      "agent",
      "agree",
      "ahead",
      "aim",
      "air",
      "airport",
      "aisle",
      "alarm",
      "album",
      "alcohol",
      "alert",
      "alien",
      "all",
      "alley",
      "allow",
      "almost",
      "alone",
      "alpha",
      "already",
      "also",
      "alter",
      "always",
      "amateur",
      "amazing",
      "among",
      "amount",
      "amused",
      "analyst",
      "anchor",
      "ancient",
      "anger",
      "angle",
      "angry",
      "animal",
      "ankle",
      "announce",
      "annual",
      "another",
      "answer",
      "antenna",
      "antique",
      "anxiety",
      "any",
      "apart",
      "apology",
      "appear",
      "apple",
      "approve",
      "april",
      "arch",
      "arctic",
      "area",
      "arena",
      "argue",
      "arm",
      "armed",
      "armor",
      "army",
      "around",
      "arrange",
      "arrest",
      "arrive",
      "arrow",
      "art",
      "artefact",
      "artist",
      "artwork",
      "ask",
      "aspect",
      "assault",
      "asset",
      "assist",
      "assume",
      "asthma",
      "athlete",
      "atom",
      "attack",
      "attend",
      "attitude",
      "attract",
      "auction",
      "audit",
      "august",
      "aunt",
      "author",
      "auto",
      "autumn",
      "average",
      "avocado",
      "avoid",
      "awake",
      "aware",
      "away",
      "awesome",
      "awful",
      "awkward",
      "axis",
      "baby",
      "bachelor",
      "bacon",
      "badge",
      "bag",
      "balance",
      "balcony",
      "ball",
      "bamboo",
      "banana",
      "banner",
      "bar",
      "barely",
      "bargain",
      "barrel",
      "base",
      "basic",
      "basket",
      "battle",
      "beach",
      "bean",
      "beauty",
      "because",
      "become",
      "beef",
      "before",
      "begin",
      "behave",
      "behind",
      "believe",
      "below",
      "belt",
      "bench",
      "benefit",
      "best",
      "betray",
      "better",
      "between",
      "beyond",
      "bicycle",
      "bid",
      "bike",
      "bind",
      "biology",
      "bird",
      "birth",
      "bitter",
      "black",
      "blade",
      "blame",
      "blanket",
      "blast",
      "bleak",
      "bless",
      "blind",
      "blood",
      "blossom",
      "blouse",
      "blue",
      "blur",
      "blush",
      "board",
      "boat",
      "body",
      "boil",
      "bomb",
      "bone",
      "bonus",
      "book",
      "boost",
      "border",
      "boring",
      "borrow",
      "boss",
      "bottom",
      "bounce",
      "box",
      "boy",
      "bracket",
      "brain",
      "brand",
      "brass",
      "brave",
      "bread",
      "breeze",
      "brick",
      "bridge",
      "brief",
      "bright",
      "bring",
      "brisk",
      "broccoli",
      "broken",
      "bronze",
      "broom",
      "brother",
      "brown",
      "brush",
      "bubble",
      "buddy",
      "budget",
      "buffalo",
      "build",
      "bulb",
      "bulk",
      "bullet",
      "bundle",
      "bunker",
      "burden",
      "burger",
      "burst",
      "bus",
      "business",
      "busy",
      "butter",
      "buyer",
      "buzz",
      "cabbage",
      "cabin",
      "cable",
      "cactus",
      "cage",
      "cake",
      "call",
      "calm",
      "camera",
      "camp",
      "can",
      "canal",
      "cancel",
      "candy",
      "cannon",
      "canoe",
      "canvas",
      "canyon",
      "capable",
      "capital",
      "captain",
      "car",
      "carbon",
      "card",
      "cargo",
      "carpet",
      "carry",
      "cart",
      "case",
      "cash",
      "casino",
      "castle",
      "casual",
      "cat",
      "catalog",
      "catch",
      "category",
      "cattle",
      "caught",
      "cause",
      "caution",
      "cave",
      "ceiling",
      "celery",
      "cement",
      "census",
      "century",
      "cereal",
      "certain",
      "chair",
      "chalk",
      "champion",
      "change",
      "chaos",
      "chapter",
      "charge",
      "chase",
      "chat",
      "cheap",
      "check",
      "cheese",
      "chef",
      "cherry",
      "chest",
      "chicken",
      "chief",
      "child",
      "chimney",
      "choice",
      "choose",
      "chronic",
      "chuckle",
      "chunk",
      "churn",
      "cigar",
      "cinnamon",
      "circle",
      "citizen",
      "city",
      "civil",
      "claim",
      "clap",
      "clarify",
      "claw",
      "clay",
      "clean",
      "clerk",
      "clever",
      "click",
      "client",
      "cliff",
      "climb",
      "clinic",
      "clip",
      "clock",
      "clog",
      "close",
      "cloth",
      "cloud",
      "clown",
      "club",
      "clump",
      "cluster",
      "clutch",
      "coach",
      "coast",
      "coconut",
      "code",
      "coffee",
      "coil",
      "coin",
      "collect",
      "color",
      "column",
      "combine",
      "come",
      "comfort",
      "comic",
      "common",
      "company",
      "concert",
      "conduct",
      "confirm",
      "congress",
      "connect",
      "consider",
      "control",
      "convince",
      "cook",
      "cool",
      "copper",
      "copy",
      "coral",
      "core",
      "corn",
      "correct",
      "cost",
      "cotton",
      "couch",
      "country",
      "couple",
      "course",
      "cousin",
      "cover",
      "coyote",
      "crack",
      "cradle",
      "craft",
      "cram",
      "crane",
      "crash",
      "crater",
      "crawl",
      "crazy",
      "cream",
      "credit",
      "creek",
      "crew",
      "cricket",
      "crime",
      "crisp",
      "critic",
      "crop",
      "cross",
      "crouch",
      "crowd",
      "crucial",
      "cruel",
      "cruise",
      "crumble",
      "crunch",
      "crush",
      "cry",
      "crystal",
      "cube",
      "culture",
      "cup",
      "cupboard",
      "curious",
      "current",
      "curtain",
      "curve",
      "cushion",
      "custom",
      "cute",
      "cycle",
      "dad",
      "damage",
      "damp",
      "dance",
      "danger",
      "daring",
      "dash",
      "daughter",
      "dawn",
      "day",
      "deal",
      "debate",
      "debris",
      "decade",
      "december",
      "decide",
      "decline",
      "decorate",
      "decrease",
      "deer",
      "defense",
      "define",
      "defy",
      "degree",
      "delay",
      "deliver",
      "demand",
      "demise",
      "denial",
      "dentist",
      "deny",
      "depart",
      "depend",
      "deposit",
      "depth",
      "deputy",
      "derive",
      "describe",
      "desert",
      "design",
      "desk",
      "despair",
      "destroy",
      "detail",
      "detect",
      "develop",
      "device",
      "devote",
      "diagram",
      "dial",
      "diamond",
      "diary",
      "dice",
      "diesel",
      "diet",
      "differ",
      "digital",
      "dignity",
      "dilemma",
      "dinner",
      "dinosaur",
      "direct",
      "dirt",
      "disagree",
      "discover",
      "disease",
      "dish",
      "dismiss",
      "disorder",
      "display",
      "distance",
      "divert",
      "divide",
      "divorce",
      "dizzy",
      "doctor",
      "document",
      "dog",
      "doll",
      "dolphin",
      "domain",
      "donate",
      "donkey",
      "donor",
      "door",
      "dose",
      "double",
      "dove",
      "draft",
      "dragon",
      "drama",
      "drastic",
      "draw",
      "dream",
      "dress",
      "drift",
      "drill",
      "drink",
      "drip",
      "drive",
      "drop",
      "drum",
      "dry",
      "duck",
      "dumb",
      "dune",
      "during",
      "dust",
      "dutch",
      "duty",
      "dwarf",
      "dynamic",
      "eager",
      "eagle",
      "early",
      "earn",
      "earth",
      "easily",
      "east",
      "easy",
      "echo",
      "ecology",
      "economy",
      "edge",
      "edit",
      "educate",
      "effort",
      "egg",
      "eight",
      "either",
      "elbow",
      "elder",
      "electric",
      "elegant",
      "element",
      "elephant",
      "elevator",
      "elite",
      "else",
      "embark",
      "embody",
      "embrace",
      "emerge",
      "emotion",
      "employ",
      "empower",
      "empty",
      "enable",
      "enact",
      "end",
      "endless",
      "endorse",
      "enemy",
      "energy",
      "enforce",
      "engage",
      "engine",
      "enhance",
      "enjoy",
      "enlist",
      "enough",
      "enrich",
      "enroll",
      "ensure",
      "enter",
      "entire",
      "entry",
      "envelope",
      "episode",
      "equal",
      "equip",
      "era",
      "erase",
      "erode",
      "erosion",
      "error",
      "erupt",
      "escape",
      "essay",
      "essence",
      "estate",
      "eternal",
      "ethics",
      "evidence",
      "evil",
      "evoke",
      "evolve",
      "exact",
      "example",
      "excess",
      "exchange",
      "excite",
      "exclude",
      "excuse",
      "execute",
      "exercise",
      "exhaust",
      "exhibit",
      "exile",
      "exist",
      "exit",
      "exotic",
      "expand",
      "expect",
      "expire",
      "explain",
      "expose",
      "express",
      "extend",
      "extra",
      "eye",
      "eyebrow",
      "fabric",
      "face",
      "faculty",
      "fade",
      "faint",
      "faith",
      "fall",
      "false",
      "fame",
      "family",
      "famous",
      "fan",
      "fancy",
      "fantasy",
      "farm",
      "fashion",
      "fat",
      "fatal",
      "father",
      "fatigue",
      "fault",
      "favorite",
      "feature",
      "february",
      "federal",
      "fee",
      "feed",
      "feel",
      "female",
      "fence",
      "festival",
      "fetch",
      "fever",
      "few",
      "fiber",
      "fiction",
      "field",
      "figure",
      "file",
      "film",
      "filter",
      "final",
      "find",
      "fine",
      "finger",
      "finish",
      "fire",
      "firm",
      "first",
      "fiscal",
      "fish",
      "fit",
      "fitness",
      "fix",
      "flag",
      "flame",
      "flash",
      "flat",
      "flavor",
      "flee",
      "flight",
      "flip",
      "float",
      "flock",
      "floor",
      "flower",
      "fluid",
      "flush",
      "fly",
      "foam",
      "focus",
      "fog",
      "foil",
      "fold",
      "follow",
      "food",
      "foot",
      "force",
      "forest",
      "forget",
      "fork",
      "fortune",
      "forum",
      "forward",
      "fossil",
      "foster",
      "found",
      "fox",
      "fragile",
      "frame",
      "frequent",
      "fresh",
      "friend",
      "fringe",
      "frog",
      "front",
      "frost",
      "frown",
      "frozen",
      "fruit",
      "fuel",
      "fun",
      "funny",
      "furnace",
      "fury",
      "future",
      "gadget",
      "gain",
      "galaxy",
      "gallery",
      "game",
      "gap",
      "garage",
      "garbage",
      "garden",
      "garlic",
      "garment",
      "gas",
      "gasp",
      "gate",
      "gather",
      "gauge",
      "gaze",
      "general",
      "genius",
      "genre",
      "gentle",
      "genuine",
      "gesture",
      "ghost",
      "giant",
      "gift",
      "giggle",
      "ginger",
      "giraffe",
      "girl",
      "give",
      "glad",
      "glance",
      "glare",
      "glass",
      "glide",
      "glimpse",
      "globe",
      "gloom",
      "glory",
      "glove",
      "glow",
      "glue",
      "goat",
      "goddess",
      "gold",
      "good",
      "goose",
      "gorilla",
      "gospel",
      "gossip",
      "govern",
      "gown",
      "grab",
      "grace",
      "grain",
      "grant",
      "grape",
      "grass",
      "gravity",
      "great",
      "green",
      "grid",
      "grief",
      "grit",
      "grocery",
      "group",
      "grow",
      "grunt",
      "guard",
      "guess",
      "guide",
      "guilt",
      "guitar",
      "gun",
      "gym",
      "habit",
      "hair",
      "half",
      "hammer",
      "hamster",
      "hand",
      "happy",
      "harbor",
      "hard",
      "harsh",
      "harvest",
      "hat",
      "have",
      "hawk",
      "hazard",
      "head",
      "health",
      "heart",
      "heavy",
      "hedgehog",
      "height",
      "hello",
      "helmet",
      "help",
      "hen",
      "hero",
      "hidden",
      "high",
      "hill",
      "hint",
      "hip",
      "hire",
      "history",
      "hobby",
      "hockey",
      "hold",
      "hole",
      "holiday",
      "hollow",
      "home",
      "honey",
      "hood",
      "hope",
      "horn",
      "horror",
      "horse",
      "hospital",
      "host",
      "hotel",
      "hour",
      "hover",
      "hub",
      "huge",
      "human",
      "humble",
      "humor",
      "hundred",
      "hungry",
      "hunt",
      "hurdle",
      "hurry",
      "hurt",
      "husband",
      "hybrid",
      "ice",
      "icon",
      "idea",
      "identify",
      "idle",
      "ignore",
      "ill",
      "illegal",
      "illness",
      "image",
      "imitate",
      "immense",
      "immune",
      "impact",
      "impose",
      "improve",
      "impulse",
      "inch",
      "include",
      "income",
      "increase",
      "index",
      "indicate",
      "indoor",
      "industry",
      "infant",
      "inflict",
      "inform",
      "inhale",
      "inherit",
      "initial",
      "inject",
      "injury",
      "inmate",
      "inner",
      "innocent",
      "input",
      "inquiry",
      "insane",
      "insect",
      "inside",
      "inspire",
      "install",
      "intact",
      "interest",
      "into",
      "invest",
      "invite",
      "involve",
      "iron",
      "island",
      "isolate",
      "issue",
      "item",
      "ivory",
      "jacket",
      "jaguar",
      "jar",
      "jazz",
      "jealous",
      "jeans",
      "jelly",
      "jewel",
      "job",
      "join",
      "joke",
      "journey",
      "joy",
      "judge",
      "juice",
      "jump",
      "jungle",
      "junior",
      "junk",
      "just",
      "kangaroo",
      "keen",
      "keep",
      "ketchup",
      "key",
      "kick",
      "kid",
      "kidney",
      "kind",
      "kingdom",
      "kiss",
      "kit",
      "kitchen",
      "kite",
      "kitten",
      "kiwi",
      "knee",
      "knife",
      "knock",
      "know",
      "lab",
      "label",
      "labor",
      "ladder",
      "lady",
      "lake",
      "lamp",
      "language",
      "laptop",
      "large",
      "later",
      "latin",
      "laugh",
      "laundry",
      "lava",
      "law",
      "lawn",
      "lawsuit",
      "layer",
      "lazy",
      "leader",
      "leaf",
      "learn",
      "leave",
      "lecture",
      "left",
      "leg",
      "legal",
      "legend",
      "leisure",
      "lemon",
      "lend",
      "length",
      "lens",
      "leopard",
      "lesson",
      "letter",
      "level",
      "liar",
      "liberty",
      "library",
      "license",
      "life",
      "lift",
      "light",
      "like",
      "limb",
      "limit",
      "link",
      "lion",
      "liquid",
      "list",
      "little",
      "live",
      "lizard",
      "load",
      "loan",
      "lobster",
      "local",
      "lock",
      "logic",
      "lonely",
      "long",
      "loop",
      "lottery",
      "loud",
      "lounge",
      "love",
      "loyal",
      "lucky",
      "luggage",
      "lumber",
      "lunar",
      "lunch",
      "luxury",
      "lyrics",
      "machine",
      "mad",
      "magic",
      "magnet",
      "maid",
      "mail",
      "main",
      "major",
      "make",
      "mammal",
      "man",
      "manage",
      "mandate",
      "mango",
      "mansion",
      "manual",
      "maple",
      "marble",
      "march",
      "margin",
      "marine",
      "market",
      "marriage",
      "mask",
      "mass",
      "master",
      "match",
      "material",
      "math",
      "matrix",
      "matter",
      "maximum",
      "maze",
      "meadow",
      "mean",
      "measure",
      "meat",
      "mechanic",
      "medal",
      "media",
      "melody",
      "melt",
      "member",
      "memory",
      "mention",
      "menu",
      "mercy",
      "merge",
      "merit",
      "merry",
      "mesh",
      "message",
      "metal",
      "method",
      "middle",
      "midnight",
      "milk",
      "million",
      "mimic",
      "mind",
      "minimum",
      "minor",
      "minute",
      "miracle",
      "mirror",
      "misery",
      "miss",
      "mistake",
      "mix",
      "mixed",
      "mixture",
      "mobile",
      "model",
      "modify",
      "mom",
      "moment",
      "monitor",
      "monkey",
      "monster",
      "month",
      "moon",
      "moral",
      "more",
      "morning",
      "mosquito",
      "mother",
      "motion",
      "motor",
      "mountain",
      "mouse",
      "move",
      "movie",
      "much",
      "muffin",
      "mule",
      "multiply",
      "muscle",
      "museum",
      "mushroom",
      "music",
      "must",
      "mutual",
      "myself",
      "mystery",
      "myth",
      "naive",
      "name",
      "napkin",
      "narrow",
      "nasty",
      "nation",
      "nature",
      "near",
      "neck",
      "need",
      "negative",
      "neglect",
      "neither",
      "nephew",
      "nerve",
      "nest",
      "net",
      "network",
      "neutral",
      "never",
      "news",
      "next",
      "nice",
      "night",
      "noble",
      "noise",
      "nominee",
      "noodle",
      "normal",
      "north",
      "nose",
      "notable",
      "note",
      "nothing",
      "notice",
      "novel",
      "now",
      "nuclear",
      "number",
      "nurse",
      "nut",
      "oak",
      "obey",
      "object",
      "oblige",
      "obscure",
      "observe",
      "obtain",
      "obvious",
      "occur",
      "ocean",
      "october",
      "odor",
      "off",
      "offer",
      "office",
      "often",
      "oil",
      "okay",
      "old",
      "olive",
      "olympic",
      "omit",
      "once",
      "one",
      "onion",
      "online",
      "only",
      "open",
      "opera",
      "opinion",
      "oppose",
      "option",
      "orange",
      "orbit",
      "orchard",
      "order",
      "ordinary",
      "organ",
      "orient",
      "original",
      "orphan",
      "ostrich",
      "other",
      "outdoor",
      "outer",
      "output",
      "outside",
      "oval",
      "oven",
      "over",
      "own",
      "owner",
      "oxygen",
      "oyster",
      "ozone",
      "pact",
      "paddle",
      "page",
      "pair",
      "palace",
      "palm",
      "panda",
      "panel",
      "panic",
      "panther",
      "paper",
      "parade",
      "parent",
      "park",
      "parrot",
      "party",
      "pass",
      "patch",
      "path",
      "patient",
      "patrol",
      "pattern",
      "pause",
      "pave",
      "payment",
      "peace",
      "peanut",
      "pear",
      "peasant",
      "pelican",
      "pen",
      "penalty",
      "pencil",
      "people",
      "pepper",
      "perfect",
      "permit",
      "person",
      "pet",
      "phone",
      "photo",
      "phrase",
      "physical",
      "piano",
      "picnic",
      "picture",
      "piece",
      "pig",
      "pigeon",
      "pill",
      "pilot",
      "pink",
      "pioneer",
      "pipe",
      "pistol",
      "pitch",
      "pizza",
      "place",
      "planet",
      "plastic",
      "plate",
      "play",
      "please",
      "pledge",
      "pluck",
      "plug",
      "plunge",
      "poem",
      "poet",
      "point",
      "polar",
      "pole",
      "police",
      "pond",
      "pony",
      "pool",
      "popular",
      "portion",
      "position",
      "possible",
      "post",
      "potato",
      "pottery",
      "poverty",
      "powder",
      "power",
      "practice",
      "praise",
      "predict",
      "prefer",
      "prepare",
      "present",
      "pretty",
      "prevent",
      "price",
      "pride",
      "primary",
      "print",
      "priority",
      "prison",
      "private",
      "prize",
      "problem",
      "process",
      "produce",
      "profit",
      "program",
      "project",
      "promote",
      "proof",
      "property",
      "prosper",
      "protect",
      "proud",
      "provide",
      "public",
      "pudding",
      "pull",
      "pulp",
      "pulse",
      "pumpkin",
      "punch",
      "pupil",
      "puppy",
      "purchase",
      "purity",
      "purpose",
      "purse",
      "push",
      "put",
      "puzzle",
      "pyramid",
      "quality",
      "quantum",
      "quarter",
      "question",
      "quick",
      "quit",
      "quiz",
      "quote",
      "rabbit",
      "raccoon",
      "race",
      "rack",
      "radar",
      "radio",
      "rail",
      "rain",
      "raise",
      "rally",
      "ramp",
      "ranch",
      "random",
      "range",
      "rapid",
      "rare",
      "rate",
      "rather",
      "raven",
      "raw",
      "razor",
      "ready",
      "real",
      "reason",
      "rebel",
      "rebuild",
      "recall",
      "receive",
      "recipe",
      "record",
      "recycle",
      "reduce",
      "reflect",
      "reform",
      "refuse",
      "region",
      "regret",
      "regular",
      "reject",
      "relax",
      "release",
      "relief",
      "rely",
      "remain",
      "remember",
      "remind",
      "remove",
      "render",
      "renew",
      "rent",
      "reopen",
      "repair",
      "repeat",
      "replace",
      "report",
      "require",
      "rescue",
      "resemble",
      "resist",
      "resource",
      "response",
      "result",
      "retire",
      "retreat",
      "return",
      "reunion",
      "reveal",
      "review",
      "reward",
      "rhythm",
      "rib",
      "ribbon",
      "rice",
      "rich",
      "ride",
      "ridge",
      "rifle",
      "right",
      "rigid",
      "ring",
      "riot",
      "ripple",
      "risk",
      "ritual",
      "rival",
      "river",
      "road",
      "roast",
      "robot",
      "robust",
      "rocket",
      "romance",
      "roof",
      "rookie",
      "room",
      "rose",
      "rotate",
      "rough",
      "round",
      "route",
      "royal",
      "rubber",
      "rude",
      "rug",
      "rule",
      "run",
      "runway",
      "rural",
      "sad",
      "saddle",
      "sadness",
      "safe",
      "sail",
      "salad",
      "salmon",
      "salon",
      "salt",
      "salute",
      "same",
      "sample",
      "sand",
      "satisfy",
      "satoshi",
      "sauce",
      "sausage",
      "save",
      "say",
      "scale",
      "scan",
      "scare",
      "scatter",
      "scene",
      "scheme",
      "school",
      "science",
      "scissors",
      "scorpion",
      "scout",
      "scrap",
      "screen",
      "script",
      "scrub",
      "sea",
      "search",
      "season",
      "seat",
      "second",
      "secret",
      "section",
      "security",
      "seed",
      "seek",
      "segment",
      "select",
      "sell",
      "seminar",
      "senior",
      "sense",
      "sentence",
      "series",
      "service",
      "session",
      "settle",
      "setup",
      "seven",
      "shadow",
      "shaft",
      "shallow",
      "share",
      "shed",
      "shell",
      "sheriff",
      "shield",
      "shift",
      "shine",
      "ship",
      "shiver",
      "shock",
      "shoe",
      "shoot",
      "shop",
      "short",
      "shoulder",
      "shove",
      "shrimp",
      "shrug",
      "shuffle",
      "shy",
      "sibling",
      "sick",
      "side",
      "siege",
      "sight",
      "sign",
      "silent",
      "silk",
      "silly",
      "silver",
      "similar",
      "simple",
      "since",
      "sing",
      "siren",
      "sister",
      "situate",
      "six",
      "size",
      "skate",
      "sketch",
      "ski",
      "skill",
      "skin",
      "skirt",
      "skull",
      "slab",
      "slam",
      "sleep",
      "slender",
      "slice",
      "slide",
      "slight",
      "slim",
      "slogan",
      "slot",
      "slow",
      "slush",
      "small",
      "smart",
      "smile",
      "smoke",
      "smooth",
      "snack",
      "snake",
      "snap",
      "sniff",
      "snow",
      "soap",
      "soccer",
      "social",
      "sock",
      "soda",
      "soft",
      "solar",
      "soldier",
      "solid",
      "solution",
      "solve",
      "someone",
      "song",
      "soon",
      "sorry",
      "sort",
      "soul",
      "sound",
      "soup",
      "source",
      "south",
      "space",
      "spare",
      "spatial",
      "spawn",
      "speak",
      "special",
      "speed",
      "spell",
      "spend",
      "sphere",
      "spice",
      "spider",
      "spike",
      "spin",
      "spirit",
      "split",
      "spoil",
      "sponsor",
      "spoon",
      "sport",
      "spot",
      "spray",
      "spread",
      "spring",
      "spy",
      "square",
      "squeeze",
      "squirrel",
      "stable",
      "stadium",
      "staff",
      "stage",
      "stairs",
      "stamp",
      "stand",
      "start",
      "state",
      "stay",
      "steak",
      "steel",
      "stem",
      "step",
      "stereo",
      "stick",
      "still",
      "sting",
      "stock",
      "stomach",
      "stone",
      "stool",
      "story",
      "stove",
      "strategy",
      "street",
      "strike",
      "strong",
      "struggle",
      "student",
      "stuff",
      "stumble",
      "style",
      "subject",
      "submit",
      "subway",
      "success",
      "such",
      "sudden",
      "suffer",
      "sugar",
      "suggest",
      "suit",
      "summer",
      "sun",
      "sunny",
      "sunset",
      "super",
      "supply",
      "supreme",
      "sure",
      "surface",
      "surge",
      "surprise",
      "surround",
      "survey",
      "suspect",
      "sustain",
      "swallow",
      "swamp",
      "swap",
      "swarm",
      "swear",
      "sweet",
      "swift",
      "swim",
      "swing",
      "switch",
      "sword",
      "symbol",
      "symptom",
      "syrup",
      "system",
      "table",
      "tackle",
      "tag",
      "tail",
      "talent",
      "talk",
      "tank",
      "tape",
      "target",
      "task",
      "taste",
      "tattoo",
      "taxi",
      "teach",
      "team",
      "tell",
      "ten",
      "tenant",
      "tennis",
      "tent",
      "term",
      "test",
      "text",
      "thank",
      "that",
      "theme",
      "then",
      "theory",
      "there",
      "they",
      "thing",
      "this",
      "thought",
      "three",
      "thrive",
      "throw",
      "thumb",
      "thunder",
      "ticket",
      "tide",
      "tiger",
      "tilt",
      "timber",
      "time",
      "tiny",
      "tip",
      "tired",
      "tissue",
      "title",
      "toast",
      "tobacco",
      "today",
      "toddler",
      "toe",
      "together",
      "toilet",
      "token",
      "tomato",
      "tomorrow",
      "tone",
      "tongue",
      "tonight",
      "tool",
      "tooth",
      "top",
      "topic",
      "topple",
      "torch",
      "tornado",
      "tortoise",
      "toss",
      "total",
      "tourist",
      "toward",
      "tower",
      "town",
      "toy",
      "track",
      "trade",
      "traffic",
      "tragic",
      "train",
      "transfer",
      "trap",
      "trash",
      "travel",
      "tray",
      "treat",
      "tree",
      "trend",
      "trial",
      "tribe",
      "trick",
      "trigger",
      "trim",
      "trip",
      "trophy",
      "trouble",
      "truck",
      "true",
      "truly",
      "trumpet",
      "trust",
      "truth",
      "try",
      "tube",
      "tuition",
      "tumble",
      "tuna",
      "tunnel",
      "turkey",
      "turn",
      "turtle",
      "twelve",
      "twenty",
      "twice",
      "twin",
      "twist",
      "two",
      "type",
      "typical",
      "ugly",
      "umbrella",
      "unable",
      "unaware",
      "uncle",
      "uncover",
      "under",
      "undo",
      "unfair",
      "unfold",
      "unhappy",
      "uniform",
      "unique",
      "unit",
      "universe",
      "unknown",
      "unlock",
      "until",
      "unusual",
      "unveil",
      "update",
      "upgrade",
      "uphold",
      "upon",
      "upper",
      "upset",
      "urban",
      "urge",
      "usage",
      "use",
      "used",
      "useful",
      "useless",
      "usual",
      "utility",
      "vacant",
      "vacuum",
      "vague",
      "valid",
      "valley",
      "valve",
      "van",
      "vanish",
      "vapor",
      "various",
      "vast",
      "vault",
      "vehicle",
      "velvet",
      "vendor",
      "venture",
      "venue",
      "verb",
      "verify",
      "version",
      "very",
      "vessel",
      "veteran",
      "viable",
      "vibrant",
      "vicious",
      "victory",
      "video",
      "view",
      "village",
      "vintage",
      "violin",
      "virtual",
      "virus",
      "visa",
      "visit",
      "visual",
      "vital",
      "vivid",
      "vocal",
      "voice",
      "void",
      "volcano",
      "volume",
      "vote",
      "voyage",
      "wage",
      "wagon",
      "wait",
      "walk",
      "wall",
      "walnut",
      "want",
      "warfare",
      "warm",
      "warrior",
      "wash",
      "wasp",
      "waste",
      "water",
      "wave",
      "way",
      "wealth",
      "weapon",
      "wear",
      "weasel",
      "weather",
      "web",
      "wedding",
      "weekend",
      "weird",
      "welcome",
      "west",
      "wet",
      "whale",
      "what",
      "wheat",
      "wheel",
      "when",
      "where",
      "whip",
      "whisper",
      "wide",
      "width",
      "wife",
      "wild",
      "will",
      "win",
      "window",
      "wine",
      "wing",
      "wink",
      "winner",
      "winter",
      "wire",
      "wisdom",
      "wise",
      "wish",
      "witness",
      "wolf",
      "woman",
      "wonder",
      "wood",
      "wool",
      "word",
      "work",
      "world",
      "worry",
      "worth",
      "wrap",
      "wreck",
      "wrestle",
      "wrist",
      "write",
      "wrong",
      "yard",
      "year",
      "yellow",
      "you",
      "young",
      "youth",
      "zebra",
      "zero",
      "zone",
      "zoo"
    ];
    exports.wordlist = EN;
  }
});

// node_modules/ton-crypto/dist/mnemonic/mnemonic.js
var require_mnemonic = __commonJS({
  "node_modules/ton-crypto/dist/mnemonic/mnemonic.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mnemonicFromRandomSeed = exports.mnemonicIndexesToBytes = exports.bytesToMnemonics = exports.bytesToMnemonicIndexes = exports.mnemonicNew = exports.mnemonicValidate = exports.mnemonicToHDSeed = exports.mnemonicToWalletKey = exports.mnemonicToPrivateKey = exports.mnemonicToSeed = exports.mnemonicToEntropy = void 0;
    var tweetnacl_1 = __importDefault(require_nacl_fast());
    var getSecureRandom_1 = require_getSecureRandom2();
    var hmac_sha512_1 = require_hmac_sha5122();
    var pbkdf2_sha512_1 = require_pbkdf2_sha5122();
    var binary_1 = require_binary();
    var wordlist_1 = require_wordlist2();
    var PBKDF_ITERATIONS = 1e5;
    async function isPasswordNeeded(mnemonicArray) {
      const passlessEntropy = await mnemonicToEntropy(mnemonicArray);
      return await isPasswordSeed(passlessEntropy) && !await isBasicSeed(passlessEntropy);
    }
    function normalizeMnemonic(src) {
      return src.map((v) => v.toLowerCase().trim());
    }
    async function isBasicSeed(entropy) {
      const seed = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, "TON seed version", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), 64);
      return seed[0] == 0;
    }
    async function isPasswordSeed(entropy) {
      const seed = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, "TON fast seed version", 1, 64);
      return seed[0] == 1;
    }
    async function mnemonicToEntropy(mnemonicArray, password) {
      return await (0, hmac_sha512_1.hmac_sha512)(mnemonicArray.join(" "), password && password.length > 0 ? password : "");
    }
    exports.mnemonicToEntropy = mnemonicToEntropy;
    async function mnemonicToSeed(mnemonicArray, seed, password) {
      const entropy = await mnemonicToEntropy(mnemonicArray, password);
      return await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, seed, PBKDF_ITERATIONS, 64);
    }
    exports.mnemonicToSeed = mnemonicToSeed;
    async function mnemonicToPrivateKey(mnemonicArray, password) {
      mnemonicArray = normalizeMnemonic(mnemonicArray);
      const seed = await mnemonicToSeed(mnemonicArray, "TON default seed", password);
      let keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seed.slice(0, 32));
      return {
        publicKey: import_buffer.Buffer.from(keyPair.publicKey),
        secretKey: import_buffer.Buffer.from(keyPair.secretKey)
      };
    }
    exports.mnemonicToPrivateKey = mnemonicToPrivateKey;
    async function mnemonicToWalletKey(mnemonicArray, password) {
      let seedPk = await mnemonicToPrivateKey(mnemonicArray, password);
      let seedSecret = seedPk.secretKey.slice(0, 32);
      const keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seedSecret);
      return {
        publicKey: import_buffer.Buffer.from(keyPair.publicKey),
        secretKey: import_buffer.Buffer.from(keyPair.secretKey)
      };
    }
    exports.mnemonicToWalletKey = mnemonicToWalletKey;
    async function mnemonicToHDSeed(mnemonicArray, password) {
      mnemonicArray = normalizeMnemonic(mnemonicArray);
      return await mnemonicToSeed(mnemonicArray, "TON HD Keys seed", password);
    }
    exports.mnemonicToHDSeed = mnemonicToHDSeed;
    async function mnemonicValidate(mnemonicArray, password) {
      mnemonicArray = normalizeMnemonic(mnemonicArray);
      for (let word of mnemonicArray) {
        if (wordlist_1.wordlist.indexOf(word) < 0) {
          return false;
        }
      }
      if (password && password.length > 0) {
        if (!await isPasswordNeeded(mnemonicArray)) {
          return false;
        }
      }
      return await isBasicSeed(await mnemonicToEntropy(mnemonicArray, password));
    }
    exports.mnemonicValidate = mnemonicValidate;
    async function mnemonicNew(wordsCount = 24, password) {
      let mnemonicArray = [];
      while (true) {
        mnemonicArray = [];
        for (let i = 0; i < wordsCount; i++) {
          let ind = await (0, getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length);
          mnemonicArray.push(wordlist_1.wordlist[ind]);
        }
        if (password && password.length > 0) {
          if (!await isPasswordNeeded(mnemonicArray)) {
            continue;
          }
        }
        if (!await isBasicSeed(await mnemonicToEntropy(mnemonicArray, password))) {
          continue;
        }
        break;
      }
      return mnemonicArray;
    }
    exports.mnemonicNew = mnemonicNew;
    function bytesToMnemonicIndexes(src, wordsCount) {
      let bits = (0, binary_1.bytesToBits)(src);
      let indexes = [];
      for (let i = 0; i < wordsCount; i++) {
        let sl = bits.slice(i * 11, i * 11 + 11);
        indexes.push(parseInt(sl, 2));
      }
      return indexes;
    }
    exports.bytesToMnemonicIndexes = bytesToMnemonicIndexes;
    function bytesToMnemonics(src, wordsCount) {
      let mnemonics = bytesToMnemonicIndexes(src, wordsCount);
      let res = [];
      for (let m of mnemonics) {
        res.push(wordlist_1.wordlist[m]);
      }
      return res;
    }
    exports.bytesToMnemonics = bytesToMnemonics;
    function mnemonicIndexesToBytes(src) {
      let res = "";
      for (let s of src) {
        if (!Number.isSafeInteger(s)) {
          throw Error("Invalid input");
        }
        if (s < 0 || s >= 2028) {
          throw Error("Invalid input");
        }
        res += (0, binary_1.lpad)(s.toString(2), "0", 11);
      }
      while (res.length % 8 !== 0) {
        res = res + "0";
      }
      return (0, binary_1.bitsToBytes)(res);
    }
    exports.mnemonicIndexesToBytes = mnemonicIndexesToBytes;
    async function mnemonicFromRandomSeed(seed, wordsCount = 24, password) {
      const bytesLength = Math.ceil(wordsCount * 11 / 8);
      let currentSeed = seed;
      while (true) {
        let entropy = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(currentSeed, "TON mnemonic seed", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), bytesLength);
        let mnemonics = bytesToMnemonics(entropy, wordsCount);
        if (await mnemonicValidate(mnemonics, password)) {
          return mnemonics;
        }
        currentSeed = entropy;
      }
    }
    exports.mnemonicFromRandomSeed = mnemonicFromRandomSeed;
  }
});

// node_modules/ton-crypto/dist/primitives/nacl.js
var require_nacl = __commonJS({
  "node_modules/ton-crypto/dist/primitives/nacl.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.openBox = exports.sealBox = exports.signVerify = exports.sign = exports.keyPairFromSeed = exports.keyPairFromSecretKey = void 0;
    var tweetnacl_1 = __importDefault(require_nacl_fast());
    function keyPairFromSecretKey(secretKey) {
      let res = tweetnacl_1.default.sign.keyPair.fromSecretKey(new Uint8Array(secretKey));
      return {
        publicKey: import_buffer.Buffer.from(res.publicKey),
        secretKey: import_buffer.Buffer.from(res.secretKey)
      };
    }
    exports.keyPairFromSecretKey = keyPairFromSecretKey;
    function keyPairFromSeed(secretKey) {
      let res = tweetnacl_1.default.sign.keyPair.fromSeed(new Uint8Array(secretKey));
      return {
        publicKey: import_buffer.Buffer.from(res.publicKey),
        secretKey: import_buffer.Buffer.from(res.secretKey)
      };
    }
    exports.keyPairFromSeed = keyPairFromSeed;
    function sign(data, secretKey) {
      return import_buffer.Buffer.from(tweetnacl_1.default.sign.detached(new Uint8Array(data), new Uint8Array(secretKey)));
    }
    exports.sign = sign;
    function signVerify(data, signature, publicKey) {
      return tweetnacl_1.default.sign.detached.verify(new Uint8Array(data), new Uint8Array(signature), new Uint8Array(publicKey));
    }
    exports.signVerify = signVerify;
    function sealBox(data, nonce, key) {
      return import_buffer.Buffer.from(tweetnacl_1.default.secretbox(data, nonce, key));
    }
    exports.sealBox = sealBox;
    function openBox(data, nonce, key) {
      let res = tweetnacl_1.default.secretbox.open(data, nonce, key);
      if (!res) {
        return null;
      }
      return import_buffer.Buffer.from(res);
    }
    exports.openBox = openBox;
  }
});

// node_modules/ton-crypto/dist/hd/ed25519.js
var require_ed25519 = __commonJS({
  "node_modules/ton-crypto/dist/hd/ed25519.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deriveEd25519Path = exports.deriveED25519HardenedKey = exports.getED25519MasterKeyFromSeed = void 0;
    var hmac_sha512_1 = require_hmac_sha5122();
    var ED25519_CURVE = "ed25519 seed";
    var HARDENED_OFFSET = 2147483648;
    async function getED25519MasterKeyFromSeed(seed) {
      const I = await (0, hmac_sha512_1.hmac_sha512)(ED25519_CURVE, seed);
      const IL = I.slice(0, 32);
      const IR = I.slice(32);
      return {
        key: IL,
        chainCode: IR
      };
    }
    exports.getED25519MasterKeyFromSeed = getED25519MasterKeyFromSeed;
    async function deriveED25519HardenedKey(parent, index) {
      if (index >= HARDENED_OFFSET) {
        throw Error("Key index must be less than offset");
      }
      const indexBuffer = import_buffer.Buffer.alloc(4);
      indexBuffer.writeUInt32BE(index + HARDENED_OFFSET, 0);
      const data = import_buffer.Buffer.concat([import_buffer.Buffer.alloc(1, 0), parent.key, indexBuffer]);
      const I = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);
      const IL = I.slice(0, 32);
      const IR = I.slice(32);
      return {
        key: IL,
        chainCode: IR
      };
    }
    exports.deriveED25519HardenedKey = deriveED25519HardenedKey;
    async function deriveEd25519Path(seed, path) {
      let state = await getED25519MasterKeyFromSeed(seed);
      let remaining = [...path];
      while (remaining.length > 0) {
        let index = remaining[0];
        remaining = remaining.slice(1);
        state = await deriveED25519HardenedKey(state, index);
      }
      return state.key;
    }
    exports.deriveEd25519Path = deriveEd25519Path;
  }
});

// node_modules/ton-crypto/dist/hd/symmetric.js
var require_symmetric = __commonJS({
  "node_modules/ton-crypto/dist/hd/symmetric.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deriveSymmetricPath = exports.deriveSymmetricHardenedKey = exports.getSymmetricMasterKeyFromSeed = void 0;
    var hmac_sha512_1 = require_hmac_sha5122();
    var SYMMETRIC_SEED = "Symmetric key seed";
    async function getSymmetricMasterKeyFromSeed(seed) {
      const I = await (0, hmac_sha512_1.hmac_sha512)(SYMMETRIC_SEED, seed);
      const IL = I.slice(32);
      const IR = I.slice(0, 32);
      return {
        key: IL,
        chainCode: IR
      };
    }
    exports.getSymmetricMasterKeyFromSeed = getSymmetricMasterKeyFromSeed;
    async function deriveSymmetricHardenedKey(parent, offset) {
      const data = import_buffer.Buffer.concat([import_buffer.Buffer.alloc(1, 0), import_buffer.Buffer.from(offset)]);
      const I = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);
      const IL = I.slice(32);
      const IR = I.slice(0, 32);
      return {
        key: IL,
        chainCode: IR
      };
    }
    exports.deriveSymmetricHardenedKey = deriveSymmetricHardenedKey;
    async function deriveSymmetricPath(seed, path) {
      let state = await getSymmetricMasterKeyFromSeed(seed);
      let remaining = [...path];
      while (remaining.length > 0) {
        let index = remaining[0];
        remaining = remaining.slice(1);
        state = await deriveSymmetricHardenedKey(state, index);
      }
      return state.key;
    }
    exports.deriveSymmetricPath = deriveSymmetricPath;
  }
});

// node_modules/ton-crypto/dist/hd/mnemonics.js
var require_mnemonics = __commonJS({
  "node_modules/ton-crypto/dist/hd/mnemonics.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deriveMnemonicsPath = exports.deriveMnemonicHardenedKey = exports.getMnemonicsMasterKeyFromSeed = void 0;
    var mnemonic_1 = require_mnemonic();
    var hmac_sha512_1 = require_hmac_sha5122();
    var HARDENED_OFFSET = 2147483648;
    var MNEMONICS_SEED = "TON Mnemonics HD seed";
    async function getMnemonicsMasterKeyFromSeed(seed) {
      const I = await (0, hmac_sha512_1.hmac_sha512)(MNEMONICS_SEED, seed);
      const IL = I.slice(0, 32);
      const IR = I.slice(32);
      return {
        key: IL,
        chainCode: IR
      };
    }
    exports.getMnemonicsMasterKeyFromSeed = getMnemonicsMasterKeyFromSeed;
    async function deriveMnemonicHardenedKey(parent, index) {
      if (index >= HARDENED_OFFSET) {
        throw Error("Key index must be less than offset");
      }
      const indexBuffer = import_buffer.Buffer.alloc(4);
      indexBuffer.writeUInt32BE(index + HARDENED_OFFSET, 0);
      const data = import_buffer.Buffer.concat([import_buffer.Buffer.alloc(1, 0), parent.key, indexBuffer]);
      const I = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);
      const IL = I.slice(0, 32);
      const IR = I.slice(32);
      return {
        key: IL,
        chainCode: IR
      };
    }
    exports.deriveMnemonicHardenedKey = deriveMnemonicHardenedKey;
    async function deriveMnemonicsPath(seed, path, wordsCount = 24, password) {
      let state = await getMnemonicsMasterKeyFromSeed(seed);
      let remaining = [...path];
      while (remaining.length > 0) {
        let index = remaining[0];
        remaining = remaining.slice(1);
        state = await deriveMnemonicHardenedKey(state, index);
      }
      return await (0, mnemonic_1.mnemonicFromRandomSeed)(state.key, wordsCount, password);
    }
    exports.deriveMnemonicsPath = deriveMnemonicsPath;
  }
});

// node_modules/ton-crypto/dist/index.js
var require_dist = __commonJS({
  "node_modules/ton-crypto/dist/index.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMnemonicsMasterKeyFromSeed = exports.deriveMnemonicHardenedKey = exports.deriveMnemonicsPath = exports.deriveSymmetricPath = exports.deriveSymmetricHardenedKey = exports.getSymmetricMasterKeyFromSeed = exports.deriveEd25519Path = exports.deriveED25519HardenedKey = exports.getED25519MasterKeyFromSeed = exports.signVerify = exports.sign = exports.keyPairFromSecretKey = exports.keyPairFromSeed = exports.openBox = exports.sealBox = exports.mnemonicWordList = exports.mnemonicToHDSeed = exports.mnemonicToSeed = exports.mnemonicToWalletKey = exports.mnemonicToPrivateKey = exports.mnemonicValidate = exports.mnemonicNew = exports.newSecurePassphrase = exports.newSecureWords = exports.getSecureRandomNumber = exports.getSecureRandomWords = exports.getSecureRandomBytes = exports.hmac_sha512 = exports.pbkdf2_sha512 = exports.sha512_sync = exports.sha512 = exports.sha256_sync = exports.sha256 = void 0;
    var sha256_1 = require_sha2562();
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha256_1.sha256;
    } });
    Object.defineProperty(exports, "sha256_sync", { enumerable: true, get: function() {
      return sha256_1.sha256_sync;
    } });
    var sha512_1 = require_sha5122();
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha512_1.sha512;
    } });
    Object.defineProperty(exports, "sha512_sync", { enumerable: true, get: function() {
      return sha512_1.sha512_sync;
    } });
    var pbkdf2_sha512_1 = require_pbkdf2_sha5122();
    Object.defineProperty(exports, "pbkdf2_sha512", { enumerable: true, get: function() {
      return pbkdf2_sha512_1.pbkdf2_sha512;
    } });
    var hmac_sha512_1 = require_hmac_sha5122();
    Object.defineProperty(exports, "hmac_sha512", { enumerable: true, get: function() {
      return hmac_sha512_1.hmac_sha512;
    } });
    var getSecureRandom_1 = require_getSecureRandom2();
    Object.defineProperty(exports, "getSecureRandomBytes", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomBytes;
    } });
    Object.defineProperty(exports, "getSecureRandomWords", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomWords;
    } });
    Object.defineProperty(exports, "getSecureRandomNumber", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomNumber;
    } });
    var newSecureWords_1 = require_newSecureWords();
    Object.defineProperty(exports, "newSecureWords", { enumerable: true, get: function() {
      return newSecureWords_1.newSecureWords;
    } });
    var newSecurePassphrase_1 = require_newSecurePassphrase();
    Object.defineProperty(exports, "newSecurePassphrase", { enumerable: true, get: function() {
      return newSecurePassphrase_1.newSecurePassphrase;
    } });
    var mnemonic_1 = require_mnemonic();
    Object.defineProperty(exports, "mnemonicNew", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicNew;
    } });
    Object.defineProperty(exports, "mnemonicValidate", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicValidate;
    } });
    Object.defineProperty(exports, "mnemonicToPrivateKey", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToPrivateKey;
    } });
    Object.defineProperty(exports, "mnemonicToWalletKey", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToWalletKey;
    } });
    Object.defineProperty(exports, "mnemonicToSeed", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToSeed;
    } });
    Object.defineProperty(exports, "mnemonicToHDSeed", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToHDSeed;
    } });
    var wordlist_1 = require_wordlist2();
    Object.defineProperty(exports, "mnemonicWordList", { enumerable: true, get: function() {
      return wordlist_1.wordlist;
    } });
    var nacl_1 = require_nacl();
    Object.defineProperty(exports, "sealBox", { enumerable: true, get: function() {
      return nacl_1.sealBox;
    } });
    Object.defineProperty(exports, "openBox", { enumerable: true, get: function() {
      return nacl_1.openBox;
    } });
    var nacl_2 = require_nacl();
    Object.defineProperty(exports, "keyPairFromSeed", { enumerable: true, get: function() {
      return nacl_2.keyPairFromSeed;
    } });
    Object.defineProperty(exports, "keyPairFromSecretKey", { enumerable: true, get: function() {
      return nacl_2.keyPairFromSecretKey;
    } });
    Object.defineProperty(exports, "sign", { enumerable: true, get: function() {
      return nacl_2.sign;
    } });
    Object.defineProperty(exports, "signVerify", { enumerable: true, get: function() {
      return nacl_2.signVerify;
    } });
    var ed25519_1 = require_ed25519();
    Object.defineProperty(exports, "getED25519MasterKeyFromSeed", { enumerable: true, get: function() {
      return ed25519_1.getED25519MasterKeyFromSeed;
    } });
    Object.defineProperty(exports, "deriveED25519HardenedKey", { enumerable: true, get: function() {
      return ed25519_1.deriveED25519HardenedKey;
    } });
    Object.defineProperty(exports, "deriveEd25519Path", { enumerable: true, get: function() {
      return ed25519_1.deriveEd25519Path;
    } });
    var symmetric_1 = require_symmetric();
    Object.defineProperty(exports, "getSymmetricMasterKeyFromSeed", { enumerable: true, get: function() {
      return symmetric_1.getSymmetricMasterKeyFromSeed;
    } });
    Object.defineProperty(exports, "deriveSymmetricHardenedKey", { enumerable: true, get: function() {
      return symmetric_1.deriveSymmetricHardenedKey;
    } });
    Object.defineProperty(exports, "deriveSymmetricPath", { enumerable: true, get: function() {
      return symmetric_1.deriveSymmetricPath;
    } });
    var mnemonics_1 = require_mnemonics();
    Object.defineProperty(exports, "deriveMnemonicsPath", { enumerable: true, get: function() {
      return mnemonics_1.deriveMnemonicsPath;
    } });
    Object.defineProperty(exports, "deriveMnemonicHardenedKey", { enumerable: true, get: function() {
      return mnemonics_1.deriveMnemonicHardenedKey;
    } });
    Object.defineProperty(exports, "getMnemonicsMasterKeyFromSeed", { enumerable: true, get: function() {
      return mnemonics_1.getMnemonicsMasterKeyFromSeed;
    } });
  }
});

// node_modules/ton-core/dist/boc/cell/wonderCalculator.js
var require_wonderCalculator = __commonJS({
  "node_modules/ton-core/dist/boc/cell/wonderCalculator.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wonderCalculator = void 0;
    var BitString_1 = require_BitString();
    var CellType_1 = require_CellType();
    var LevelMask_1 = require_LevelMask();
    var exoticPruned_1 = require_exoticPruned();
    var exoticMerkleProof_1 = require_exoticMerkleProof();
    var descriptor_1 = require_descriptor();
    var ton_crypto_1 = require_dist();
    var exoticMerkleUpdate_1 = require_exoticMerkleUpdate();
    var exoticLibrary_1 = require_exoticLibrary();
    function wonderCalculator(type2, bits, refs) {
      let levelMask;
      let pruned = null;
      if (type2 === CellType_1.CellType.Ordinary) {
        let mask = 0;
        for (let r of refs) {
          mask = mask | r.mask.value;
        }
        levelMask = new LevelMask_1.LevelMask(mask);
      } else if (type2 === CellType_1.CellType.PrunedBranch) {
        pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);
        levelMask = new LevelMask_1.LevelMask(pruned.mask);
      } else if (type2 === CellType_1.CellType.MerkleProof) {
        let loaded = (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);
        levelMask = new LevelMask_1.LevelMask(refs[0].mask.value >> 1);
      } else if (type2 === CellType_1.CellType.MerkleUpdate) {
        let loaded = (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);
        levelMask = new LevelMask_1.LevelMask((refs[0].mask.value | refs[1].mask.value) >> 1);
      } else if (type2 === CellType_1.CellType.Library) {
        let loaded = (0, exoticLibrary_1.exoticLibrary)(bits, refs);
        levelMask = new LevelMask_1.LevelMask();
      } else {
        throw new Error("Unsupported exotic type");
      }
      let depths = [];
      let hashes = [];
      let hashCount = type2 === CellType_1.CellType.PrunedBranch ? 1 : levelMask.hashCount;
      let totalHashCount = levelMask.hashCount;
      let hashIOffset = totalHashCount - hashCount;
      for (let levelI = 0, hashI = 0; levelI <= levelMask.level; levelI++) {
        if (!levelMask.isSignificant(levelI)) {
          continue;
        }
        if (hashI < hashIOffset) {
          hashI++;
          continue;
        }
        let currentBits;
        if (hashI === hashIOffset) {
          if (!(levelI === 0 || type2 === CellType_1.CellType.PrunedBranch)) {
            throw Error("Invalid");
          }
          currentBits = bits;
        } else {
          if (!(levelI !== 0 && type2 !== CellType_1.CellType.PrunedBranch)) {
            throw Error("Invalid: " + levelI + ", " + type2);
          }
          currentBits = new BitString_1.BitString(hashes[hashI - hashIOffset - 1], 0, 256);
        }
        let currentDepth = 0;
        for (let c of refs) {
          let childDepth;
          if (type2 == CellType_1.CellType.MerkleProof || type2 == CellType_1.CellType.MerkleUpdate) {
            childDepth = c.depth(levelI + 1);
          } else {
            childDepth = c.depth(levelI);
          }
          currentDepth = Math.max(currentDepth, childDepth);
        }
        if (refs.length > 0) {
          currentDepth++;
        }
        let repr = (0, descriptor_1.getRepr)(currentBits, refs, levelI, type2);
        let hash = (0, ton_crypto_1.sha256_sync)(repr);
        let destI = hashI - hashIOffset;
        depths[destI] = currentDepth;
        hashes[destI] = hash;
        hashI++;
      }
      let resolvedHashes = [];
      let resolvedDepths = [];
      if (pruned) {
        for (let i = 0; i < 4; i++) {
          const { hashIndex } = levelMask.apply(i);
          const { hashIndex: thisHashIndex } = levelMask;
          if (hashIndex !== thisHashIndex) {
            resolvedHashes.push(pruned.pruned[hashIndex].hash);
            resolvedDepths.push(pruned.pruned[hashIndex].depth);
          } else {
            resolvedHashes.push(hashes[0]);
            resolvedDepths.push(depths[0]);
          }
        }
      } else {
        for (let i = 0; i < 4; i++) {
          resolvedHashes.push(hashes[levelMask.apply(i).hashIndex]);
          resolvedDepths.push(depths[levelMask.apply(i).hashIndex]);
        }
      }
      return {
        mask: levelMask,
        hashes: resolvedHashes,
        depths: resolvedDepths
      };
    }
    exports.wonderCalculator = wonderCalculator;
  }
});

// node_modules/ton-core/dist/boc/cell/utils/topologicalSort.js
var require_topologicalSort = __commonJS({
  "node_modules/ton-core/dist/boc/cell/utils/topologicalSort.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.topologicalSort = void 0;
    function topologicalSort(src) {
      let pending = [src];
      let allCells = /* @__PURE__ */ new Map();
      let notPermCells = /* @__PURE__ */ new Set();
      let sorted = [];
      while (pending.length > 0) {
        const cells = [...pending];
        pending = [];
        for (let cell of cells) {
          const hash = cell.hash().toString("hex");
          if (allCells.has(hash)) {
            continue;
          }
          notPermCells.add(hash);
          allCells.set(hash, { cell, refs: cell.refs.map((v) => v.hash().toString("hex")) });
          for (let r of cell.refs) {
            pending.push(r);
          }
        }
      }
      let tempMark = /* @__PURE__ */ new Set();
      function visit(hash) {
        if (!notPermCells.has(hash)) {
          return;
        }
        if (tempMark.has(hash)) {
          throw Error("Not a DAG");
        }
        tempMark.add(hash);
        for (let c of allCells.get(hash).refs) {
          visit(c);
        }
        sorted.unshift(hash);
        tempMark.delete(hash);
        notPermCells.delete(hash);
      }
      while (notPermCells.size > 0) {
        const id = Array.from(notPermCells)[0];
        visit(id);
      }
      let indexes = /* @__PURE__ */ new Map();
      for (let i = 0; i < sorted.length; i++) {
        indexes.set(sorted[i], i);
      }
      let result = [];
      for (let ent of sorted) {
        const rrr = allCells.get(ent);
        result.push({ cell: rrr.cell, refs: rrr.refs.map((v) => indexes.get(v)) });
      }
      return result;
    }
    exports.topologicalSort = topologicalSort;
  }
});

// node_modules/ton-core/dist/utils/bitsForNumber.js
var require_bitsForNumber = __commonJS({
  "node_modules/ton-core/dist/utils/bitsForNumber.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bitsForNumber = void 0;
    function bitsForNumber(src, mode) {
      let v = BigInt(src);
      if (mode === "int") {
        if (v === 0n || v === -1n) {
          return 1;
        }
        let v2 = v > 0 ? v : -v;
        return v2.toString(2).length + 1;
      } else if (mode === "uint") {
        if (v < 0) {
          throw Error(`value is negative. Got ${src}`);
        }
        return v.toString(2).length;
      } else {
        throw Error(`invalid mode. Got ${mode}`);
      }
    }
    exports.bitsForNumber = bitsForNumber;
  }
});

// node_modules/ton-core/dist/utils/crc32c.js
var require_crc32c = __commonJS({
  "node_modules/ton-core/dist/utils/crc32c.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crc32c = void 0;
    var POLY = 2197175160;
    function crc32c(source) {
      let crc = 0 ^ 4294967295;
      for (let n = 0; n < source.length; n++) {
        crc ^= source[n];
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      }
      crc = crc ^ 4294967295;
      let res = import_buffer.Buffer.alloc(4);
      res.writeInt32LE(crc);
      return res;
    }
    exports.crc32c = crc32c;
  }
});

// node_modules/ton-core/dist/boc/cell/serialization.js
var require_serialization = __commonJS({
  "node_modules/ton-core/dist/boc/cell/serialization.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeBoc = exports.deserializeBoc = exports.parseBoc = void 0;
    var BitReader_1 = require_BitReader();
    var BitString_1 = require_BitString();
    var Cell_1 = require_Cell();
    var topologicalSort_1 = require_topologicalSort();
    var bitsForNumber_1 = require_bitsForNumber();
    var BitBuilder_1 = require_BitBuilder();
    var descriptor_1 = require_descriptor();
    var paddedBits_1 = require_paddedBits();
    var crc32c_1 = require_crc32c();
    function readCell(reader, sizeBytes) {
      const d1 = reader.loadUint(8);
      const refsCount = d1 % 8;
      const exotic = !!(d1 & 8);
      const d2 = reader.loadUint(8);
      const dataBytesize = Math.ceil(d2 / 2);
      const paddingAdded = !!(d2 % 2);
      let bits = BitString_1.BitString.EMPTY;
      if (dataBytesize > 0) {
        if (paddingAdded) {
          bits = reader.loadPaddedBits(dataBytesize * 8);
        } else {
          bits = reader.loadBits(dataBytesize * 8);
        }
      }
      let refs = [];
      for (let i = 0; i < refsCount; i++) {
        refs.push(reader.loadUint(sizeBytes * 8));
      }
      return {
        bits,
        refs,
        exotic
      };
    }
    function calcCellSize(cell, sizeBytes) {
      return 2 + Math.ceil(cell.bits.length / 8) + cell.refs.length * sizeBytes;
    }
    function parseBoc(src) {
      let reader = new BitReader_1.BitReader(new BitString_1.BitString(src, 0, src.length * 8));
      let magic = reader.loadUint(32);
      if (magic === 1761568243) {
        let size4 = reader.loadUint(8);
        let offBytes = reader.loadUint(8);
        let cells = reader.loadUint(size4 * 8);
        let roots = reader.loadUint(size4 * 8);
        let absent = reader.loadUint(size4 * 8);
        let totalCellSize = reader.loadUint(offBytes * 8);
        let index = reader.loadBuffer(cells * offBytes);
        let cellData = reader.loadBuffer(totalCellSize);
        return {
          size: size4,
          offBytes,
          cells,
          roots,
          absent,
          totalCellSize,
          index,
          cellData,
          root: [0]
        };
      } else if (magic === 2898503464) {
        let size4 = reader.loadUint(8);
        let offBytes = reader.loadUint(8);
        let cells = reader.loadUint(size4 * 8);
        let roots = reader.loadUint(size4 * 8);
        let absent = reader.loadUint(size4 * 8);
        let totalCellSize = reader.loadUint(offBytes * 8);
        let index = reader.loadBuffer(cells * offBytes);
        let cellData = reader.loadBuffer(totalCellSize);
        let crc32 = reader.loadBuffer(4);
        if (!(0, crc32c_1.crc32c)(src.subarray(0, src.length - 4)).equals(crc32)) {
          throw Error("Invalid CRC32C");
        }
        return {
          size: size4,
          offBytes,
          cells,
          roots,
          absent,
          totalCellSize,
          index,
          cellData,
          root: [0]
        };
      } else if (magic === 3052313714) {
        let hasIdx = reader.loadUint(1);
        let hasCrc32c = reader.loadUint(1);
        let hasCacheBits = reader.loadUint(1);
        let flags = reader.loadUint(2);
        let size4 = reader.loadUint(3);
        let offBytes = reader.loadUint(8);
        let cells = reader.loadUint(size4 * 8);
        let roots = reader.loadUint(size4 * 8);
        let absent = reader.loadUint(size4 * 8);
        let totalCellSize = reader.loadUint(offBytes * 8);
        let root = [];
        for (let i = 0; i < roots; i++) {
          root.push(reader.loadUint(size4 * 8));
        }
        let index = null;
        if (hasIdx) {
          index = reader.loadBuffer(cells * offBytes);
        }
        let cellData = reader.loadBuffer(totalCellSize);
        if (hasCrc32c) {
          let crc32 = reader.loadBuffer(4);
          if (!(0, crc32c_1.crc32c)(src.subarray(0, src.length - 4)).equals(crc32)) {
            throw Error("Invalid CRC32C");
          }
        }
        return {
          size: size4,
          offBytes,
          cells,
          roots,
          absent,
          totalCellSize,
          index,
          cellData,
          root
        };
      } else {
        throw Error("Invalid magic");
      }
    }
    exports.parseBoc = parseBoc;
    function deserializeBoc(src) {
      let boc = parseBoc(src);
      let reader = new BitReader_1.BitReader(new BitString_1.BitString(boc.cellData, 0, boc.cellData.length * 8));
      let cells = [];
      for (let i = 0; i < boc.cells; i++) {
        let cll = readCell(reader, boc.size);
        cells.push({ ...cll, result: null });
      }
      for (let i = cells.length - 1; i >= 0; i--) {
        if (cells[i].result) {
          throw Error("Impossible");
        }
        let refs = [];
        for (let r of cells[i].refs) {
          if (!cells[r].result) {
            throw Error("Invalid BOC file");
          }
          refs.push(cells[r].result);
        }
        cells[i].result = new Cell_1.Cell({ bits: cells[i].bits, refs, exotic: cells[i].exotic });
      }
      let roots = [];
      for (let i = 0; i < boc.root.length; i++) {
        roots.push(cells[boc.root[i]].result);
      }
      return roots;
    }
    exports.deserializeBoc = deserializeBoc;
    function writeCellToBuilder(cell, refs, sizeBytes, to) {
      let d1 = (0, descriptor_1.getRefsDescriptor)(cell.refs, cell.level(), cell.type);
      let d2 = (0, descriptor_1.getBitsDescriptor)(cell.bits);
      to.writeUint(d1, 8);
      to.writeUint(d2, 8);
      to.writeBuffer((0, paddedBits_1.bitsToPaddedBuffer)(cell.bits));
      for (let r of refs) {
        to.writeUint(r, sizeBytes * 8);
      }
    }
    function serializeBoc(root, opts) {
      let allCells = (0, topologicalSort_1.topologicalSort)(root);
      let cellsNum = allCells.length;
      let has_idx = opts.idx;
      let has_crc32c = opts.crc32;
      let has_cache_bits = false;
      let flags = 0;
      let sizeBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(cellsNum, "uint") / 8), 1);
      let totalCellSize = 0;
      let index = [];
      for (let c of allCells) {
        let sz = calcCellSize(c.cell, sizeBytes);
        index.push(totalCellSize);
        totalCellSize += sz;
      }
      let offsetBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(totalCellSize, "uint") / 8), 1);
      let totalSize = (4 + // magic
      1 + // flags and s_bytes
      1 + // offset_bytes
      3 * sizeBytes + // cells_num, roots, complete
      offsetBytes + // full_size
      1 * sizeBytes + // root_idx
      (has_idx ? cellsNum * offsetBytes : 0) + totalCellSize + (has_crc32c ? 4 : 0)) * 8;
      let builder = new BitBuilder_1.BitBuilder(totalSize);
      builder.writeUint(3052313714, 32);
      builder.writeBit(has_idx);
      builder.writeBit(has_crc32c);
      builder.writeBit(has_cache_bits);
      builder.writeUint(flags, 2);
      builder.writeUint(sizeBytes, 3);
      builder.writeUint(offsetBytes, 8);
      builder.writeUint(cellsNum, sizeBytes * 8);
      builder.writeUint(1, sizeBytes * 8);
      builder.writeUint(0, sizeBytes * 8);
      builder.writeUint(totalCellSize, offsetBytes * 8);
      builder.writeUint(0, sizeBytes * 8);
      if (has_idx) {
        for (let i = 0; i < cellsNum; i++) {
          builder.writeUint(index[i], offsetBytes * 8);
        }
      }
      for (let i = 0; i < cellsNum; i++) {
        writeCellToBuilder(allCells[i].cell, allCells[i].refs, sizeBytes, builder);
      }
      if (has_crc32c) {
        let crc32 = (0, crc32c_1.crc32c)(builder.buffer());
        builder.writeBuffer(crc32);
      }
      let res = builder.buffer();
      if (res.length !== totalSize / 8) {
        throw Error("Internal error");
      }
      return res;
    }
    exports.serializeBoc = serializeBoc;
  }
});

// node_modules/ton-core/dist/boc/Cell.js
var require_Cell = __commonJS({
  "node_modules/ton-core/dist/boc/Cell.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Cell = void 0;
    var symbol_inspect_1 = __importDefault(require_symbol());
    var BitString_1 = require_BitString();
    var CellType_1 = require_CellType();
    var Slice_1 = require_Slice();
    var resolveExotic_1 = require_resolveExotic();
    var wonderCalculator_1 = require_wonderCalculator();
    var serialization_1 = require_serialization();
    var BitReader_1 = require_BitReader();
    var Builder_1 = require_Builder();
    var Cell = class {
      /**
       * Deserialize cells from BOC
       * @param src source buffer
       * @returns array of cells
       */
      static fromBoc(src) {
        return (0, serialization_1.deserializeBoc)(src);
      }
      /**
       * Helper class that deserializes a single cell from BOC in base64
       * @param src source string
       */
      static fromBase64(src) {
        let parsed = Cell.fromBoc(import_buffer.Buffer.from(src, "base64"));
        if (parsed.length !== 1) {
          throw new Error("Deserialized more than one cell");
        }
        return parsed[0];
      }
      constructor(opts) {
        this._hashes = [];
        this._depths = [];
        this.beginParse = (allowExotic = false) => {
          if (this.isExotic && !allowExotic) {
            throw new Error("Exotic cells cannot be parsed");
          }
          return new Slice_1.Slice(new BitReader_1.BitReader(this.bits), this.refs);
        };
        this.hash = (level = 3) => {
          return this._hashes[Math.min(this._hashes.length - 1, level)];
        };
        this.depth = (level = 3) => {
          return this._depths[Math.min(this._depths.length - 1, level)];
        };
        this.level = () => {
          return this.mask.level;
        };
        this.equals = (other) => {
          return this.hash().equals(other.hash());
        };
        this[_a] = () => this.toString();
        let bits = BitString_1.BitString.EMPTY;
        if (opts && opts.bits) {
          bits = opts.bits;
        }
        let refs = [];
        if (opts && opts.refs) {
          refs = [...opts.refs];
        }
        let hashes;
        let depths;
        let mask;
        let type2 = CellType_1.CellType.Ordinary;
        if (opts && opts.exotic) {
          let resolved = (0, resolveExotic_1.resolveExotic)(bits, refs);
          let wonders = (0, wonderCalculator_1.wonderCalculator)(resolved.type, bits, refs);
          mask = wonders.mask;
          depths = wonders.depths;
          hashes = wonders.hashes;
          type2 = resolved.type;
        } else {
          if (refs.length > 4) {
            throw new Error("Invalid number of references");
          }
          if (bits.length > 1023) {
            throw new Error(`Bits overflow: ${bits.length} > 1023`);
          }
          let wonders = (0, wonderCalculator_1.wonderCalculator)(CellType_1.CellType.Ordinary, bits, refs);
          mask = wonders.mask;
          depths = wonders.depths;
          hashes = wonders.hashes;
          type2 = CellType_1.CellType.Ordinary;
        }
        this.type = type2;
        this.bits = bits;
        this.refs = refs;
        this.mask = mask;
        this._depths = depths;
        this._hashes = hashes;
        Object.freeze(this);
        Object.freeze(this.refs);
        Object.freeze(this.bits);
        Object.freeze(this.mask);
        Object.freeze(this._depths);
        Object.freeze(this._hashes);
      }
      /**
       * Check if cell is exotic
       */
      get isExotic() {
        return this.type !== CellType_1.CellType.Ordinary;
      }
      /**
       * Serializes cell to BOC
       * @param opts options
       */
      toBoc(opts) {
        let idx = opts && opts.idx !== null && opts.idx !== void 0 ? opts.idx : false;
        let crc32 = opts && opts.crc32 !== null && opts.crc32 !== void 0 ? opts.crc32 : true;
        return (0, serialization_1.serializeBoc)(this, { idx, crc32 });
      }
      /**
       * Format cell to string
       * @param indent indentation
       * @returns string representation
       */
      toString(indent) {
        let id = indent || "";
        let t = "x";
        if (this.isExotic) {
          if (this.type === CellType_1.CellType.MerkleProof) {
            t = "p";
          } else if (this.type === CellType_1.CellType.MerkleUpdate) {
            t = "u";
          } else if (this.type === CellType_1.CellType.PrunedBranch) {
            t = "p";
          }
        }
        let s = id + (this.isExotic ? t : "x") + "{" + this.bits.toString() + "}";
        for (let k in this.refs) {
          const i = this.refs[k];
          s += "\n" + i.toString(id + " ");
        }
        return s;
      }
      /**
       * Covnert cell to slice
       * @returns slice
       */
      asSlice() {
        return this.beginParse();
      }
      /**
       * Convert cell to a builder that has this cell stored
       * @returns builder
       */
      asBuilder() {
        return (0, Builder_1.beginCell)().storeSlice(this.asSlice());
      }
    };
    exports.Cell = Cell;
    _a = symbol_inspect_1.default;
    Cell.EMPTY = new Cell();
  }
});

// node_modules/ton-core/dist/boc/Builder.js
var require_Builder = __commonJS({
  "node_modules/ton-core/dist/boc/Builder.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Builder = exports.beginCell = void 0;
    var BitBuilder_1 = require_BitBuilder();
    var Cell_1 = require_Cell();
    var strings_1 = require_strings();
    function beginCell() {
      return new Builder();
    }
    exports.beginCell = beginCell;
    var Builder = class {
      constructor() {
        this._bits = new BitBuilder_1.BitBuilder();
        this._refs = [];
      }
      /**
       * Bits written so far
       */
      get bits() {
        return this._bits.length;
      }
      /**
       * References written so far
       */
      get refs() {
        return this._refs.length;
      }
      /**
       * Available bits
       */
      get availableBits() {
        return 1023 - this.bits;
      }
      /**
       * Available references
       */
      get availableRefs() {
        return 4 - this.refs;
      }
      /**
       * Write a single bit
       * @param value bit to write, true or positive number for 1, false or zero or negative for 0
       * @returns this builder
       */
      storeBit(value) {
        this._bits.writeBit(value);
        return this;
      }
      /**
       * Write bits from BitString
       * @param src source bits
       * @returns this builder
       */
      storeBits(src) {
        this._bits.writeBits(src);
        return this;
      }
      /**
       * Store Buffer
       * @param src source buffer
       * @param bytes optional number of bytes to write
       * @returns this builder
       */
      storeBuffer(src, bytes) {
        if (bytes !== void 0 && bytes !== null) {
          if (src.length !== bytes) {
            throw Error(`Buffer length ${src.length} is not equal to ${bytes}`);
          }
        }
        this._bits.writeBuffer(src);
        return this;
      }
      /**
       * Store Maybe Buffer
       * @param src source buffer or null
       * @param bytes optional number of bytes to write
       * @returns this builder
       */
      storeMaybeBuffer(src, bytes) {
        if (src !== null) {
          this.storeBit(1);
          this.storeBuffer(src, bytes);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store uint value
       * @param value value as bigint or number
       * @param bits number of bits to write
       * @returns this builder
       */
      storeUint(value, bits) {
        this._bits.writeUint(value, bits);
        return this;
      }
      /**
       * Store maybe uint value
       * @param value value as bigint or number, null or undefined
       * @param bits number of bits to write
       * @returns this builder
       */
      storeMaybeUint(value, bits) {
        if (value !== null && value !== void 0) {
          this.storeBit(1);
          this.storeUint(value, bits);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store int value
       * @param value value as bigint or number
       * @param bits number of bits to write
       * @returns this builder
       */
      storeInt(value, bits) {
        this._bits.writeInt(value, bits);
        return this;
      }
      /**
       * Store maybe int value
       * @param value value as bigint or number, null or undefined
       * @param bits number of bits to write
       * @returns this builder
       */
      storeMaybeInt(value, bits) {
        if (value !== null && value !== void 0) {
          this.storeBit(1);
          this.storeInt(value, bits);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store varuint value
       * @param value value as bigint or number
       * @param bits number of bits to write to header
       * @returns this builder
       */
      storeVarUint(value, bits) {
        this._bits.writeVarUint(value, bits);
        return this;
      }
      /**
       * Store maybe varuint value
       * @param value value as bigint or number, null or undefined
       * @param bits number of bits to write to header
       * @returns this builder
       */
      storeMaybeVarUint(value, bits) {
        if (value !== null && value !== void 0) {
          this.storeBit(1);
          this.storeVarUint(value, bits);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store varint value
       * @param value value as bigint or number
       * @param bits number of bits to write to header
       * @returns this builder
       */
      storeVarInt(value, bits) {
        this._bits.writeVarInt(value, bits);
        return this;
      }
      /**
       * Store maybe varint value
       * @param value value as bigint or number, null or undefined
       * @param bits number of bits to write to header
       * @returns this builder
       */
      storeMaybeVarInt(value, bits) {
        if (value !== null && value !== void 0) {
          this.storeBit(1);
          this.storeVarInt(value, bits);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store coins value
       * @param amount amount of coins
       * @returns this builder
       */
      storeCoins(amount) {
        this._bits.writeCoins(amount);
        return this;
      }
      /**
       * Store maybe coins value
       * @param amount amount of coins, null or undefined
       * @returns this builder
       */
      storeMaybeCoins(amount) {
        if (amount !== null && amount !== void 0) {
          this.storeBit(1);
          this.storeCoins(amount);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store address
       * @param addres address to store
       * @returns this builder
       */
      storeAddress(address) {
        this._bits.writeAddress(address);
        return this;
      }
      /**
       * Store reference
       * @param cell cell or builder to store
       * @returns this builder
       */
      storeRef(cell) {
        if (this._refs.length >= 4) {
          throw new Error("Too many references");
        }
        if (cell instanceof Cell_1.Cell) {
          this._refs.push(cell);
        } else if (cell instanceof Builder) {
          this._refs.push(cell.endCell());
        } else {
          throw new Error("Invalid argument");
        }
        return this;
      }
      /**
       * Store reference if not null
       * @param cell cell or builder to store
       * @returns this builder
       */
      storeMaybeRef(cell) {
        if (cell) {
          this.storeBit(1);
          this.storeRef(cell);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store slice it in this builder
       * @param src source slice
       */
      storeSlice(src) {
        let c = src.clone();
        if (c.remainingBits > 0) {
          this.storeBits(c.loadBits(c.remainingBits));
        }
        while (c.remainingRefs > 0) {
          this.storeRef(c.loadRef());
        }
        return this;
      }
      /**
       * Store slice in this builder if not null
       * @param src source slice
       */
      storeMaybeSlice(src) {
        if (src) {
          this.storeBit(1);
          this.storeSlice(src);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store builder
       * @param src builder to store
       * @returns this builder
       */
      storeBuilder(src) {
        return this.storeSlice(src.endCell().beginParse());
      }
      /**
       * Store builder if not null
       * @param src builder to store
       * @returns this builder
       */
      storeMaybeBuilder(src) {
        if (src) {
          this.storeBit(1);
          this.storeBuilder(src);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store writer or builder
       * @param writer writer or builder to store
       * @returns this builder
       */
      storeWritable(writer) {
        if (typeof writer === "object") {
          writer.writeTo(this);
        } else {
          writer(this);
        }
        return this;
      }
      /**
       * Store writer or builder if not null
       * @param writer writer or builder to store
       * @returns this builder
       */
      storeMaybeWritable(writer) {
        if (writer) {
          this.storeBit(1);
          this.storeWritable(writer);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store object in this builder
       * @param writer Writable or writer functuin
       */
      store(writer) {
        this.storeWritable(writer);
        return this;
      }
      /**
       * Store string tail
       * @param src source string
       * @returns this builder
       */
      storeStringTail(src) {
        (0, strings_1.writeString)(src, this);
        return this;
      }
      /**
       * Store string tail
       * @param src source string
       * @returns this builder
       */
      storeMaybeStringTail(src) {
        if (src !== null && src !== void 0) {
          this.storeBit(1);
          (0, strings_1.writeString)(src, this);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store string tail in ref
       * @param src source string
       * @returns this builder
       */
      storeStringRefTail(src) {
        this.storeRef(beginCell().storeStringTail(src));
        return this;
      }
      /**
       * Store maybe string tail in ref
       * @param src source string
       * @returns this builder
       */
      storeMaybeStringRefTail(src) {
        if (src !== null && src !== void 0) {
          this.storeBit(1);
          this.storeStringRefTail(src);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store dictionary in this builder
       * @param dict dictionary to store
       * @returns this builder
       */
      storeDict(dict, key, value) {
        if (dict) {
          dict.store(this, key, value);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store dictionary in this builder directly
       * @param dict dictionary to store
       * @returns this builder
       */
      storeDictDirect(dict, key, value) {
        dict.storeDirect(this, key, value);
        return this;
      }
      /**
       * Complete cell
       * @returns cell
       */
      endCell() {
        return new Cell_1.Cell({
          bits: this._bits.build(),
          refs: this._refs
        });
      }
      /**
       * Convert to cell
       * @returns cell
       */
      asCell() {
        return this.endCell();
      }
      /**
       * Convert to slice
       * @returns slice
       */
      asSlice() {
        return this.endCell().beginParse();
      }
    };
    exports.Builder = Builder;
  }
});

// node_modules/ton-core/dist/types/SimpleLibrary.js
var require_SimpleLibrary = __commonJS({
  "node_modules/ton-core/dist/types/SimpleLibrary.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SimpleLibraryValue = exports.storeSimpleLibrary = exports.loadSimpleLibrary = void 0;
    function loadSimpleLibrary(slice) {
      return {
        public: slice.loadBit(),
        root: slice.loadRef()
      };
    }
    exports.loadSimpleLibrary = loadSimpleLibrary;
    function storeSimpleLibrary(src) {
      return (builder) => {
        builder.storeBit(src.public);
        builder.storeRef(src.root);
      };
    }
    exports.storeSimpleLibrary = storeSimpleLibrary;
    exports.SimpleLibraryValue = {
      serialize(src, builder) {
        storeSimpleLibrary(src)(builder);
      },
      parse(src) {
        return loadSimpleLibrary(src);
      }
    };
  }
});

// node_modules/ton-core/dist/types/TickTock.js
var require_TickTock = __commonJS({
  "node_modules/ton-core/dist/types/TickTock.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeTickTock = exports.loadTickTock = void 0;
    function loadTickTock(slice) {
      return {
        tick: slice.loadBit(),
        tock: slice.loadBit()
      };
    }
    exports.loadTickTock = loadTickTock;
    function storeTickTock(src) {
      return (builder) => {
        builder.storeBit(src.tick);
        builder.storeBit(src.tock);
      };
    }
    exports.storeTickTock = storeTickTock;
  }
});

// node_modules/ton-core/dist/types/StateInit.js
var require_StateInit = __commonJS({
  "node_modules/ton-core/dist/types/StateInit.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeStateInit = exports.loadStateInit = void 0;
    var Dictionary_1 = require_Dictionary();
    var SimpleLibrary_1 = require_SimpleLibrary();
    var TickTock_1 = require_TickTock();
    function loadStateInit(slice) {
      let splitDepth;
      if (slice.loadBit()) {
        splitDepth = slice.loadUint(5);
      }
      let special;
      if (slice.loadBit()) {
        special = (0, TickTock_1.loadTickTock)(slice);
      }
      let code = slice.loadMaybeRef();
      let data = slice.loadMaybeRef();
      let libraries = slice.loadDict(Dictionary_1.Dictionary.Keys.BigUint(256), SimpleLibrary_1.SimpleLibraryValue);
      if (libraries.size === 0) {
        libraries = void 0;
      }
      return {
        splitDepth,
        special,
        code,
        data,
        libraries
      };
    }
    exports.loadStateInit = loadStateInit;
    function storeStateInit(src) {
      return (builder) => {
        if (src.splitDepth !== null && src.splitDepth !== void 0) {
          builder.storeBit(true);
          builder.storeUint(src.splitDepth, 5);
        } else {
          builder.storeBit(false);
        }
        if (src.special !== null && src.special !== void 0) {
          builder.storeBit(true);
          builder.store((0, TickTock_1.storeTickTock)(src.special));
        } else {
          builder.storeBit(false);
        }
        builder.storeMaybeRef(src.code);
        builder.storeMaybeRef(src.data);
        builder.storeDict(src.libraries);
      };
    }
    exports.storeStateInit = storeStateInit;
  }
});

// node_modules/ton-core/dist/address/contractAddress.js
var require_contractAddress = __commonJS({
  "node_modules/ton-core/dist/address/contractAddress.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.contractAddress = void 0;
    var Builder_1 = require_Builder();
    var StateInit_1 = require_StateInit();
    var Address_1 = require_Address();
    function contractAddress(workchain, init4) {
      let hash = (0, Builder_1.beginCell)().store((0, StateInit_1.storeStateInit)(init4)).endCell().hash();
      return new Address_1.Address(workchain, hash);
    }
    exports.contractAddress = contractAddress;
  }
});

// node_modules/ton-core/dist/tuple/tuple.js
var require_tuple = __commonJS({
  "node_modules/ton-core/dist/tuple/tuple.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTuple = exports.serializeTuple = void 0;
    var Builder_1 = require_Builder();
    var INT64_MIN = BigInt("-9223372036854775808");
    var INT64_MAX = BigInt("9223372036854775807");
    function serializeTupleItem(src, builder) {
      if (src.type === "null") {
        builder.storeUint(0, 8);
      } else if (src.type === "int") {
        if (src.value <= INT64_MAX && src.value >= INT64_MIN) {
          builder.storeUint(1, 8);
          builder.storeInt(src.value, 64);
        } else {
          builder.storeUint(256, 15);
          builder.storeInt(src.value, 257);
        }
      } else if (src.type === "nan") {
        builder.storeInt(767, 16);
      } else if (src.type === "cell") {
        builder.storeUint(3, 8);
        builder.storeRef(src.cell);
      } else if (src.type === "slice") {
        builder.storeUint(4, 8);
        builder.storeUint(0, 10);
        builder.storeUint(src.cell.bits.length, 10);
        builder.storeUint(0, 3);
        builder.storeUint(src.cell.refs.length, 3);
        builder.storeRef(src.cell);
      } else if (src.type === "builder") {
        builder.storeUint(5, 8);
        builder.storeRef(src.cell);
      } else if (src.type === "tuple") {
        let head6 = null;
        let tail5 = null;
        for (let i = 0; i < src.items.length; i++) {
          let s = head6;
          head6 = tail5;
          tail5 = s;
          if (i > 1) {
            head6 = (0, Builder_1.beginCell)().storeRef(tail5).storeRef(head6).endCell();
          }
          let bc = (0, Builder_1.beginCell)();
          serializeTupleItem(src.items[i], bc);
          tail5 = bc.endCell();
        }
        builder.storeUint(7, 8);
        builder.storeUint(src.items.length, 16);
        if (head6) {
          builder.storeRef(head6);
        }
        if (tail5) {
          builder.storeRef(tail5);
        }
      } else {
        throw Error("Invalid value");
      }
    }
    function parseStackItem(cs) {
      let kind = cs.loadUint(8);
      if (kind === 0) {
        return { type: "null" };
      } else if (kind === 1) {
        return { type: "int", value: cs.loadIntBig(64) };
      } else if (kind === 2) {
        if (cs.loadUint(7) === 0) {
          return { type: "int", value: cs.loadIntBig(257) };
        } else {
          cs.loadBit();
          return { type: "nan" };
        }
      } else if (kind === 3) {
        return { type: "cell", cell: cs.loadRef() };
      } else if (kind === 4) {
        let startBits = cs.loadUint(10);
        let endBits = cs.loadUint(10);
        let startRefs = cs.loadUint(3);
        let endRefs = cs.loadUint(3);
        let rs = cs.loadRef().beginParse();
        rs.skip(startBits);
        let dt = rs.loadBits(endBits - startBits);
        let builder = (0, Builder_1.beginCell)().storeBits(dt);
        if (startRefs < endRefs) {
          for (let i = 0; i < startRefs; i++) {
            rs.loadRef();
          }
          for (let i = 0; i < endRefs - startRefs; i++) {
            builder.storeRef(rs.loadRef());
          }
        }
        return { type: "slice", cell: builder.endCell() };
      } else if (kind === 5) {
        return { type: "builder", cell: cs.loadRef() };
      } else if (kind === 7) {
        let length = cs.loadUint(16);
        let items = [];
        if (length > 1) {
          let head6 = cs.loadRef().beginParse();
          let tail5 = cs.loadRef().beginParse();
          items.unshift(parseStackItem(tail5));
          for (let i = 0; i < length - 2; i++) {
            let ohead = head6;
            head6 = ohead.loadRef().beginParse();
            tail5 = ohead.loadRef().beginParse();
            items.unshift(parseStackItem(tail5));
          }
          items.unshift(parseStackItem(head6));
        } else if (length === 1) {
          items.push(parseStackItem(cs.loadRef().beginParse()));
        }
        return { type: "tuple", items };
      } else {
        throw Error("Unsupported stack item");
      }
    }
    function serializeTupleTail(src, builder) {
      if (src.length > 0) {
        let tail5 = (0, Builder_1.beginCell)();
        serializeTupleTail(src.slice(0, src.length - 1), tail5);
        builder.storeRef(tail5.endCell());
        serializeTupleItem(src[src.length - 1], builder);
      }
    }
    function serializeTuple(src) {
      let builder = (0, Builder_1.beginCell)();
      builder.storeUint(src.length, 24);
      let r = [...src];
      serializeTupleTail(r, builder);
      return builder.endCell();
    }
    exports.serializeTuple = serializeTuple;
    function parseTuple(src) {
      let res = [];
      let cs = src.beginParse();
      let size4 = cs.loadUint(24);
      for (let i = 0; i < size4; i++) {
        let next = cs.loadRef();
        res.unshift(parseStackItem(cs));
        cs = next.beginParse();
      }
      return res;
    }
    exports.parseTuple = parseTuple;
  }
});

// node_modules/ton-core/dist/tuple/reader.js
var require_reader = __commonJS({
  "node_modules/ton-core/dist/tuple/reader.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TupleReader = void 0;
    var TupleReader = class {
      constructor(items) {
        this.items = [...items];
      }
      get remaining() {
        return this.items.length;
      }
      peek() {
        if (this.items.length === 0) {
          throw Error("EOF");
        }
        return this.items[0];
      }
      pop() {
        if (this.items.length === 0) {
          throw Error("EOF");
        }
        let res = this.items[0];
        this.items.splice(0, 1);
        return res;
      }
      skip(num = 1) {
        for (let i = 0; i < num; i++) {
          this.pop();
        }
        return this;
      }
      readBigNumber() {
        let popped = this.pop();
        if (popped.type !== "int") {
          throw Error("Not a number");
        }
        return popped.value;
      }
      readBigNumberOpt() {
        let popped = this.pop();
        if (popped.type === "null") {
          return null;
        }
        if (popped.type !== "int") {
          throw Error("Not a number");
        }
        return popped.value;
      }
      readNumber() {
        return Number(this.readBigNumber());
      }
      readNumberOpt() {
        let r = this.readBigNumberOpt();
        if (r !== null) {
          return Number(r);
        } else {
          return null;
        }
      }
      readBoolean() {
        let res = this.readNumber();
        return res === 0 ? false : true;
      }
      readBooleanOpt() {
        let res = this.readNumberOpt();
        if (res !== null) {
          return res === 0 ? false : true;
        } else {
          return null;
        }
      }
      readAddress() {
        let r = this.readCell().beginParse().loadAddress();
        if (r !== null) {
          return r;
        } else {
          throw Error("Not an address");
        }
      }
      readAddressOpt() {
        let r = this.readCellOpt();
        if (r !== null) {
          return r.beginParse().loadMaybeAddress();
        } else {
          return null;
        }
      }
      readCell() {
        let popped = this.pop();
        if (popped.type !== "cell" && popped.type !== "slice" && popped.type !== "builder") {
          throw Error("Not a cell: " + popped.type);
        }
        return popped.cell;
      }
      readCellOpt() {
        let popped = this.pop();
        if (popped.type === "null") {
          return null;
        }
        if (popped.type !== "cell" && popped.type !== "slice" && popped.type !== "builder") {
          throw Error("Not a cell");
        }
        return popped.cell;
      }
      readTuple() {
        let popped = this.pop();
        if (popped.type !== "tuple") {
          throw Error("Not a number");
        }
        return new TupleReader(popped.items);
      }
      readTupleOpt() {
        let popped = this.pop();
        if (popped.type === "null") {
          return null;
        }
        if (popped.type !== "tuple") {
          throw Error("Not a number");
        }
        return new TupleReader(popped.items);
      }
      readBuffer() {
        let s = this.readCell().beginParse();
        if (s.remainingRefs !== 0) {
          throw Error("Not a buffer");
        }
        if (s.remainingBits % 8 !== 0) {
          throw Error("Not a buffer");
        }
        return s.loadBuffer(s.remainingBits / 8);
      }
      readBufferOpt() {
        let popped = this.peek();
        if (popped.type === "null") {
          return null;
        }
        let s = this.readCell().beginParse();
        if (s.remainingRefs !== 0) {
          throw Error("Not a buffer");
        }
        if (s.remainingBits % 8 !== 0) {
          throw Error("Not a buffer");
        }
        return s.loadBuffer(s.remainingBits / 8);
      }
      readString() {
        let s = this.readCell().beginParse();
        return s.loadStringTail();
      }
      readStringOpt() {
        let popped = this.peek();
        if (popped.type === "null") {
          return null;
        }
        let s = this.readCell().beginParse();
        return s.loadStringTail();
      }
    };
    exports.TupleReader = TupleReader;
  }
});

// node_modules/ton-core/dist/tuple/builder.js
var require_builder = __commonJS({
  "node_modules/ton-core/dist/tuple/builder.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TupleBuilder = void 0;
    var Builder_1 = require_Builder();
    var Cell_1 = require_Cell();
    var Slice_1 = require_Slice();
    var TupleBuilder = class {
      constructor() {
        this._tuple = [];
      }
      writeNumber(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          this._tuple.push({ type: "int", value: BigInt(v) });
        }
      }
      writeBoolean(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          this._tuple.push({ type: "int", value: v ? -1n : 0n });
        }
      }
      writeBuffer(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          this._tuple.push({ type: "slice", cell: (0, Builder_1.beginCell)().storeBuffer(v).endCell() });
        }
      }
      writeString(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          this._tuple.push({ type: "slice", cell: (0, Builder_1.beginCell)().storeStringTail(v).endCell() });
        }
      }
      writeCell(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          if (v instanceof Cell_1.Cell) {
            this._tuple.push({ type: "cell", cell: v });
          } else if (v instanceof Slice_1.Slice) {
            this._tuple.push({ type: "cell", cell: v.asCell() });
          }
        }
      }
      writeSlice(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          if (v instanceof Cell_1.Cell) {
            this._tuple.push({ type: "slice", cell: v });
          } else if (v instanceof Slice_1.Slice) {
            this._tuple.push({ type: "slice", cell: v.asCell() });
          }
        }
      }
      writeBuilder(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          if (v instanceof Cell_1.Cell) {
            this._tuple.push({ type: "builder", cell: v });
          } else if (v instanceof Slice_1.Slice) {
            this._tuple.push({ type: "builder", cell: v.asCell() });
          }
        }
      }
      writeTuple(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          this._tuple.push({ type: "tuple", items: v });
        }
      }
      writeAddress(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          this._tuple.push({ type: "slice", cell: (0, Builder_1.beginCell)().storeAddress(v).endCell() });
        }
      }
      build() {
        return [...this._tuple];
      }
    };
    exports.TupleBuilder = TupleBuilder;
  }
});

// node_modules/ton-core/dist/utils/convert.js
var require_convert = __commonJS({
  "node_modules/ton-core/dist/utils/convert.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromNano = exports.toNano = void 0;
    function toNano(src) {
      if (typeof src === "bigint") {
        return src * 1000000000n;
      } else if (typeof src === "number") {
        return BigInt(src) * 1000000000n;
      } else {
        let neg = false;
        while (src.startsWith("-")) {
          neg = !neg;
          src = src.slice(1);
        }
        if (src === ".") {
          throw Error("Invalid number");
        }
        let parts = src.split(".");
        if (parts.length > 2) {
          throw Error("Invalid number");
        }
        let whole = parts[0];
        let frac = parts[1];
        if (!whole) {
          whole = "0";
        }
        if (!frac) {
          frac = "0";
        }
        if (frac.length > 9) {
          throw Error("Invalid number");
        }
        while (frac.length < 9) {
          frac += "0";
        }
        let r = BigInt(whole) * 1000000000n + BigInt(frac);
        if (neg) {
          r = -r;
        }
        return r;
      }
    }
    exports.toNano = toNano;
    function fromNano(src) {
      let v = BigInt(src);
      let neg = false;
      if (v < 0) {
        neg = true;
        v = -v;
      }
      let frac = v % 1000000000n;
      let facStr = frac.toString();
      while (facStr.length < 9) {
        facStr = "0" + facStr;
      }
      facStr = facStr.match(/^([0-9]*[1-9]|0)(0*)/)[1];
      let whole = v / 1000000000n;
      let wholeStr = whole.toString();
      let value = `${wholeStr}${facStr === "0" ? "" : `.${facStr}`}`;
      if (neg) {
        value = "-" + value;
      }
      return value;
    }
    exports.fromNano = fromNano;
  }
});

// node_modules/ton-core/dist/types/_helpers.js
var require_helpers = __commonJS({
  "node_modules/ton-core/dist/types/_helpers.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.comment = exports.external = exports.internal = void 0;
    var Address_1 = require_Address();
    var Cell_1 = require_Cell();
    var Builder_1 = require_Builder();
    var convert_1 = require_convert();
    function internal(src) {
      let bounce = true;
      if (src.bounce !== null && src.bounce !== void 0) {
        bounce = src.bounce;
      }
      let to;
      if (typeof src.to === "string") {
        to = Address_1.Address.parse(src.to);
      } else if (Address_1.Address.isAddress(src.to)) {
        to = src.to;
      } else {
        throw new Error(`Invalid address ${src.to}`);
      }
      let value;
      if (typeof src.value === "string") {
        value = (0, convert_1.toNano)(src.value);
      } else {
        value = src.value;
      }
      let body = Cell_1.Cell.EMPTY;
      if (typeof src.body === "string") {
        body = (0, Builder_1.beginCell)().storeUint(0, 32).storeStringTail(src.body).endCell();
      } else if (src.body) {
        body = src.body;
      }
      return {
        info: {
          type: "internal",
          dest: to,
          value: { coins: value },
          bounce,
          ihrDisabled: true,
          bounced: false,
          ihrFee: 0n,
          forwardFee: 0n,
          createdAt: 0,
          createdLt: 0n
        },
        init: src.init ? { code: src.init.code, data: src.init.data } : void 0,
        body
      };
    }
    exports.internal = internal;
    function external(src) {
      let to;
      if (typeof src.to === "string") {
        to = Address_1.Address.parse(src.to);
      } else if (Address_1.Address.isAddress(src.to)) {
        to = src.to;
      } else {
        throw new Error(`Invalid address ${src.to}`);
      }
      return {
        info: {
          type: "external-in",
          dest: to,
          importFee: 0n
        },
        init: src.init ? { code: src.init.code, data: src.init.data } : void 0,
        body: src.body || Cell_1.Cell.EMPTY
      };
    }
    exports.external = external;
    function comment(src) {
      return (0, Builder_1.beginCell)().storeUint(0, 32).storeStringTail(src).endCell();
    }
    exports.comment = comment;
  }
});

// node_modules/ton-core/dist/types/AccountState.js
var require_AccountState = __commonJS({
  "node_modules/ton-core/dist/types/AccountState.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeAccountState = exports.loadAccountState = void 0;
    var StateInit_1 = require_StateInit();
    function loadAccountState(cs) {
      if (cs.loadBit()) {
        return { type: "active", state: (0, StateInit_1.loadStateInit)(cs) };
      } else if (cs.loadBit()) {
        return { type: "frozen", stateHash: cs.loadUintBig(256) };
      } else {
        return { type: "uninit" };
      }
    }
    exports.loadAccountState = loadAccountState;
    function storeAccountState(src) {
      return (builder) => {
        if (src.type === "active") {
          builder.storeBit(true);
          builder.store((0, StateInit_1.storeStateInit)(src.state));
        } else if (src.type === "frozen") {
          builder.storeBit(false);
          builder.storeBit(true);
          builder.storeUint(src.stateHash, 256);
        } else if (src.type === "uninit") {
          builder.storeBit(false);
          builder.storeBit(false);
        }
      };
    }
    exports.storeAccountState = storeAccountState;
  }
});

// node_modules/ton-core/dist/types/CurrencyCollection.js
var require_CurrencyCollection = __commonJS({
  "node_modules/ton-core/dist/types/CurrencyCollection.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeCurrencyCollection = exports.loadCurrencyCollection = void 0;
    var Dictionary_1 = require_Dictionary();
    function loadCurrencyCollection(slice) {
      const coins = slice.loadCoins();
      const other = slice.loadDict(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(
        5
        /* log2(32) */
      ));
      if (other.size === 0) {
        return { coins };
      } else {
        return { other, coins };
      }
    }
    exports.loadCurrencyCollection = loadCurrencyCollection;
    function storeCurrencyCollection(collection) {
      return (builder) => {
        builder.storeCoins(collection.coins);
        if (collection.other) {
          builder.storeDict(collection.other);
        } else {
          builder.storeBit(0);
        }
      };
    }
    exports.storeCurrencyCollection = storeCurrencyCollection;
  }
});

// node_modules/ton-core/dist/types/AccountStorage.js
var require_AccountStorage = __commonJS({
  "node_modules/ton-core/dist/types/AccountStorage.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeAccountStorage = exports.loadAccountStorage = void 0;
    var AccountState_1 = require_AccountState();
    var CurrencyCollection_1 = require_CurrencyCollection();
    function loadAccountStorage(slice) {
      return {
        lastTransLt: slice.loadUintBig(64),
        balance: (0, CurrencyCollection_1.loadCurrencyCollection)(slice),
        state: (0, AccountState_1.loadAccountState)(slice)
      };
    }
    exports.loadAccountStorage = loadAccountStorage;
    function storeAccountStorage(src) {
      return (builder) => {
        builder.storeUint(src.lastTransLt, 64);
        builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.balance));
        builder.store((0, AccountState_1.storeAccountState)(src.state));
      };
    }
    exports.storeAccountStorage = storeAccountStorage;
  }
});

// node_modules/ton-core/dist/types/StorageUsed.js
var require_StorageUsed = __commonJS({
  "node_modules/ton-core/dist/types/StorageUsed.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeStorageUsed = exports.loadStorageUsed = void 0;
    function loadStorageUsed(cs) {
      return {
        cells: cs.loadVarUintBig(3),
        bits: cs.loadVarUintBig(3),
        publicCells: cs.loadVarUintBig(3)
      };
    }
    exports.loadStorageUsed = loadStorageUsed;
    function storeStorageUsed(src) {
      return (builder) => {
        builder.storeVarUint(src.cells, 3);
        builder.storeVarUint(src.bits, 3);
        builder.storeVarUint(src.publicCells, 3);
      };
    }
    exports.storeStorageUsed = storeStorageUsed;
  }
});

// node_modules/ton-core/dist/types/StorageInto.js
var require_StorageInto = __commonJS({
  "node_modules/ton-core/dist/types/StorageInto.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeStorageInfo = exports.loadStorageInfo = void 0;
    var StorageUsed_1 = require_StorageUsed();
    function loadStorageInfo(slice) {
      return {
        used: (0, StorageUsed_1.loadStorageUsed)(slice),
        lastPaid: slice.loadUint(32),
        duePayment: slice.loadMaybeCoins()
      };
    }
    exports.loadStorageInfo = loadStorageInfo;
    function storeStorageInfo(src) {
      return (builder) => {
        builder.store((0, StorageUsed_1.storeStorageUsed)(src.used));
        builder.storeUint(src.lastPaid, 32);
        builder.storeMaybeCoins(src.duePayment);
      };
    }
    exports.storeStorageInfo = storeStorageInfo;
  }
});

// node_modules/ton-core/dist/types/Account.js
var require_Account = __commonJS({
  "node_modules/ton-core/dist/types/Account.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeAccount = exports.loadAccount = void 0;
    var AccountStorage_1 = require_AccountStorage();
    var StorageInto_1 = require_StorageInto();
    function loadAccount(slice) {
      return {
        addr: slice.loadAddress(),
        storageStats: (0, StorageInto_1.loadStorageInfo)(slice),
        storage: (0, AccountStorage_1.loadAccountStorage)(slice)
      };
    }
    exports.loadAccount = loadAccount;
    function storeAccount(src) {
      return (builder) => {
        builder.storeAddress(src.addr);
        builder.store((0, StorageInto_1.storeStorageInfo)(src.storageStats));
        builder.store((0, AccountStorage_1.storeAccountStorage)(src.storage));
      };
    }
    exports.storeAccount = storeAccount;
  }
});

// node_modules/ton-core/dist/types/AccountStatus.js
var require_AccountStatus = __commonJS({
  "node_modules/ton-core/dist/types/AccountStatus.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeAccountStatus = exports.loadAccountStatus = void 0;
    function loadAccountStatus(slice) {
      const status = slice.loadUint(2);
      if (status === 0) {
        return "uninitialized";
      }
      if (status === 1) {
        return "frozen";
      }
      if (status === 2) {
        return "active";
      }
      if (status === 3) {
        return "non-existing";
      }
      throw Error("Invalid data");
    }
    exports.loadAccountStatus = loadAccountStatus;
    function storeAccountStatus(src) {
      return (builder) => {
        if (src === "uninitialized") {
          builder.storeUint(0, 2);
        } else if (src === "frozen") {
          builder.storeUint(1, 2);
        } else if (src === "active") {
          builder.storeUint(2, 2);
        } else if (src === "non-existing") {
          builder.storeUint(3, 2);
        } else {
          throw Error("Invalid data");
        }
        return builder;
      };
    }
    exports.storeAccountStatus = storeAccountStatus;
  }
});

// node_modules/ton-core/dist/types/AccountStatusChange.js
var require_AccountStatusChange = __commonJS({
  "node_modules/ton-core/dist/types/AccountStatusChange.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeAccountStatusChange = exports.loadAccountStatusChange = void 0;
    function loadAccountStatusChange(slice) {
      if (!slice.loadBit()) {
        return "unchanged";
      }
      if (slice.loadBit()) {
        return "frozen";
      } else {
        return "deleted";
      }
    }
    exports.loadAccountStatusChange = loadAccountStatusChange;
    function storeAccountStatusChange(src) {
      return (builder) => {
        if (src == "unchanged") {
          builder.storeBit(0);
        } else if (src === "frozen") {
          builder.storeBit(1);
          builder.storeBit(0);
        } else if (src === "deleted") {
          builder.storeBit(1);
          builder.storeBit(1);
        } else {
          throw Error("Invalid account status change");
        }
      };
    }
    exports.storeAccountStatusChange = storeAccountStatusChange;
  }
});

// node_modules/ton-core/dist/types/CommonMessageInfo.js
var require_CommonMessageInfo = __commonJS({
  "node_modules/ton-core/dist/types/CommonMessageInfo.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeCommonMessageInfo = exports.loadCommonMessageInfo = void 0;
    var CurrencyCollection_1 = require_CurrencyCollection();
    function loadCommonMessageInfo(slice) {
      if (!slice.loadBit()) {
        const ihrDisabled = slice.loadBit();
        const bounce = slice.loadBit();
        const bounced = slice.loadBit();
        const src2 = slice.loadAddress();
        const dest2 = slice.loadAddress();
        const value = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
        const ihrFee = slice.loadCoins();
        const forwardFee = slice.loadCoins();
        const createdLt2 = slice.loadUintBig(64);
        const createdAt2 = slice.loadUint(32);
        return {
          type: "internal",
          ihrDisabled,
          bounce,
          bounced,
          src: src2,
          dest: dest2,
          value,
          ihrFee,
          forwardFee,
          createdLt: createdLt2,
          createdAt: createdAt2
        };
      }
      if (!slice.loadBit()) {
        const src2 = slice.loadMaybeExternalAddress();
        const dest2 = slice.loadAddress();
        const importFee = slice.loadCoins();
        return {
          type: "external-in",
          src: src2,
          dest: dest2,
          importFee
        };
      }
      const src = slice.loadAddress();
      const dest = slice.loadMaybeExternalAddress();
      const createdLt = slice.loadUintBig(64);
      const createdAt = slice.loadUint(32);
      return {
        type: "external-out",
        src,
        dest,
        createdLt,
        createdAt
      };
    }
    exports.loadCommonMessageInfo = loadCommonMessageInfo;
    function storeCommonMessageInfo(source) {
      return (builder) => {
        if (source.type === "internal") {
          builder.storeBit(0);
          builder.storeBit(source.ihrDisabled);
          builder.storeBit(source.bounce);
          builder.storeBit(source.bounced);
          builder.storeAddress(source.src);
          builder.storeAddress(source.dest);
          builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(source.value));
          builder.storeCoins(source.ihrFee);
          builder.storeCoins(source.forwardFee);
          builder.storeUint(source.createdLt, 64);
          builder.storeUint(source.createdAt, 32);
        } else if (source.type === "external-in") {
          builder.storeBit(1);
          builder.storeBit(0);
          builder.storeAddress(source.src);
          builder.storeAddress(source.dest);
          builder.storeCoins(source.importFee);
        } else if (source.type === "external-out") {
          builder.storeBit(1);
          builder.storeBit(1);
          builder.storeAddress(source.src);
          builder.storeAddress(source.dest);
          builder.storeUint(source.createdLt, 64);
          builder.storeUint(source.createdAt, 32);
        } else {
          throw new Error("Unknown CommonMessageInfo type");
        }
      };
    }
    exports.storeCommonMessageInfo = storeCommonMessageInfo;
  }
});

// node_modules/ton-core/dist/types/CommonMessageInfoRelaxed.js
var require_CommonMessageInfoRelaxed = __commonJS({
  "node_modules/ton-core/dist/types/CommonMessageInfoRelaxed.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeCommonMessageInfoRelaxed = exports.loadCommonMessageInfoRelaxed = void 0;
    var CurrencyCollection_1 = require_CurrencyCollection();
    function loadCommonMessageInfoRelaxed(slice) {
      if (!slice.loadBit()) {
        const ihrDisabled = slice.loadBit();
        const bounce = slice.loadBit();
        const bounced = slice.loadBit();
        const src2 = slice.loadMaybeAddress();
        const dest2 = slice.loadAddress();
        const value = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
        const ihrFee = slice.loadCoins();
        const forwardFee = slice.loadCoins();
        const createdLt2 = slice.loadUintBig(64);
        const createdAt2 = slice.loadUint(32);
        return {
          type: "internal",
          ihrDisabled,
          bounce,
          bounced,
          src: src2,
          dest: dest2,
          value,
          ihrFee,
          forwardFee,
          createdLt: createdLt2,
          createdAt: createdAt2
        };
      }
      if (!slice.loadBit()) {
        throw Error("External In message is not possible for CommonMessageInfoRelaxed");
      }
      const src = slice.loadMaybeAddress();
      const dest = slice.loadMaybeExternalAddress();
      const createdLt = slice.loadUintBig(64);
      const createdAt = slice.loadUint(32);
      return {
        type: "external-out",
        src,
        dest,
        createdLt,
        createdAt
      };
    }
    exports.loadCommonMessageInfoRelaxed = loadCommonMessageInfoRelaxed;
    function storeCommonMessageInfoRelaxed(source) {
      return (builder) => {
        if (source.type === "internal") {
          builder.storeBit(0);
          builder.storeBit(source.ihrDisabled);
          builder.storeBit(source.bounce);
          builder.storeBit(source.bounced);
          builder.storeAddress(source.src);
          builder.storeAddress(source.dest);
          builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(source.value));
          builder.storeCoins(source.ihrFee);
          builder.storeCoins(source.forwardFee);
          builder.storeUint(source.createdLt, 64);
          builder.storeUint(source.createdAt, 32);
        } else if (source.type === "external-out") {
          builder.storeBit(1);
          builder.storeBit(1);
          builder.storeAddress(source.src);
          builder.storeAddress(source.dest);
          builder.storeUint(source.createdLt, 64);
          builder.storeUint(source.createdAt, 32);
        } else {
          throw new Error("Unknown CommonMessageInfo type");
        }
      };
    }
    exports.storeCommonMessageInfoRelaxed = storeCommonMessageInfoRelaxed;
  }
});

// node_modules/ton-core/dist/types/ComputeSkipReason.js
var require_ComputeSkipReason = __commonJS({
  "node_modules/ton-core/dist/types/ComputeSkipReason.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeComputeSkipReason = exports.loadComputeSkipReason = void 0;
    function loadComputeSkipReason(slice) {
      let reason = slice.loadUint(2);
      if (reason === 0) {
        return "no-state";
      } else if (reason === 1) {
        return "bad-state";
      } else if (reason === 2) {
        return "no-gas";
      }
      throw new Error(`Unknown ComputeSkipReason: ${reason}`);
    }
    exports.loadComputeSkipReason = loadComputeSkipReason;
    function storeComputeSkipReason(src) {
      return (builder) => {
        if (src === "no-state") {
          builder.storeUint(0, 2);
        } else if (src === "bad-state") {
          builder.storeUint(1, 2);
        } else if (src === "no-gas") {
          builder.storeUint(2, 2);
        } else {
          throw new Error(`Unknown ComputeSkipReason: ${src}`);
        }
      };
    }
    exports.storeComputeSkipReason = storeComputeSkipReason;
  }
});

// node_modules/ton-core/dist/types/DepthBalanceInfo.js
var require_DepthBalanceInfo = __commonJS({
  "node_modules/ton-core/dist/types/DepthBalanceInfo.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeDepthBalanceInfo = exports.loadDepthBalanceInfo = void 0;
    var CurrencyCollection_1 = require_CurrencyCollection();
    function loadDepthBalanceInfo(slice) {
      let splitDepth = slice.loadUint(5);
      return {
        splitDepth,
        balance: (0, CurrencyCollection_1.loadCurrencyCollection)(slice)
      };
    }
    exports.loadDepthBalanceInfo = loadDepthBalanceInfo;
    function storeDepthBalanceInfo(src) {
      return (builder) => {
        builder.storeUint(src.splitDepth, 5);
        builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.balance));
      };
    }
    exports.storeDepthBalanceInfo = storeDepthBalanceInfo;
  }
});

// node_modules/ton-core/dist/types/HashUpdate.js
var require_HashUpdate = __commonJS({
  "node_modules/ton-core/dist/types/HashUpdate.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeHashUpdate = exports.loadHashUpdate = void 0;
    function loadHashUpdate(slice) {
      if (slice.loadUint(8) !== 114) {
        throw Error("Invalid data");
      }
      const oldHash = slice.loadBuffer(32);
      const newHash = slice.loadBuffer(32);
      return { oldHash, newHash };
    }
    exports.loadHashUpdate = loadHashUpdate;
    function storeHashUpdate(src) {
      return (builder) => {
        builder.storeUint(114, 8);
        builder.storeBuffer(src.oldHash);
        builder.storeBuffer(src.newHash);
      };
    }
    exports.storeHashUpdate = storeHashUpdate;
  }
});

// node_modules/ton-core/dist/types/MasterchainStateExtra.js
var require_MasterchainStateExtra = __commonJS({
  "node_modules/ton-core/dist/types/MasterchainStateExtra.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadMasterchainStateExtra = void 0;
    var Dictionary_1 = require_Dictionary();
    var CurrencyCollection_1 = require_CurrencyCollection();
    function loadMasterchainStateExtra(cs) {
      if (cs.loadUint(16) !== 52262) {
        throw Error("Invalid data");
      }
      if (cs.loadBit()) {
        cs.loadRef();
      }
      let configAddress = cs.loadUintBig(256);
      let config = Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.Int(32), Dictionary_1.Dictionary.Values.Cell(), cs);
      const globalBalance = (0, CurrencyCollection_1.loadCurrencyCollection)(cs);
      return {
        config,
        configAddress,
        globalBalance
      };
    }
    exports.loadMasterchainStateExtra = loadMasterchainStateExtra;
  }
});

// node_modules/ton-core/dist/types/Message.js
var require_Message = __commonJS({
  "node_modules/ton-core/dist/types/Message.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageValue = exports.storeMessage = exports.loadMessage = void 0;
    var Builder_1 = require_Builder();
    var CommonMessageInfo_1 = require_CommonMessageInfo();
    var StateInit_1 = require_StateInit();
    function loadMessage(slice) {
      const info = (0, CommonMessageInfo_1.loadCommonMessageInfo)(slice);
      let init4 = null;
      if (slice.loadBit()) {
        if (!slice.loadBit()) {
          init4 = (0, StateInit_1.loadStateInit)(slice);
        } else {
          init4 = (0, StateInit_1.loadStateInit)(slice.loadRef().beginParse());
        }
      }
      const body = slice.loadBit() ? slice.loadRef() : slice.asCell();
      return {
        info,
        init: init4,
        body
      };
    }
    exports.loadMessage = loadMessage;
    function storeMessage(message, opts) {
      return (builder) => {
        builder.store((0, CommonMessageInfo_1.storeCommonMessageInfo)(message.info));
        if (message.init) {
          builder.storeBit(true);
          let initCell = (0, Builder_1.beginCell)().store((0, StateInit_1.storeStateInit)(message.init));
          let needRef2 = false;
          if (opts && opts.forceRef) {
            needRef2 = true;
          } else if (builder.availableBits - 2 >= initCell.bits) {
            needRef2 = false;
          } else {
            needRef2 = true;
          }
          if (needRef2) {
            builder.storeBit(true);
            builder.storeRef(initCell);
          } else {
            builder.storeBit(false);
            builder.storeBuilder(initCell);
          }
        } else {
          builder.storeBit(false);
        }
        let needRef = false;
        if (opts && opts.forceRef) {
          needRef = true;
        } else {
          if (builder.availableBits - 1 >= message.body.bits.length && builder.refs + message.body.refs.length <= 4) {
            needRef = false;
          } else {
            needRef = true;
          }
        }
        if (needRef) {
          builder.storeBit(true);
          builder.storeRef(message.body);
        } else {
          builder.storeBit(false);
          builder.storeBuilder(message.body.asBuilder());
        }
      };
    }
    exports.storeMessage = storeMessage;
    exports.MessageValue = {
      serialize(src, builder) {
        builder.storeRef((0, Builder_1.beginCell)().store(storeMessage(src)));
      },
      parse(slice) {
        return loadMessage(slice.loadRef().beginParse());
      }
    };
  }
});

// node_modules/ton-core/dist/types/MessageRelaxed.js
var require_MessageRelaxed = __commonJS({
  "node_modules/ton-core/dist/types/MessageRelaxed.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeMessageRelaxed = exports.loadMessageRelaxed = void 0;
    var Builder_1 = require_Builder();
    var CommonMessageInfoRelaxed_1 = require_CommonMessageInfoRelaxed();
    var StateInit_1 = require_StateInit();
    function loadMessageRelaxed(slice) {
      const info = (0, CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed)(slice);
      let init4 = null;
      if (slice.loadBit()) {
        if (!slice.loadBit()) {
          init4 = (0, StateInit_1.loadStateInit)(slice);
        } else {
          init4 = (0, StateInit_1.loadStateInit)(slice.loadRef().beginParse());
        }
      }
      const body = slice.loadBit() ? slice.loadRef() : slice.asCell();
      return {
        info,
        init: init4,
        body
      };
    }
    exports.loadMessageRelaxed = loadMessageRelaxed;
    function storeMessageRelaxed(message, opts) {
      return (builder) => {
        builder.store((0, CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed)(message.info));
        if (message.init) {
          builder.storeBit(true);
          let initCell = (0, Builder_1.beginCell)().store((0, StateInit_1.storeStateInit)(message.init));
          let needRef2 = false;
          if (opts && opts.forceRef) {
            needRef2 = true;
          } else {
            if (builder.availableBits - 2 >= initCell.bits) {
              needRef2 = false;
            } else {
              needRef2 = true;
            }
          }
          if (needRef2) {
            builder.storeBit(true);
            builder.storeRef(initCell);
          } else {
            builder.storeBit(false);
            builder.storeBuilder(initCell);
          }
        } else {
          builder.storeBit(false);
        }
        let needRef = false;
        if (opts && opts.forceRef) {
          needRef = true;
        } else {
          if (builder.availableBits - 1 >= message.body.bits.length && builder.refs + message.body.refs.length <= 4) {
            needRef = false;
          } else {
            needRef = true;
          }
        }
        if (needRef) {
          builder.storeBit(true);
          builder.storeRef(message.body);
        } else {
          builder.storeBit(false);
          builder.storeBuilder(message.body.asBuilder());
        }
      };
    }
    exports.storeMessageRelaxed = storeMessageRelaxed;
  }
});

// node_modules/ton-core/dist/types/SendMode.js
var require_SendMode = __commonJS({
  "node_modules/ton-core/dist/types/SendMode.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SendMode = void 0;
    var SendMode;
    (function(SendMode2) {
      SendMode2[SendMode2["CARRY_ALL_REMAINING_BALANCE"] = 128] = "CARRY_ALL_REMAINING_BALANCE";
      SendMode2[SendMode2["CARRY_ALL_REMAINING_INCOMING_VALUE"] = 64] = "CARRY_ALL_REMAINING_INCOMING_VALUE";
      SendMode2[SendMode2["DESTROY_ACCOUNT_IF_ZERO"] = 32] = "DESTROY_ACCOUNT_IF_ZERO";
      SendMode2[SendMode2["PAY_GAS_SEPARATELY"] = 1] = "PAY_GAS_SEPARATELY";
      SendMode2[SendMode2["IGNORE_ERRORS"] = 2] = "IGNORE_ERRORS";
      SendMode2[SendMode2["NONE"] = 0] = "NONE";
    })(SendMode = exports.SendMode || (exports.SendMode = {}));
  }
});

// node_modules/ton-core/dist/types/ShardAccount.js
var require_ShardAccount = __commonJS({
  "node_modules/ton-core/dist/types/ShardAccount.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeShardAccount = exports.loadShardAccount = void 0;
    var Builder_1 = require_Builder();
    var Account_1 = require_Account();
    function loadShardAccount(slice) {
      let accountRef = slice.loadRef();
      let account = void 0;
      if (!accountRef.isExotic) {
        let accountSlice = accountRef.beginParse();
        if (accountSlice.loadBit()) {
          account = (0, Account_1.loadAccount)(accountSlice);
        }
      }
      return {
        account,
        lastTransactionHash: slice.loadUintBig(256),
        lastTransactionLt: slice.loadUintBig(64)
      };
    }
    exports.loadShardAccount = loadShardAccount;
    function storeShardAccount(src) {
      return (builder) => {
        if (src.account) {
          builder.storeRef((0, Builder_1.beginCell)().storeBit(true).store((0, Account_1.storeAccount)(src.account)));
        } else {
          builder.storeRef((0, Builder_1.beginCell)().storeBit(false));
        }
        builder.storeUint(src.lastTransactionHash, 256);
        builder.storeUint(src.lastTransactionLt, 64);
      };
    }
    exports.storeShardAccount = storeShardAccount;
  }
});

// node_modules/ton-core/dist/types/ShardAccounts.js
var require_ShardAccounts = __commonJS({
  "node_modules/ton-core/dist/types/ShardAccounts.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeShardAccounts = exports.loadShardAccounts = exports.ShardAccountRefValue = void 0;
    var Dictionary_1 = require_Dictionary();
    var DepthBalanceInfo_1 = require_DepthBalanceInfo();
    var ShardAccount_1 = require_ShardAccount();
    exports.ShardAccountRefValue = {
      parse: (cs) => {
        let depthBalanceInfo = (0, DepthBalanceInfo_1.loadDepthBalanceInfo)(cs);
        let shardAccount = (0, ShardAccount_1.loadShardAccount)(cs);
        return {
          depthBalanceInfo,
          shardAccount
        };
      },
      serialize(src, builder) {
        builder.store((0, DepthBalanceInfo_1.storeDepthBalanceInfo)(src.depthBalanceInfo));
        builder.store((0, ShardAccount_1.storeShardAccount)(src.shardAccount));
      }
    };
    function loadShardAccounts(cs) {
      return Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.BigUint(256), exports.ShardAccountRefValue, cs);
    }
    exports.loadShardAccounts = loadShardAccounts;
    function storeShardAccounts(src) {
      return (Builder) => {
        Builder.storeDict(src);
      };
    }
    exports.storeShardAccounts = storeShardAccounts;
  }
});

// node_modules/ton-core/dist/types/ShardIdent.js
var require_ShardIdent = __commonJS({
  "node_modules/ton-core/dist/types/ShardIdent.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeShardIdent = exports.loadShardIdent = void 0;
    function loadShardIdent(slice) {
      if (slice.loadUint(2) !== 0) {
        throw Error("Invalid data");
      }
      return {
        shardPrefixBits: slice.loadUint(6),
        workchainId: slice.loadInt(32),
        shardPrefix: slice.loadUintBig(64)
      };
    }
    exports.loadShardIdent = loadShardIdent;
    function storeShardIdent(src) {
      return (builder) => {
        builder.storeUint(0, 2);
        builder.storeUint(src.shardPrefixBits, 6);
        builder.storeInt(src.workchainId, 32);
        builder.storeUint(src.shardPrefix, 64);
      };
    }
    exports.storeShardIdent = storeShardIdent;
  }
});

// node_modules/ton-core/dist/types/ShardStateUnsplit.js
var require_ShardStateUnsplit = __commonJS({
  "node_modules/ton-core/dist/types/ShardStateUnsplit.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadShardStateUnsplit = void 0;
    var MasterchainStateExtra_1 = require_MasterchainStateExtra();
    var ShardAccounts_1 = require_ShardAccounts();
    var ShardIdent_1 = require_ShardIdent();
    function loadShardStateUnsplit(cs) {
      if (cs.loadUint(32) !== 2418257890) {
        throw Error("Invalid data");
      }
      let globalId = cs.loadInt(32);
      let shardId = (0, ShardIdent_1.loadShardIdent)(cs);
      let seqno = cs.loadUint(32);
      let vertSeqNo = cs.loadUint(32);
      let genUtime = cs.loadUint(32);
      let genLt = cs.loadUintBig(64);
      let minRefMcSeqno = cs.loadUint(32);
      cs.loadRef();
      let beforeSplit = cs.loadBit();
      let shardAccountsRef = cs.loadRef();
      let accounts = void 0;
      if (!shardAccountsRef.isExotic) {
        accounts = (0, ShardAccounts_1.loadShardAccounts)(shardAccountsRef.beginParse());
      }
      cs.loadRef();
      let mcStateExtra = cs.loadBit();
      let extras = null;
      if (mcStateExtra) {
        let cell = cs.loadRef();
        if (!cell.isExotic) {
          extras = (0, MasterchainStateExtra_1.loadMasterchainStateExtra)(cell.beginParse());
        }
      }
      ;
      return {
        globalId,
        shardId,
        seqno,
        vertSeqNo,
        genUtime,
        genLt,
        minRefMcSeqno,
        beforeSplit,
        accounts,
        extras
      };
    }
    exports.loadShardStateUnsplit = loadShardStateUnsplit;
  }
});

// node_modules/ton-core/dist/types/SplitMergeInfo.js
var require_SplitMergeInfo = __commonJS({
  "node_modules/ton-core/dist/types/SplitMergeInfo.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeSplitMergeInfo = exports.loadSplitMergeInfo = void 0;
    function loadSplitMergeInfo(slice) {
      let currentShardPrefixLength = slice.loadUint(6);
      let accountSplitDepth = slice.loadUint(6);
      let thisAddress = slice.loadUintBig(256);
      let siblingAddress = slice.loadUintBig(256);
      return {
        currentShardPrefixLength,
        accountSplitDepth,
        thisAddress,
        siblingAddress
      };
    }
    exports.loadSplitMergeInfo = loadSplitMergeInfo;
    function storeSplitMergeInfo(src) {
      return (builder) => {
        builder.storeUint(src.currentShardPrefixLength, 6);
        builder.storeUint(src.accountSplitDepth, 6);
        builder.storeUint(src.thisAddress, 256);
        builder.storeUint(src.siblingAddress, 256);
      };
    }
    exports.storeSplitMergeInfo = storeSplitMergeInfo;
  }
});

// node_modules/ton-core/dist/types/StorageUsedShort.js
var require_StorageUsedShort = __commonJS({
  "node_modules/ton-core/dist/types/StorageUsedShort.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeStorageUsedShort = exports.loadStorageUsedShort = void 0;
    function loadStorageUsedShort(slice) {
      let cells = slice.loadVarUintBig(3);
      let bits = slice.loadVarUintBig(3);
      return {
        cells,
        bits
      };
    }
    exports.loadStorageUsedShort = loadStorageUsedShort;
    function storeStorageUsedShort(src) {
      return (builder) => {
        builder.storeVarUint(src.cells, 3);
        builder.storeVarUint(src.bits, 3);
      };
    }
    exports.storeStorageUsedShort = storeStorageUsedShort;
  }
});

// node_modules/ton-core/dist/types/TransactionActionPhase.js
var require_TransactionActionPhase = __commonJS({
  "node_modules/ton-core/dist/types/TransactionActionPhase.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeTransactionActionPhase = exports.loadTransactionActionPhase = void 0;
    var AccountStatusChange_1 = require_AccountStatusChange();
    var StorageUsedShort_1 = require_StorageUsedShort();
    function loadTransactionActionPhase(slice) {
      let success2 = slice.loadBit();
      let valid = slice.loadBit();
      let noFunds = slice.loadBit();
      let statusChange = (0, AccountStatusChange_1.loadAccountStatusChange)(slice);
      let totalFwdFees = slice.loadBit() ? slice.loadCoins() : void 0;
      let totalActionFees = slice.loadBit() ? slice.loadCoins() : void 0;
      let resultCode = slice.loadInt(32);
      let resultArg = slice.loadBit() ? slice.loadInt(32) : void 0;
      let totalActions = slice.loadUint(16);
      let specActions = slice.loadUint(16);
      let skippedActions = slice.loadUint(16);
      let messagesCreated = slice.loadUint(16);
      let actionListHash = slice.loadUintBig(256);
      let totalMessageSize = (0, StorageUsedShort_1.loadStorageUsedShort)(slice);
      return {
        success: success2,
        valid,
        noFunds,
        statusChange,
        totalFwdFees,
        totalActionFees,
        resultCode,
        resultArg,
        totalActions,
        specActions,
        skippedActions,
        messagesCreated,
        actionListHash,
        totalMessageSize
      };
    }
    exports.loadTransactionActionPhase = loadTransactionActionPhase;
    function storeTransactionActionPhase(src) {
      return (builder) => {
        builder.storeBit(src.success);
        builder.storeBit(src.valid);
        builder.storeBit(src.noFunds);
        builder.store((0, AccountStatusChange_1.storeAccountStatusChange)(src.statusChange));
        builder.storeMaybeCoins(src.totalFwdFees);
        builder.storeMaybeCoins(src.totalActionFees);
        builder.storeInt(src.resultCode, 32);
        builder.storeMaybeInt(src.resultArg, 32);
        builder.storeUint(src.totalActions, 16);
        builder.storeUint(src.specActions, 16);
        builder.storeUint(src.skippedActions, 16);
        builder.storeUint(src.messagesCreated, 16);
        builder.storeUint(src.actionListHash, 256);
        builder.store((0, StorageUsedShort_1.storeStorageUsedShort)(src.totalMessageSize));
      };
    }
    exports.storeTransactionActionPhase = storeTransactionActionPhase;
  }
});

// node_modules/ton-core/dist/types/TransactionBouncePhase.js
var require_TransactionBouncePhase = __commonJS({
  "node_modules/ton-core/dist/types/TransactionBouncePhase.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeTransactionBouncePhase = exports.loadTransactionBouncePhase = void 0;
    var StorageUsedShort_1 = require_StorageUsedShort();
    function loadTransactionBouncePhase(slice) {
      if (slice.loadBit()) {
        let messageSize = (0, StorageUsedShort_1.loadStorageUsedShort)(slice);
        let messageFees = slice.loadCoins();
        let forwardFees = slice.loadCoins();
        return {
          type: "ok",
          messageSize,
          messageFees,
          forwardFees
        };
      }
      if (slice.loadBit()) {
        let messageSize = (0, StorageUsedShort_1.loadStorageUsedShort)(slice);
        let requiredForwardFees = slice.loadCoins();
        return {
          type: "no-funds",
          messageSize,
          requiredForwardFees
        };
      }
      return {
        type: "negative-funds"
      };
    }
    exports.loadTransactionBouncePhase = loadTransactionBouncePhase;
    function storeTransactionBouncePhase(src) {
      return (builder) => {
        if (src.type === "ok") {
          builder.storeBit(true);
          builder.store((0, StorageUsedShort_1.storeStorageUsedShort)(src.messageSize));
          builder.storeCoins(src.messageFees);
          builder.storeCoins(src.forwardFees);
        } else if (src.type === "negative-funds") {
          builder.storeBit(false);
          builder.storeBit(false);
        } else if (src.type === "no-funds") {
          builder.storeBit(false);
          builder.storeBit(true);
          builder.store((0, StorageUsedShort_1.storeStorageUsedShort)(src.messageSize));
          builder.storeCoins(src.requiredForwardFees);
        } else {
          throw new Error("Invalid TransactionBouncePhase type");
        }
      };
    }
    exports.storeTransactionBouncePhase = storeTransactionBouncePhase;
  }
});

// node_modules/ton-core/dist/types/TransactionComputePhase.js
var require_TransactionComputePhase = __commonJS({
  "node_modules/ton-core/dist/types/TransactionComputePhase.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeTransactionComputePhase = exports.loadTransactionComputePhase = void 0;
    var Builder_1 = require_Builder();
    var ComputeSkipReason_1 = require_ComputeSkipReason();
    function loadTransactionComputePhase(slice) {
      if (!slice.loadBit()) {
        let reason = (0, ComputeSkipReason_1.loadComputeSkipReason)(slice);
        return {
          type: "skipped",
          reason
        };
      }
      let success2 = slice.loadBit();
      let messageStateUsed = slice.loadBit();
      let accountActivated = slice.loadBit();
      let gasFees = slice.loadCoins();
      const vmState = slice.loadRef().beginParse();
      let gasUsed = vmState.loadVarUintBig(3);
      let gasLimit = vmState.loadVarUintBig(3);
      let gasCredit = vmState.loadBit() ? vmState.loadVarUintBig(2) : void 0;
      let mode = vmState.loadUint(8);
      let exitCode = vmState.loadUint(32);
      let exitArg = vmState.loadBit() ? vmState.loadInt(32) : void 0;
      let vmSteps = vmState.loadUint(32);
      let vmInitStateHash = vmState.loadUintBig(256);
      let vmFinalStateHash = vmState.loadUintBig(256);
      return {
        type: "vm",
        success: success2,
        messageStateUsed,
        accountActivated,
        gasFees,
        gasUsed,
        gasLimit,
        gasCredit,
        mode,
        exitCode,
        exitArg,
        vmSteps,
        vmInitStateHash,
        vmFinalStateHash
      };
    }
    exports.loadTransactionComputePhase = loadTransactionComputePhase;
    function storeTransactionComputePhase(src) {
      return (builder) => {
        if (src.type === "skipped") {
          builder.storeBit(0);
          builder.store((0, ComputeSkipReason_1.storeComputeSkipReason)(src.reason));
          return;
        }
        builder.storeBit(1);
        builder.storeBit(src.success);
        builder.storeBit(src.messageStateUsed);
        builder.storeBit(src.accountActivated);
        builder.storeCoins(src.gasFees);
        builder.storeRef((0, Builder_1.beginCell)().storeVarUint(src.gasUsed, 3).storeVarUint(src.gasLimit, 3).store((b) => src.gasCredit !== void 0 && src.gasCredit !== null ? b.storeBit(1).storeVarUint(src.gasCredit, 2) : b.storeBit(0)).storeUint(src.mode, 8).storeUint(src.exitCode, 32).store((b) => src.exitArg !== void 0 && src.exitArg !== null ? b.storeBit(1).storeInt(src.exitArg, 32) : b.storeBit(0)).storeUint(src.vmSteps, 32).storeUint(src.vmInitStateHash, 256).storeUint(src.vmFinalStateHash, 256).endCell());
      };
    }
    exports.storeTransactionComputePhase = storeTransactionComputePhase;
  }
});

// node_modules/ton-core/dist/types/TransactionCreditPhase.js
var require_TransactionCreditPhase = __commonJS({
  "node_modules/ton-core/dist/types/TransactionCreditPhase.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeTransactionCreditPhase = exports.loadTransactionCreditPhase = void 0;
    var CurrencyCollection_1 = require_CurrencyCollection();
    function loadTransactionCreditPhase(slice) {
      const dueFeesColelcted = slice.loadBit() ? slice.loadCoins() : void 0;
      const credit = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
      return {
        dueFeesColelcted,
        credit
      };
    }
    exports.loadTransactionCreditPhase = loadTransactionCreditPhase;
    function storeTransactionCreditPhase(src) {
      return (builder) => {
        if (src.dueFeesColelcted === null || src.dueFeesColelcted === void 0) {
          builder.storeBit(false);
        } else {
          builder.storeBit(true);
          builder.storeCoins(src.dueFeesColelcted);
        }
        builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.credit));
      };
    }
    exports.storeTransactionCreditPhase = storeTransactionCreditPhase;
  }
});

// node_modules/ton-core/dist/types/TransactionStoragePhase.js
var require_TransactionStoragePhase = __commonJS({
  "node_modules/ton-core/dist/types/TransactionStoragePhase.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeTransactionsStoragePhase = exports.loadTransactionStoragePhase = void 0;
    var AccountStatusChange_1 = require_AccountStatusChange();
    function loadTransactionStoragePhase(slice) {
      const storageFeesCollected = slice.loadCoins();
      let storageFeesDue = void 0;
      if (slice.loadBit()) {
        storageFeesDue = slice.loadCoins();
      }
      const statusChange = (0, AccountStatusChange_1.loadAccountStatusChange)(slice);
      return {
        storageFeesCollected,
        storageFeesDue,
        statusChange
      };
    }
    exports.loadTransactionStoragePhase = loadTransactionStoragePhase;
    function storeTransactionsStoragePhase(src) {
      return (builder) => {
        builder.storeCoins(src.storageFeesCollected);
        if (src.storageFeesDue === null || src.storageFeesDue === void 0) {
          builder.storeBit(false);
        } else {
          builder.storeBit(true);
          builder.storeCoins(src.storageFeesDue);
        }
        builder.store((0, AccountStatusChange_1.storeAccountStatusChange)(src.statusChange));
      };
    }
    exports.storeTransactionsStoragePhase = storeTransactionsStoragePhase;
  }
});

// node_modules/ton-core/dist/types/TransactionDescription.js
var require_TransactionDescription = __commonJS({
  "node_modules/ton-core/dist/types/TransactionDescription.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeTransactionDescription = exports.loadTransactionDescription = void 0;
    var Builder_1 = require_Builder();
    var SplitMergeInfo_1 = require_SplitMergeInfo();
    var Transaction_1 = require_Transaction();
    var TransactionActionPhase_1 = require_TransactionActionPhase();
    var TransactionBouncePhase_1 = require_TransactionBouncePhase();
    var TransactionComputePhase_1 = require_TransactionComputePhase();
    var TransactionCreditPhase_1 = require_TransactionCreditPhase();
    var TransactionStoragePhase_1 = require_TransactionStoragePhase();
    function loadTransactionDescription(slice) {
      let type2 = slice.loadUint(4);
      if (type2 === 0) {
        const creditFirst = slice.loadBit();
        let storagePhase = void 0;
        if (slice.loadBit()) {
          storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
        }
        let creditPhase = void 0;
        if (slice.loadBit()) {
          creditPhase = (0, TransactionCreditPhase_1.loadTransactionCreditPhase)(slice);
        }
        let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
        let actionPhase = void 0;
        if (slice.loadBit()) {
          actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
        }
        let aborted = slice.loadBit();
        let bouncePhase = void 0;
        if (slice.loadBit()) {
          bouncePhase = (0, TransactionBouncePhase_1.loadTransactionBouncePhase)(slice);
        }
        const destroyed = slice.loadBit();
        return {
          type: "generic",
          creditFirst,
          storagePhase,
          creditPhase,
          computePhase,
          actionPhase,
          bouncePhase,
          aborted,
          destroyed
        };
      }
      if (type2 === 1) {
        return {
          type: "storage",
          storagePhase: (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice)
        };
      }
      if (type2 === 2 || type2 === 3) {
        const isTock = type2 === 3;
        let storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
        let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
        let actionPhase = void 0;
        if (slice.loadBit()) {
          actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
        }
        const aborted = slice.loadBit();
        const destroyed = slice.loadBit();
        return {
          type: "tick-tock",
          isTock,
          storagePhase,
          computePhase,
          actionPhase,
          aborted,
          destroyed
        };
      }
      if (type2 === 4) {
        let splitInfo = (0, SplitMergeInfo_1.loadSplitMergeInfo)(slice);
        let storagePhase = void 0;
        if (slice.loadBit()) {
          storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
        }
        let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
        let actionPhase = void 0;
        if (slice.loadBit()) {
          actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
        }
        const aborted = slice.loadBit();
        const destroyed = slice.loadBit();
        return {
          type: "split-prepare",
          splitInfo,
          storagePhase,
          computePhase,
          actionPhase,
          aborted,
          destroyed
        };
      }
      if (type2 === 5) {
        let splitInfo = (0, SplitMergeInfo_1.loadSplitMergeInfo)(slice);
        let prepareTransaction = (0, Transaction_1.loadTransaction)(slice.loadRef().beginParse());
        const installed = slice.loadBit();
        return {
          type: "split-install",
          splitInfo,
          prepareTransaction,
          installed
        };
      }
      throw Error(`Unsupported transaction description type ${type2}`);
    }
    exports.loadTransactionDescription = loadTransactionDescription;
    function storeTransactionDescription(src) {
      return (builder) => {
        if (src.type === "generic") {
          builder.storeUint(0, 4);
          builder.storeBit(src.creditFirst);
          if (src.storagePhase) {
            builder.storeBit(true);
            builder.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
          } else {
            builder.storeBit(false);
          }
          if (src.creditPhase) {
            builder.storeBit(true);
            builder.store((0, TransactionCreditPhase_1.storeTransactionCreditPhase)(src.creditPhase));
          } else {
            builder.storeBit(false);
          }
          builder.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
          if (src.actionPhase) {
            builder.storeBit(true);
            builder.storeRef((0, Builder_1.beginCell)().store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase)));
          } else {
            builder.storeBit(false);
          }
          builder.storeBit(src.aborted);
          if (src.bouncePhase) {
            builder.storeBit(true);
            builder.store((0, TransactionBouncePhase_1.storeTransactionBouncePhase)(src.bouncePhase));
          } else {
            builder.storeBit(false);
          }
          builder.storeBit(src.destroyed);
        } else if (src.type === "storage") {
          builder.storeUint(1, 4);
          builder.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
        } else if (src.type === "tick-tock") {
          builder.storeUint(src.isTock ? 3 : 2, 4);
          builder.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
          builder.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
          if (src.actionPhase) {
            builder.storeBit(true);
            builder.storeRef((0, Builder_1.beginCell)().store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase)));
          } else {
            builder.storeBit(false);
          }
          builder.storeBit(src.aborted);
          builder.storeBit(src.destroyed);
        } else if (src.type === "split-prepare") {
          builder.storeUint(4, 4);
          builder.store((0, SplitMergeInfo_1.storeSplitMergeInfo)(src.splitInfo));
          if (src.storagePhase) {
            builder.storeBit(true);
            builder.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
          } else {
            builder.storeBit(false);
          }
          builder.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
          if (src.actionPhase) {
            builder.storeBit(true);
            builder.store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase));
          } else {
            builder.storeBit(false);
          }
          builder.storeBit(src.aborted);
          builder.storeBit(src.destroyed);
        } else if (src.type === "split-install") {
          builder.storeUint(5, 4);
          builder.store((0, SplitMergeInfo_1.storeSplitMergeInfo)(src.splitInfo));
          builder.storeRef((0, Builder_1.beginCell)().store((0, Transaction_1.storeTransaction)(src.prepareTransaction)));
          builder.storeBit(src.installed);
        } else {
          throw Error(`Unsupported transaction description type ${src.type}`);
        }
      };
    }
    exports.storeTransactionDescription = storeTransactionDescription;
  }
});

// node_modules/ton-core/dist/types/Transaction.js
var require_Transaction = __commonJS({
  "node_modules/ton-core/dist/types/Transaction.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeTransaction = exports.loadTransaction = void 0;
    var Builder_1 = require_Builder();
    var Dictionary_1 = require_Dictionary();
    var AccountStatus_1 = require_AccountStatus();
    var CurrencyCollection_1 = require_CurrencyCollection();
    var HashUpdate_1 = require_HashUpdate();
    var Message_1 = require_Message();
    var TransactionDescription_1 = require_TransactionDescription();
    function loadTransaction(slice) {
      if (slice.loadUint(4) !== 7) {
        throw Error("Invalid data");
      }
      let address = slice.loadUintBig(256);
      let lt = slice.loadUintBig(64);
      let prevTransactionHash = slice.loadUintBig(256);
      let prevTransactionLt = slice.loadUintBig(64);
      let now = slice.loadUint(32);
      let outMessagesCount = slice.loadUint(15);
      let oldStatus = (0, AccountStatus_1.loadAccountStatus)(slice);
      let endStatus = (0, AccountStatus_1.loadAccountStatus)(slice);
      let msgRef = slice.loadRef();
      let msgSlice = msgRef.beginParse();
      let inMessage = msgSlice.loadBit() ? (0, Message_1.loadMessage)(msgSlice.loadRef().beginParse()) : void 0;
      let outMessages = msgSlice.loadDict(Dictionary_1.Dictionary.Keys.Uint(15), Message_1.MessageValue);
      msgSlice.endParse();
      let totalFees = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
      let stateUpdate = (0, HashUpdate_1.loadHashUpdate)(slice.loadRef().beginParse());
      let description = (0, TransactionDescription_1.loadTransactionDescription)(slice.loadRef().beginParse());
      return {
        address,
        lt,
        prevTransactionHash,
        prevTransactionLt,
        now,
        outMessagesCount,
        oldStatus,
        endStatus,
        inMessage,
        outMessages,
        totalFees,
        stateUpdate,
        description
      };
    }
    exports.loadTransaction = loadTransaction;
    function storeTransaction(src) {
      return (builder) => {
        builder.storeUint(7, 4);
        builder.storeUint(src.address, 256);
        builder.storeUint(src.lt, 64);
        builder.storeUint(src.prevTransactionHash, 256);
        builder.storeUint(src.prevTransactionLt, 64);
        builder.storeUint(src.now, 32);
        builder.storeUint(src.outMessagesCount, 15);
        builder.store((0, AccountStatus_1.storeAccountStatus)(src.oldStatus));
        builder.store((0, AccountStatus_1.storeAccountStatus)(src.endStatus));
        let msgBuilder = (0, Builder_1.beginCell)();
        if (src.inMessage) {
          msgBuilder.storeBit(true);
          msgBuilder.storeRef((0, Builder_1.beginCell)().store((0, Message_1.storeMessage)(src.inMessage)));
        } else {
          msgBuilder.storeBit(false);
        }
        msgBuilder.storeDict(src.outMessages);
        builder.storeRef(msgBuilder);
        builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.totalFees));
        builder.storeRef((0, Builder_1.beginCell)().store((0, HashUpdate_1.storeHashUpdate)(src.stateUpdate)));
        builder.storeRef((0, Builder_1.beginCell)().store((0, TransactionDescription_1.storeTransactionDescription)(src.description)));
      };
    }
    exports.storeTransaction = storeTransaction;
  }
});

// node_modules/ton-core/dist/types/_export.js
var require_export = __commonJS({
  "node_modules/ton-core/dist/types/_export.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadStorageUsedShort = exports.storeStorageUsed = exports.loadStorageUsed = exports.storeStorageInfo = exports.loadStorageInfo = exports.storeStateInit = exports.loadStateInit = exports.storeSplitMergeInfo = exports.loadSplitMergeInfo = exports.storeSimpleLibrary = exports.loadSimpleLibrary = exports.loadShardStateUnsplit = exports.storeShardIdent = exports.loadShardIdent = exports.storeShardAccounts = exports.loadShardAccounts = exports.ShardAccountRefValue = exports.storeShardAccount = exports.loadShardAccount = exports.SendMode = exports.storeMessageRelaxed = exports.loadMessageRelaxed = exports.storeMessage = exports.loadMessage = exports.loadMasterchainStateExtra = exports.storeHashUpdate = exports.loadHashUpdate = exports.storeDepthBalanceInfo = exports.loadDepthBalanceInfo = exports.storeCurrencyCollection = exports.loadCurrencyCollection = exports.storeComputeSkipReason = exports.loadComputeSkipReason = exports.storeCommonMessageInfoRelaxed = exports.loadCommonMessageInfoRelaxed = exports.storeCommonMessageInfo = exports.loadCommonMessageInfo = exports.storeAccountStorage = exports.loadAccountStorage = exports.storeAccountStatusChange = exports.loadAccountStatusChange = exports.storeAccountStatus = exports.loadAccountStatus = exports.storeAccountState = exports.loadAccountState = exports.storeAccount = exports.loadAccount = exports.comment = exports.external = exports.internal = void 0;
    exports.storeTransactionsStoragePhase = exports.loadTransactionStoragePhase = exports.storeTransactionDescription = exports.loadTransactionDescription = exports.storeTransactionCreditPhase = exports.loadTransactionCreditPhase = exports.storeTransactionComputePhase = exports.loadTransactionComputePhase = exports.storeTransactionBouncePhase = exports.loadTransactionBouncePhase = exports.storeTransactionActionPhase = exports.loadTransactionActionPhase = exports.storeTransaction = exports.loadTransaction = exports.storeTickTock = exports.loadTickTock = exports.storeStorageUsedShort = void 0;
    var _helpers_1 = require_helpers();
    Object.defineProperty(exports, "internal", { enumerable: true, get: function() {
      return _helpers_1.internal;
    } });
    Object.defineProperty(exports, "external", { enumerable: true, get: function() {
      return _helpers_1.external;
    } });
    Object.defineProperty(exports, "comment", { enumerable: true, get: function() {
      return _helpers_1.comment;
    } });
    var Account_1 = require_Account();
    Object.defineProperty(exports, "loadAccount", { enumerable: true, get: function() {
      return Account_1.loadAccount;
    } });
    Object.defineProperty(exports, "storeAccount", { enumerable: true, get: function() {
      return Account_1.storeAccount;
    } });
    var AccountState_1 = require_AccountState();
    Object.defineProperty(exports, "loadAccountState", { enumerable: true, get: function() {
      return AccountState_1.loadAccountState;
    } });
    Object.defineProperty(exports, "storeAccountState", { enumerable: true, get: function() {
      return AccountState_1.storeAccountState;
    } });
    var AccountStatus_1 = require_AccountStatus();
    Object.defineProperty(exports, "loadAccountStatus", { enumerable: true, get: function() {
      return AccountStatus_1.loadAccountStatus;
    } });
    Object.defineProperty(exports, "storeAccountStatus", { enumerable: true, get: function() {
      return AccountStatus_1.storeAccountStatus;
    } });
    var AccountStatusChange_1 = require_AccountStatusChange();
    Object.defineProperty(exports, "loadAccountStatusChange", { enumerable: true, get: function() {
      return AccountStatusChange_1.loadAccountStatusChange;
    } });
    Object.defineProperty(exports, "storeAccountStatusChange", { enumerable: true, get: function() {
      return AccountStatusChange_1.storeAccountStatusChange;
    } });
    var AccountStorage_1 = require_AccountStorage();
    Object.defineProperty(exports, "loadAccountStorage", { enumerable: true, get: function() {
      return AccountStorage_1.loadAccountStorage;
    } });
    Object.defineProperty(exports, "storeAccountStorage", { enumerable: true, get: function() {
      return AccountStorage_1.storeAccountStorage;
    } });
    var CommonMessageInfo_1 = require_CommonMessageInfo();
    Object.defineProperty(exports, "loadCommonMessageInfo", { enumerable: true, get: function() {
      return CommonMessageInfo_1.loadCommonMessageInfo;
    } });
    Object.defineProperty(exports, "storeCommonMessageInfo", { enumerable: true, get: function() {
      return CommonMessageInfo_1.storeCommonMessageInfo;
    } });
    var CommonMessageInfoRelaxed_1 = require_CommonMessageInfoRelaxed();
    Object.defineProperty(exports, "loadCommonMessageInfoRelaxed", { enumerable: true, get: function() {
      return CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed;
    } });
    Object.defineProperty(exports, "storeCommonMessageInfoRelaxed", { enumerable: true, get: function() {
      return CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed;
    } });
    var ComputeSkipReason_1 = require_ComputeSkipReason();
    Object.defineProperty(exports, "loadComputeSkipReason", { enumerable: true, get: function() {
      return ComputeSkipReason_1.loadComputeSkipReason;
    } });
    Object.defineProperty(exports, "storeComputeSkipReason", { enumerable: true, get: function() {
      return ComputeSkipReason_1.storeComputeSkipReason;
    } });
    var CurrencyCollection_1 = require_CurrencyCollection();
    Object.defineProperty(exports, "loadCurrencyCollection", { enumerable: true, get: function() {
      return CurrencyCollection_1.loadCurrencyCollection;
    } });
    Object.defineProperty(exports, "storeCurrencyCollection", { enumerable: true, get: function() {
      return CurrencyCollection_1.storeCurrencyCollection;
    } });
    var DepthBalanceInfo_1 = require_DepthBalanceInfo();
    Object.defineProperty(exports, "loadDepthBalanceInfo", { enumerable: true, get: function() {
      return DepthBalanceInfo_1.loadDepthBalanceInfo;
    } });
    Object.defineProperty(exports, "storeDepthBalanceInfo", { enumerable: true, get: function() {
      return DepthBalanceInfo_1.storeDepthBalanceInfo;
    } });
    var HashUpdate_1 = require_HashUpdate();
    Object.defineProperty(exports, "loadHashUpdate", { enumerable: true, get: function() {
      return HashUpdate_1.loadHashUpdate;
    } });
    Object.defineProperty(exports, "storeHashUpdate", { enumerable: true, get: function() {
      return HashUpdate_1.storeHashUpdate;
    } });
    var MasterchainStateExtra_1 = require_MasterchainStateExtra();
    Object.defineProperty(exports, "loadMasterchainStateExtra", { enumerable: true, get: function() {
      return MasterchainStateExtra_1.loadMasterchainStateExtra;
    } });
    var Message_1 = require_Message();
    Object.defineProperty(exports, "loadMessage", { enumerable: true, get: function() {
      return Message_1.loadMessage;
    } });
    Object.defineProperty(exports, "storeMessage", { enumerable: true, get: function() {
      return Message_1.storeMessage;
    } });
    var MessageRelaxed_1 = require_MessageRelaxed();
    Object.defineProperty(exports, "loadMessageRelaxed", { enumerable: true, get: function() {
      return MessageRelaxed_1.loadMessageRelaxed;
    } });
    Object.defineProperty(exports, "storeMessageRelaxed", { enumerable: true, get: function() {
      return MessageRelaxed_1.storeMessageRelaxed;
    } });
    var SendMode_1 = require_SendMode();
    Object.defineProperty(exports, "SendMode", { enumerable: true, get: function() {
      return SendMode_1.SendMode;
    } });
    var ShardAccount_1 = require_ShardAccount();
    Object.defineProperty(exports, "loadShardAccount", { enumerable: true, get: function() {
      return ShardAccount_1.loadShardAccount;
    } });
    Object.defineProperty(exports, "storeShardAccount", { enumerable: true, get: function() {
      return ShardAccount_1.storeShardAccount;
    } });
    var ShardAccounts_1 = require_ShardAccounts();
    Object.defineProperty(exports, "ShardAccountRefValue", { enumerable: true, get: function() {
      return ShardAccounts_1.ShardAccountRefValue;
    } });
    Object.defineProperty(exports, "loadShardAccounts", { enumerable: true, get: function() {
      return ShardAccounts_1.loadShardAccounts;
    } });
    Object.defineProperty(exports, "storeShardAccounts", { enumerable: true, get: function() {
      return ShardAccounts_1.storeShardAccounts;
    } });
    var ShardIdent_1 = require_ShardIdent();
    Object.defineProperty(exports, "loadShardIdent", { enumerable: true, get: function() {
      return ShardIdent_1.loadShardIdent;
    } });
    Object.defineProperty(exports, "storeShardIdent", { enumerable: true, get: function() {
      return ShardIdent_1.storeShardIdent;
    } });
    var ShardStateUnsplit_1 = require_ShardStateUnsplit();
    Object.defineProperty(exports, "loadShardStateUnsplit", { enumerable: true, get: function() {
      return ShardStateUnsplit_1.loadShardStateUnsplit;
    } });
    var SimpleLibrary_1 = require_SimpleLibrary();
    Object.defineProperty(exports, "loadSimpleLibrary", { enumerable: true, get: function() {
      return SimpleLibrary_1.loadSimpleLibrary;
    } });
    Object.defineProperty(exports, "storeSimpleLibrary", { enumerable: true, get: function() {
      return SimpleLibrary_1.storeSimpleLibrary;
    } });
    var SplitMergeInfo_1 = require_SplitMergeInfo();
    Object.defineProperty(exports, "loadSplitMergeInfo", { enumerable: true, get: function() {
      return SplitMergeInfo_1.loadSplitMergeInfo;
    } });
    Object.defineProperty(exports, "storeSplitMergeInfo", { enumerable: true, get: function() {
      return SplitMergeInfo_1.storeSplitMergeInfo;
    } });
    var StateInit_1 = require_StateInit();
    Object.defineProperty(exports, "loadStateInit", { enumerable: true, get: function() {
      return StateInit_1.loadStateInit;
    } });
    Object.defineProperty(exports, "storeStateInit", { enumerable: true, get: function() {
      return StateInit_1.storeStateInit;
    } });
    var StorageInto_1 = require_StorageInto();
    Object.defineProperty(exports, "loadStorageInfo", { enumerable: true, get: function() {
      return StorageInto_1.loadStorageInfo;
    } });
    Object.defineProperty(exports, "storeStorageInfo", { enumerable: true, get: function() {
      return StorageInto_1.storeStorageInfo;
    } });
    var StorageUsed_1 = require_StorageUsed();
    Object.defineProperty(exports, "loadStorageUsed", { enumerable: true, get: function() {
      return StorageUsed_1.loadStorageUsed;
    } });
    Object.defineProperty(exports, "storeStorageUsed", { enumerable: true, get: function() {
      return StorageUsed_1.storeStorageUsed;
    } });
    var StorageUsedShort_1 = require_StorageUsedShort();
    Object.defineProperty(exports, "loadStorageUsedShort", { enumerable: true, get: function() {
      return StorageUsedShort_1.loadStorageUsedShort;
    } });
    Object.defineProperty(exports, "storeStorageUsedShort", { enumerable: true, get: function() {
      return StorageUsedShort_1.storeStorageUsedShort;
    } });
    var TickTock_1 = require_TickTock();
    Object.defineProperty(exports, "loadTickTock", { enumerable: true, get: function() {
      return TickTock_1.loadTickTock;
    } });
    Object.defineProperty(exports, "storeTickTock", { enumerable: true, get: function() {
      return TickTock_1.storeTickTock;
    } });
    var Transaction_1 = require_Transaction();
    Object.defineProperty(exports, "loadTransaction", { enumerable: true, get: function() {
      return Transaction_1.loadTransaction;
    } });
    Object.defineProperty(exports, "storeTransaction", { enumerable: true, get: function() {
      return Transaction_1.storeTransaction;
    } });
    var TransactionActionPhase_1 = require_TransactionActionPhase();
    Object.defineProperty(exports, "loadTransactionActionPhase", { enumerable: true, get: function() {
      return TransactionActionPhase_1.loadTransactionActionPhase;
    } });
    Object.defineProperty(exports, "storeTransactionActionPhase", { enumerable: true, get: function() {
      return TransactionActionPhase_1.storeTransactionActionPhase;
    } });
    var TransactionBouncePhase_1 = require_TransactionBouncePhase();
    Object.defineProperty(exports, "loadTransactionBouncePhase", { enumerable: true, get: function() {
      return TransactionBouncePhase_1.loadTransactionBouncePhase;
    } });
    Object.defineProperty(exports, "storeTransactionBouncePhase", { enumerable: true, get: function() {
      return TransactionBouncePhase_1.storeTransactionBouncePhase;
    } });
    var TransactionComputePhase_1 = require_TransactionComputePhase();
    Object.defineProperty(exports, "loadTransactionComputePhase", { enumerable: true, get: function() {
      return TransactionComputePhase_1.loadTransactionComputePhase;
    } });
    Object.defineProperty(exports, "storeTransactionComputePhase", { enumerable: true, get: function() {
      return TransactionComputePhase_1.storeTransactionComputePhase;
    } });
    var TransactionCreditPhase_1 = require_TransactionCreditPhase();
    Object.defineProperty(exports, "loadTransactionCreditPhase", { enumerable: true, get: function() {
      return TransactionCreditPhase_1.loadTransactionCreditPhase;
    } });
    Object.defineProperty(exports, "storeTransactionCreditPhase", { enumerable: true, get: function() {
      return TransactionCreditPhase_1.storeTransactionCreditPhase;
    } });
    var TransactionDescription_1 = require_TransactionDescription();
    Object.defineProperty(exports, "loadTransactionDescription", { enumerable: true, get: function() {
      return TransactionDescription_1.loadTransactionDescription;
    } });
    Object.defineProperty(exports, "storeTransactionDescription", { enumerable: true, get: function() {
      return TransactionDescription_1.storeTransactionDescription;
    } });
    var TransactionStoragePhase_1 = require_TransactionStoragePhase();
    Object.defineProperty(exports, "loadTransactionStoragePhase", { enumerable: true, get: function() {
      return TransactionStoragePhase_1.loadTransactionStoragePhase;
    } });
    Object.defineProperty(exports, "storeTransactionsStoragePhase", { enumerable: true, get: function() {
      return TransactionStoragePhase_1.storeTransactionsStoragePhase;
    } });
  }
});

// node_modules/ton-core/dist/contract/openContract.js
var require_openContract = __commonJS({
  "node_modules/ton-core/dist/contract/openContract.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.openContract = void 0;
    var Address_1 = require_Address();
    var Cell_1 = require_Cell();
    function openContract(src, factory) {
      let address;
      let init4 = null;
      if (!Address_1.Address.isAddress(src.address)) {
        throw Error("Invalid address");
      }
      address = src.address;
      if (src.init) {
        if (!(src.init.code instanceof Cell_1.Cell)) {
          throw Error("Invalid init.code");
        }
        if (!(src.init.data instanceof Cell_1.Cell)) {
          throw Error("Invalid init.data");
        }
        init4 = src.init;
      }
      let executor = factory({ address, init: init4 });
      return new Proxy(src, {
        get(target, prop) {
          const value = target[prop];
          if (typeof prop === "string" && (prop.startsWith("get") || prop.startsWith("send"))) {
            if (typeof value === "function") {
              return (...args) => value.apply(target, [executor, ...args]);
            }
          }
          return value;
        }
      });
    }
    exports.openContract = openContract;
  }
});

// node_modules/ton-core/dist/contract/ComputeError.js
var require_ComputeError = __commonJS({
  "node_modules/ton-core/dist/contract/ComputeError.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ComputeError = void 0;
    var ComputeError = class extends Error {
      constructor(message, exitCode, opts) {
        super(message);
        this.exitCode = exitCode;
        this.debugLogs = opts && opts.debugLogs ? opts.debugLogs : null;
        this.logs = opts && opts.logs ? opts.logs : null;
        Object.setPrototypeOf(this, ComputeError.prototype);
      }
    };
    exports.ComputeError = ComputeError;
  }
});

// node_modules/ton-core/dist/utils/getMethodId.js
var require_getMethodId = __commonJS({
  "node_modules/ton-core/dist/utils/getMethodId.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMethodId = void 0;
    var TABLE = new Int16Array([
      0,
      4129,
      8258,
      12387,
      16516,
      20645,
      24774,
      28903,
      33032,
      37161,
      41290,
      45419,
      49548,
      53677,
      57806,
      61935,
      4657,
      528,
      12915,
      8786,
      21173,
      17044,
      29431,
      25302,
      37689,
      33560,
      45947,
      41818,
      54205,
      50076,
      62463,
      58334,
      9314,
      13379,
      1056,
      5121,
      25830,
      29895,
      17572,
      21637,
      42346,
      46411,
      34088,
      38153,
      58862,
      62927,
      50604,
      54669,
      13907,
      9842,
      5649,
      1584,
      30423,
      26358,
      22165,
      18100,
      46939,
      42874,
      38681,
      34616,
      63455,
      59390,
      55197,
      51132,
      18628,
      22757,
      26758,
      30887,
      2112,
      6241,
      10242,
      14371,
      51660,
      55789,
      59790,
      63919,
      35144,
      39273,
      43274,
      47403,
      23285,
      19156,
      31415,
      27286,
      6769,
      2640,
      14899,
      10770,
      56317,
      52188,
      64447,
      60318,
      39801,
      35672,
      47931,
      43802,
      27814,
      31879,
      19684,
      23749,
      11298,
      15363,
      3168,
      7233,
      60846,
      64911,
      52716,
      56781,
      44330,
      48395,
      36200,
      40265,
      32407,
      28342,
      24277,
      20212,
      15891,
      11826,
      7761,
      3696,
      65439,
      61374,
      57309,
      53244,
      48923,
      44858,
      40793,
      36728,
      37256,
      33193,
      45514,
      41451,
      53516,
      49453,
      61774,
      57711,
      4224,
      161,
      12482,
      8419,
      20484,
      16421,
      28742,
      24679,
      33721,
      37784,
      41979,
      46042,
      49981,
      54044,
      58239,
      62302,
      689,
      4752,
      8947,
      13010,
      16949,
      21012,
      25207,
      29270,
      46570,
      42443,
      38312,
      34185,
      62830,
      58703,
      54572,
      50445,
      13538,
      9411,
      5280,
      1153,
      29798,
      25671,
      21540,
      17413,
      42971,
      47098,
      34713,
      38840,
      59231,
      63358,
      50973,
      55100,
      9939,
      14066,
      1681,
      5808,
      26199,
      30326,
      17941,
      22068,
      55628,
      51565,
      63758,
      59695,
      39368,
      35305,
      47498,
      43435,
      22596,
      18533,
      30726,
      26663,
      6336,
      2273,
      14466,
      10403,
      52093,
      56156,
      60223,
      64286,
      35833,
      39896,
      43963,
      48026,
      19061,
      23124,
      27191,
      31254,
      2801,
      6864,
      10931,
      14994,
      64814,
      60687,
      56684,
      52557,
      48554,
      44427,
      40424,
      36297,
      31782,
      27655,
      23652,
      19525,
      15522,
      11395,
      7392,
      3265,
      61215,
      65342,
      53085,
      57212,
      44955,
      49082,
      36825,
      40952,
      28183,
      32310,
      20053,
      24180,
      11923,
      16050,
      3793,
      7920
    ]);
    function crc16(data) {
      if (!(data instanceof import_buffer.Buffer)) {
        data = import_buffer.Buffer.from(data);
      }
      let crc = 0;
      for (let index = 0; index < data.length; index++) {
        const byte = data[index];
        crc = (TABLE[(crc >> 8 ^ byte) & 255] ^ crc << 8) & 65535;
      }
      return crc;
    }
    function getMethodId(name) {
      return crc16(name) & 65535 | 65536;
    }
    exports.getMethodId = getMethodId;
  }
});

// node_modules/ton-core/dist/crypto/safeSign.js
var require_safeSign = __commonJS({
  "node_modules/ton-core/dist/crypto/safeSign.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.safeSignVerify = exports.safeSign = void 0;
    var ton_crypto_1 = require_dist();
    var MIN_SEED_LENGTH = 8;
    var MAX_SEED_LENGTH = 64;
    function createSafeSignHash(cell, seed) {
      let seedData = import_buffer.Buffer.from(seed);
      if (seedData.length > MAX_SEED_LENGTH) {
        throw Error("Seed can	 be longer than 64 bytes");
      }
      if (seedData.length < MIN_SEED_LENGTH) {
        throw Error("Seed must be at least 8 bytes");
      }
      return (0, ton_crypto_1.sha256_sync)(import_buffer.Buffer.concat([import_buffer.Buffer.from([255, 255]), seedData, cell.hash()]));
    }
    function safeSign(cell, secretKey, seed = "ton-safe-sign-magic") {
      return (0, ton_crypto_1.sign)(createSafeSignHash(cell, seed), secretKey);
    }
    exports.safeSign = safeSign;
    function safeSignVerify(cell, signature, publicKey, seed = "ton-safe-sign-magic") {
      return (0, ton_crypto_1.signVerify)(createSafeSignHash(cell, seed), signature, publicKey);
    }
    exports.safeSignVerify = safeSignVerify;
  }
});

// node_modules/ton-core/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/ton-core/dist/index.js"(exports) {
    "use strict";
    init_shim();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.safeSignVerify = exports.safeSign = exports.getMethodId = exports.base32Encode = exports.base32Decode = exports.crc32c = exports.crc16 = exports.fromNano = exports.toNano = exports.ComputeError = exports.openContract = exports.TupleBuilder = exports.TupleReader = exports.serializeTuple = exports.parseTuple = exports.exoticPruned = exports.exoticMerkleUpdate = exports.exoticMerkleProof = exports.Dictionary = exports.Cell = exports.CellType = exports.Slice = exports.beginCell = exports.Builder = exports.BitBuilder = exports.BitReader = exports.BitString = exports.contractAddress = exports.ADNLAddress = exports.ExternalAddress = exports.address = exports.Address = void 0;
    var Address_1 = require_Address();
    Object.defineProperty(exports, "Address", { enumerable: true, get: function() {
      return Address_1.Address;
    } });
    Object.defineProperty(exports, "address", { enumerable: true, get: function() {
      return Address_1.address;
    } });
    var ExternalAddress_1 = require_ExternalAddress();
    Object.defineProperty(exports, "ExternalAddress", { enumerable: true, get: function() {
      return ExternalAddress_1.ExternalAddress;
    } });
    var ADNLAddress_1 = require_ADNLAddress();
    Object.defineProperty(exports, "ADNLAddress", { enumerable: true, get: function() {
      return ADNLAddress_1.ADNLAddress;
    } });
    var contractAddress_1 = require_contractAddress();
    Object.defineProperty(exports, "contractAddress", { enumerable: true, get: function() {
      return contractAddress_1.contractAddress;
    } });
    var BitString_1 = require_BitString();
    Object.defineProperty(exports, "BitString", { enumerable: true, get: function() {
      return BitString_1.BitString;
    } });
    var BitReader_1 = require_BitReader();
    Object.defineProperty(exports, "BitReader", { enumerable: true, get: function() {
      return BitReader_1.BitReader;
    } });
    var BitBuilder_1 = require_BitBuilder();
    Object.defineProperty(exports, "BitBuilder", { enumerable: true, get: function() {
      return BitBuilder_1.BitBuilder;
    } });
    var Builder_1 = require_Builder();
    Object.defineProperty(exports, "Builder", { enumerable: true, get: function() {
      return Builder_1.Builder;
    } });
    Object.defineProperty(exports, "beginCell", { enumerable: true, get: function() {
      return Builder_1.beginCell;
    } });
    var Slice_1 = require_Slice();
    Object.defineProperty(exports, "Slice", { enumerable: true, get: function() {
      return Slice_1.Slice;
    } });
    var CellType_1 = require_CellType();
    Object.defineProperty(exports, "CellType", { enumerable: true, get: function() {
      return CellType_1.CellType;
    } });
    var Cell_1 = require_Cell();
    Object.defineProperty(exports, "Cell", { enumerable: true, get: function() {
      return Cell_1.Cell;
    } });
    var Dictionary_1 = require_Dictionary();
    Object.defineProperty(exports, "Dictionary", { enumerable: true, get: function() {
      return Dictionary_1.Dictionary;
    } });
    var exoticMerkleProof_1 = require_exoticMerkleProof();
    Object.defineProperty(exports, "exoticMerkleProof", { enumerable: true, get: function() {
      return exoticMerkleProof_1.exoticMerkleProof;
    } });
    var exoticMerkleUpdate_1 = require_exoticMerkleUpdate();
    Object.defineProperty(exports, "exoticMerkleUpdate", { enumerable: true, get: function() {
      return exoticMerkleUpdate_1.exoticMerkleUpdate;
    } });
    var exoticPruned_1 = require_exoticPruned();
    Object.defineProperty(exports, "exoticPruned", { enumerable: true, get: function() {
      return exoticPruned_1.exoticPruned;
    } });
    var tuple_1 = require_tuple();
    Object.defineProperty(exports, "parseTuple", { enumerable: true, get: function() {
      return tuple_1.parseTuple;
    } });
    Object.defineProperty(exports, "serializeTuple", { enumerable: true, get: function() {
      return tuple_1.serializeTuple;
    } });
    var reader_1 = require_reader();
    Object.defineProperty(exports, "TupleReader", { enumerable: true, get: function() {
      return reader_1.TupleReader;
    } });
    var builder_1 = require_builder();
    Object.defineProperty(exports, "TupleBuilder", { enumerable: true, get: function() {
      return builder_1.TupleBuilder;
    } });
    __exportStar(require_export(), exports);
    var openContract_1 = require_openContract();
    Object.defineProperty(exports, "openContract", { enumerable: true, get: function() {
      return openContract_1.openContract;
    } });
    var ComputeError_1 = require_ComputeError();
    Object.defineProperty(exports, "ComputeError", { enumerable: true, get: function() {
      return ComputeError_1.ComputeError;
    } });
    var convert_1 = require_convert();
    Object.defineProperty(exports, "toNano", { enumerable: true, get: function() {
      return convert_1.toNano;
    } });
    Object.defineProperty(exports, "fromNano", { enumerable: true, get: function() {
      return convert_1.fromNano;
    } });
    var crc16_1 = require_crc16();
    Object.defineProperty(exports, "crc16", { enumerable: true, get: function() {
      return crc16_1.crc16;
    } });
    var crc32c_1 = require_crc32c();
    Object.defineProperty(exports, "crc32c", { enumerable: true, get: function() {
      return crc32c_1.crc32c;
    } });
    var base32_1 = require_base32();
    Object.defineProperty(exports, "base32Decode", { enumerable: true, get: function() {
      return base32_1.base32Decode;
    } });
    Object.defineProperty(exports, "base32Encode", { enumerable: true, get: function() {
      return base32_1.base32Encode;
    } });
    var getMethodId_1 = require_getMethodId();
    Object.defineProperty(exports, "getMethodId", { enumerable: true, get: function() {
      return getMethodId_1.getMethodId;
    } });
    var safeSign_1 = require_safeSign();
    Object.defineProperty(exports, "safeSign", { enumerable: true, get: function() {
      return safeSign_1.safeSign;
    } });
    Object.defineProperty(exports, "safeSignVerify", { enumerable: true, get: function() {
      return safeSign_1.safeSignVerify;
    } });
  }
});

// node_modules/fp-ts/es6/function.js
function identity(a) {
  return a;
}
function constant(a) {
  return function() {
    return a;
  };
}
function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
  switch (arguments.length) {
    case 1:
      return ab;
    case 2:
      return function() {
        return bc(ab.apply(this, arguments));
      };
    case 3:
      return function() {
        return cd(bc(ab.apply(this, arguments)));
      };
    case 4:
      return function() {
        return de(cd(bc(ab.apply(this, arguments))));
      };
    case 5:
      return function() {
        return ef(de(cd(bc(ab.apply(this, arguments)))));
      };
    case 6:
      return function() {
        return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
      };
    case 7:
      return function() {
        return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
      };
    case 8:
      return function() {
        return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
      };
    case 9:
      return function() {
        return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
      };
  }
  return;
}
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      var ret = arguments[0];
      for (var i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}
var constTrue, constFalse, constNull, constUndefined, SK;
var init_function = __esm({
  "node_modules/fp-ts/es6/function.js"() {
    init_shim();
    constTrue = constant(true);
    constFalse = constant(false);
    constNull = constant(null);
    constUndefined = constant(void 0);
    SK = function(_, b) {
      return b;
    };
  }
});

// node_modules/fp-ts/es6/internal.js
var __spreadArray, isNone, isSome, none, some, isLeft, isRight, left, right, singleton, isNonEmpty, head, tail, emptyReadonlyArray, emptyRecord, has, fromReadonlyNonEmptyArray;
var init_internal = __esm({
  "node_modules/fp-ts/es6/internal.js"() {
    init_shim();
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    isNone = function(fa) {
      return fa._tag === "None";
    };
    isSome = function(fa) {
      return fa._tag === "Some";
    };
    none = { _tag: "None" };
    some = function(a) {
      return { _tag: "Some", value: a };
    };
    isLeft = function(ma) {
      return ma._tag === "Left";
    };
    isRight = function(ma) {
      return ma._tag === "Right";
    };
    left = function(e) {
      return { _tag: "Left", left: e };
    };
    right = function(a) {
      return { _tag: "Right", right: a };
    };
    singleton = function(a) {
      return [a];
    };
    isNonEmpty = function(as) {
      return as.length > 0;
    };
    head = function(as) {
      return as[0];
    };
    tail = function(as) {
      return as.slice(1);
    };
    emptyReadonlyArray = [];
    emptyRecord = {};
    has = Object.prototype.hasOwnProperty;
    fromReadonlyNonEmptyArray = function(as) {
      return __spreadArray([as[0]], as.slice(1), true);
    };
  }
});

// node_modules/fp-ts/es6/Apply.js
function apFirst(A) {
  return function(second) {
    return function(first2) {
      return A.ap(A.map(first2, function(a) {
        return function() {
          return a;
        };
      }), second);
    };
  };
}
function apSecond(A) {
  return function(second) {
    return function(first2) {
      return A.ap(A.map(first2, function() {
        return function(b) {
          return b;
        };
      }), second);
    };
  };
}
function apS(F) {
  return function(name, fb) {
    return function(fa) {
      return F.ap(F.map(fa, function(a) {
        return function(b) {
          var _a;
          return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
        };
      }), fb);
    };
  };
}
function getApplySemigroup(F) {
  return function(S) {
    return {
      concat: function(first2, second) {
        return F.ap(F.map(first2, function(x) {
          return function(y) {
            return S.concat(x, y);
          };
        }), second);
      }
    };
  };
}
var init_Apply = __esm({
  "node_modules/fp-ts/es6/Apply.js"() {
    init_shim();
    init_function();
    init_internal();
  }
});

// node_modules/fp-ts/es6/Functor.js
function flap(F) {
  return function(a) {
    return function(fab) {
      return F.map(fab, function(f) {
        return f(a);
      });
    };
  };
}
function bindTo(F) {
  return function(name) {
    return function(fa) {
      return F.map(fa, function(a) {
        var _a;
        return _a = {}, _a[name] = a, _a;
      });
    };
  };
}
function let_(F) {
  return function(name, f) {
    return function(fa) {
      return F.map(fa, function(a) {
        var _a;
        return Object.assign({}, a, (_a = {}, _a[name] = f(a), _a));
      });
    };
  };
}
var init_Functor = __esm({
  "node_modules/fp-ts/es6/Functor.js"() {
    init_shim();
    init_function();
  }
});

// node_modules/fp-ts/es6/Applicative.js
function getApplicativeMonoid(F) {
  var f = getApplySemigroup(F);
  return function(M) {
    return {
      concat: f(M).concat,
      empty: F.of(M.empty)
    };
  };
}
var init_Applicative = __esm({
  "node_modules/fp-ts/es6/Applicative.js"() {
    init_shim();
    init_Apply();
    init_function();
    init_Functor();
  }
});

// node_modules/fp-ts/es6/Chain.js
function chainFirst(M) {
  return function(f) {
    return function(first2) {
      return M.chain(first2, function(a) {
        return M.map(f(a), function() {
          return a;
        });
      });
    };
  };
}
function bind(M) {
  return function(name, f) {
    return function(ma) {
      return M.chain(ma, function(a) {
        return M.map(f(a), function(b) {
          var _a;
          return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
        });
      });
    };
  };
}
var init_Chain = __esm({
  "node_modules/fp-ts/es6/Chain.js"() {
    init_shim();
  }
});

// node_modules/fp-ts/es6/ChainRec.js
var tailRec;
var init_ChainRec = __esm({
  "node_modules/fp-ts/es6/ChainRec.js"() {
    init_shim();
    tailRec = function(startWith, f) {
      var ab = f(startWith);
      while (ab._tag === "Left") {
        ab = f(ab.left);
      }
      return ab.right;
    };
  }
});

// node_modules/fp-ts/es6/FromEither.js
function fromOption(F) {
  return function(onNone) {
    return function(ma) {
      return F.fromEither(isNone(ma) ? left(onNone()) : right(ma.value));
    };
  };
}
function fromPredicate(F) {
  return function(predicate, onFalse) {
    return function(a) {
      return F.fromEither(predicate(a) ? right(a) : left(onFalse(a)));
    };
  };
}
function fromOptionK(F) {
  var fromOptionF = fromOption(F);
  return function(onNone) {
    var from = fromOptionF(onNone);
    return function(f) {
      return flow(f, from);
    };
  };
}
function chainOptionK(F, M) {
  var fromOptionKF = fromOptionK(F);
  return function(onNone) {
    var from = fromOptionKF(onNone);
    return function(f) {
      return function(ma) {
        return M.chain(ma, from(f));
      };
    };
  };
}
function fromEitherK(F) {
  return function(f) {
    return flow(f, F.fromEither);
  };
}
function chainEitherK(F, M) {
  var fromEitherKF = fromEitherK(F);
  return function(f) {
    return function(ma) {
      return M.chain(ma, fromEitherKF(f));
    };
  };
}
function chainFirstEitherK(F, M) {
  return flow(fromEitherK(F), chainFirst(M));
}
function filterOrElse(F, M) {
  return function(predicate, onFalse) {
    return function(ma) {
      return M.chain(ma, function(a) {
        return F.fromEither(predicate(a) ? right(a) : left(onFalse(a)));
      });
    };
  };
}
var init_FromEither = __esm({
  "node_modules/fp-ts/es6/FromEither.js"() {
    init_shim();
    init_Chain();
    init_function();
    init_internal();
  }
});

// node_modules/fp-ts/es6/Separated.js
var separated, _map, map, URI, Functor, flap2, left2, right2;
var init_Separated = __esm({
  "node_modules/fp-ts/es6/Separated.js"() {
    init_shim();
    init_function();
    init_Functor();
    separated = function(left4, right4) {
      return { left: left4, right: right4 };
    };
    _map = function(fa, f) {
      return pipe(fa, map(f));
    };
    map = function(f) {
      return function(fa) {
        return separated(left2(fa), f(right2(fa)));
      };
    };
    URI = "Separated";
    Functor = {
      URI,
      map: _map
    };
    flap2 = flap(Functor);
    left2 = function(s) {
      return s.left;
    };
    right2 = function(s) {
      return s.right;
    };
  }
});

// node_modules/fp-ts/es6/Witherable.js
function wiltDefault(T, C) {
  return function(F) {
    var traverseF = T.traverse(F);
    return function(wa, f) {
      return F.map(traverseF(wa, f), C.separate);
    };
  };
}
function witherDefault(T, C) {
  return function(F) {
    var traverseF = T.traverse(F);
    return function(wa, f) {
      return F.map(traverseF(wa, f), C.compact);
    };
  };
}
function filterE(W) {
  return function(F) {
    var witherF = W.wither(F);
    return function(predicate) {
      return function(ga) {
        return witherF(ga, function(a) {
          return F.map(predicate(a), function(b) {
            return b ? some(a) : none;
          });
        });
      };
    };
  };
}
var init_Witherable = __esm({
  "node_modules/fp-ts/es6/Witherable.js"() {
    init_shim();
    init_internal();
  }
});

// node_modules/fp-ts/es6/Either.js
var Either_exports = {};
__export(Either_exports, {
  Alt: () => Alt,
  ApT: () => ApT,
  Applicative: () => Applicative,
  Apply: () => Apply,
  Bifunctor: () => Bifunctor,
  Chain: () => Chain,
  ChainRec: () => ChainRec,
  Do: () => Do,
  Extend: () => Extend,
  Foldable: () => Foldable,
  FromEither: () => FromEither,
  Functor: () => Functor2,
  Monad: () => Monad,
  MonadThrow: () => MonadThrow,
  Pointed: () => Pointed,
  Traversable: () => Traversable,
  URI: () => URI2,
  alt: () => alt,
  altW: () => altW,
  ap: () => ap2,
  apFirst: () => apFirst2,
  apFirstW: () => apFirstW,
  apS: () => apS2,
  apSW: () => apSW,
  apSecond: () => apSecond2,
  apSecondW: () => apSecondW,
  apW: () => apW,
  bimap: () => bimap,
  bind: () => bind2,
  bindTo: () => bindTo2,
  bindW: () => bindW,
  chain: () => chain,
  chainFirst: () => chainFirst2,
  chainFirstW: () => chainFirstW,
  chainNullableK: () => chainNullableK,
  chainOptionK: () => chainOptionK2,
  chainW: () => chainW,
  duplicate: () => duplicate,
  either: () => either,
  elem: () => elem,
  exists: () => exists,
  extend: () => extend,
  filterOrElse: () => filterOrElse2,
  filterOrElseW: () => filterOrElseW,
  flap: () => flap3,
  flatten: () => flatten,
  flattenW: () => flattenW,
  fold: () => fold,
  foldMap: () => foldMap,
  foldW: () => foldW,
  fromNullable: () => fromNullable,
  fromNullableK: () => fromNullableK,
  fromOption: () => fromOption2,
  fromOptionK: () => fromOptionK2,
  fromPredicate: () => fromPredicate2,
  getAltValidation: () => getAltValidation,
  getApplicativeValidation: () => getApplicativeValidation,
  getApplyMonoid: () => getApplyMonoid,
  getApplySemigroup: () => getApplySemigroup2,
  getCompactable: () => getCompactable,
  getEq: () => getEq,
  getFilterable: () => getFilterable,
  getOrElse: () => getOrElse,
  getOrElseW: () => getOrElseW,
  getSemigroup: () => getSemigroup,
  getShow: () => getShow,
  getValidation: () => getValidation,
  getValidationMonoid: () => getValidationMonoid,
  getValidationSemigroup: () => getValidationSemigroup,
  getWitherable: () => getWitherable,
  isLeft: () => isLeft2,
  isRight: () => isRight2,
  left: () => left3,
  let: () => let_2,
  map: () => map2,
  mapLeft: () => mapLeft,
  match: () => match,
  matchW: () => matchW,
  of: () => of,
  orElse: () => orElse,
  orElseW: () => orElseW,
  parseJSON: () => parseJSON,
  reduce: () => reduce,
  reduceRight: () => reduceRight,
  right: () => right3,
  sequence: () => sequence,
  sequenceArray: () => sequenceArray,
  stringifyJSON: () => stringifyJSON,
  swap: () => swap,
  throwError: () => throwError,
  toError: () => toError,
  toUnion: () => toUnion,
  traverse: () => traverse,
  traverseArray: () => traverseArray,
  traverseArrayWithIndex: () => traverseArrayWithIndex,
  traverseReadonlyArrayWithIndex: () => traverseReadonlyArrayWithIndex,
  traverseReadonlyNonEmptyArrayWithIndex: () => traverseReadonlyNonEmptyArrayWithIndex,
  tryCatch: () => tryCatch,
  tryCatchK: () => tryCatchK
});
function toError(e) {
  return e instanceof Error ? e : new Error(String(e));
}
function elem(E) {
  return function(a, ma) {
    if (ma === void 0) {
      var elemE_1 = elem(E);
      return function(ma2) {
        return elemE_1(a, ma2);
      };
    }
    return isLeft2(ma) ? false : E.equals(a, ma.right);
  };
}
function parseJSON(s, onError) {
  return tryCatch(function() {
    return JSON.parse(s);
  }, onError);
}
function getValidation(SE) {
  var ap9 = getApplicativeValidation(SE).ap;
  var alt6 = getAltValidation(SE).alt;
  return {
    URI: URI2,
    _E: void 0,
    map: _map2,
    of,
    chain: _chain,
    bimap: _bimap,
    mapLeft: _mapLeft,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    extend: _extend,
    traverse: _traverse,
    sequence,
    chainRec: _chainRec,
    throwError,
    ap: ap9,
    alt: alt6
  };
}
var left3, right3, _map2, _ap, _chain, _reduce, _foldMap, _reduceRight, _traverse, _bimap, _mapLeft, _alt, _extend, _chainRec, URI2, getShow, getEq, getSemigroup, getCompactable, getFilterable, getWitherable, getApplicativeValidation, getAltValidation, map2, Functor2, of, Pointed, apW, ap2, Apply, Applicative, chainW, chain, Chain, Monad, reduce, foldMap, reduceRight, Foldable, traverse, sequence, Traversable, bimap, mapLeft, Bifunctor, altW, alt, Alt, extend, Extend, ChainRec, throwError, MonadThrow, FromEither, fromPredicate2, fromOption2, isLeft2, isRight2, matchW, foldW, match, fold, getOrElseW, getOrElse, flap3, apFirst2, apFirstW, apSecond2, apSecondW, chainFirst2, chainFirstW, flattenW, flatten, duplicate, fromOptionK2, chainOptionK2, filterOrElse2, filterOrElseW, swap, orElseW, orElse, fromNullable, tryCatch, tryCatchK, fromNullableK, chainNullableK, toUnion, exists, Do, bindTo2, let_2, bind2, bindW, apS2, apSW, ApT, traverseReadonlyNonEmptyArrayWithIndex, traverseReadonlyArrayWithIndex, traverseArrayWithIndex, traverseArray, sequenceArray, stringifyJSON, either, getApplySemigroup2, getApplyMonoid, getValidationSemigroup, getValidationMonoid;
var init_Either = __esm({
  "node_modules/fp-ts/es6/Either.js"() {
    init_shim();
    init_Applicative();
    init_Apply();
    init_Chain();
    init_ChainRec();
    init_FromEither();
    init_function();
    init_Functor();
    init_internal();
    init_Separated();
    init_Witherable();
    left3 = left;
    right3 = right;
    _map2 = function(fa, f) {
      return pipe(fa, map2(f));
    };
    _ap = function(fab, fa) {
      return pipe(fab, ap2(fa));
    };
    _chain = function(ma, f) {
      return pipe(ma, chain(f));
    };
    _reduce = function(fa, b, f) {
      return pipe(fa, reduce(b, f));
    };
    _foldMap = function(M) {
      return function(fa, f) {
        var foldMapM = foldMap(M);
        return pipe(fa, foldMapM(f));
      };
    };
    _reduceRight = function(fa, b, f) {
      return pipe(fa, reduceRight(b, f));
    };
    _traverse = function(F) {
      var traverseF = traverse(F);
      return function(ta, f) {
        return pipe(ta, traverseF(f));
      };
    };
    _bimap = function(fa, f, g) {
      return pipe(fa, bimap(f, g));
    };
    _mapLeft = function(fa, f) {
      return pipe(fa, mapLeft(f));
    };
    _alt = function(fa, that) {
      return pipe(fa, alt(that));
    };
    _extend = function(wa, f) {
      return pipe(wa, extend(f));
    };
    _chainRec = function(a, f) {
      return tailRec(f(a), function(e) {
        return isLeft2(e) ? right3(left3(e.left)) : isLeft2(e.right) ? left3(f(e.right.left)) : right3(right3(e.right.right));
      });
    };
    URI2 = "Either";
    getShow = function(SE, SA) {
      return {
        show: function(ma) {
          return isLeft2(ma) ? "left(".concat(SE.show(ma.left), ")") : "right(".concat(SA.show(ma.right), ")");
        }
      };
    };
    getEq = function(EL, EA) {
      return {
        equals: function(x, y) {
          return x === y || (isLeft2(x) ? isLeft2(y) && EL.equals(x.left, y.left) : isRight2(y) && EA.equals(x.right, y.right));
        }
      };
    };
    getSemigroup = function(S) {
      return {
        concat: function(x, y) {
          return isLeft2(y) ? x : isLeft2(x) ? y : right3(S.concat(x.right, y.right));
        }
      };
    };
    getCompactable = function(M) {
      var empty7 = left3(M.empty);
      return {
        URI: URI2,
        _E: void 0,
        compact: function(ma) {
          return isLeft2(ma) ? ma : ma.right._tag === "None" ? empty7 : right3(ma.right.value);
        },
        separate: function(ma) {
          return isLeft2(ma) ? separated(ma, ma) : isLeft2(ma.right) ? separated(right3(ma.right.left), empty7) : separated(empty7, right3(ma.right.right));
        }
      };
    };
    getFilterable = function(M) {
      var empty7 = left3(M.empty);
      var _a = getCompactable(M), compact6 = _a.compact, separate6 = _a.separate;
      var filter8 = function(ma, predicate) {
        return isLeft2(ma) ? ma : predicate(ma.right) ? ma : empty7;
      };
      var partition7 = function(ma, p) {
        return isLeft2(ma) ? separated(ma, ma) : p(ma.right) ? separated(empty7, right3(ma.right)) : separated(right3(ma.right), empty7);
      };
      return {
        URI: URI2,
        _E: void 0,
        map: _map2,
        compact: compact6,
        separate: separate6,
        filter: filter8,
        filterMap: function(ma, f) {
          if (isLeft2(ma)) {
            return ma;
          }
          var ob = f(ma.right);
          return ob._tag === "None" ? empty7 : right3(ob.value);
        },
        partition: partition7,
        partitionMap: function(ma, f) {
          if (isLeft2(ma)) {
            return separated(ma, ma);
          }
          var e = f(ma.right);
          return isLeft2(e) ? separated(right3(e.left), empty7) : separated(empty7, right3(e.right));
        }
      };
    };
    getWitherable = function(M) {
      var F_ = getFilterable(M);
      var C = getCompactable(M);
      return {
        URI: URI2,
        _E: void 0,
        map: _map2,
        compact: F_.compact,
        separate: F_.separate,
        filter: F_.filter,
        filterMap: F_.filterMap,
        partition: F_.partition,
        partitionMap: F_.partitionMap,
        traverse: _traverse,
        sequence,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        wither: witherDefault(Traversable, C),
        wilt: wiltDefault(Traversable, C)
      };
    };
    getApplicativeValidation = function(SE) {
      return {
        URI: URI2,
        _E: void 0,
        map: _map2,
        ap: function(fab, fa) {
          return isLeft2(fab) ? isLeft2(fa) ? left3(SE.concat(fab.left, fa.left)) : fab : isLeft2(fa) ? fa : right3(fab.right(fa.right));
        },
        of
      };
    };
    getAltValidation = function(SE) {
      return {
        URI: URI2,
        _E: void 0,
        map: _map2,
        alt: function(me, that) {
          if (isRight2(me)) {
            return me;
          }
          var ea = that();
          return isLeft2(ea) ? left3(SE.concat(me.left, ea.left)) : ea;
        }
      };
    };
    map2 = function(f) {
      return function(fa) {
        return isLeft2(fa) ? fa : right3(f(fa.right));
      };
    };
    Functor2 = {
      URI: URI2,
      map: _map2
    };
    of = right3;
    Pointed = {
      URI: URI2,
      of
    };
    apW = function(fa) {
      return function(fab) {
        return isLeft2(fab) ? fab : isLeft2(fa) ? fa : right3(fab.right(fa.right));
      };
    };
    ap2 = apW;
    Apply = {
      URI: URI2,
      map: _map2,
      ap: _ap
    };
    Applicative = {
      URI: URI2,
      map: _map2,
      ap: _ap,
      of
    };
    chainW = function(f) {
      return function(ma) {
        return isLeft2(ma) ? ma : f(ma.right);
      };
    };
    chain = chainW;
    Chain = {
      URI: URI2,
      map: _map2,
      ap: _ap,
      chain: _chain
    };
    Monad = {
      URI: URI2,
      map: _map2,
      ap: _ap,
      of,
      chain: _chain
    };
    reduce = function(b, f) {
      return function(fa) {
        return isLeft2(fa) ? b : f(b, fa.right);
      };
    };
    foldMap = function(M) {
      return function(f) {
        return function(fa) {
          return isLeft2(fa) ? M.empty : f(fa.right);
        };
      };
    };
    reduceRight = function(b, f) {
      return function(fa) {
        return isLeft2(fa) ? b : f(fa.right, b);
      };
    };
    Foldable = {
      URI: URI2,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight
    };
    traverse = function(F) {
      return function(f) {
        return function(ta) {
          return isLeft2(ta) ? F.of(left3(ta.left)) : F.map(f(ta.right), right3);
        };
      };
    };
    sequence = function(F) {
      return function(ma) {
        return isLeft2(ma) ? F.of(left3(ma.left)) : F.map(ma.right, right3);
      };
    };
    Traversable = {
      URI: URI2,
      map: _map2,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence
    };
    bimap = function(f, g) {
      return function(fa) {
        return isLeft2(fa) ? left3(f(fa.left)) : right3(g(fa.right));
      };
    };
    mapLeft = function(f) {
      return function(fa) {
        return isLeft2(fa) ? left3(f(fa.left)) : fa;
      };
    };
    Bifunctor = {
      URI: URI2,
      bimap: _bimap,
      mapLeft: _mapLeft
    };
    altW = function(that) {
      return function(fa) {
        return isLeft2(fa) ? that() : fa;
      };
    };
    alt = altW;
    Alt = {
      URI: URI2,
      map: _map2,
      alt: _alt
    };
    extend = function(f) {
      return function(wa) {
        return isLeft2(wa) ? wa : right3(f(wa));
      };
    };
    Extend = {
      URI: URI2,
      map: _map2,
      extend: _extend
    };
    ChainRec = {
      URI: URI2,
      map: _map2,
      ap: _ap,
      chain: _chain,
      chainRec: _chainRec
    };
    throwError = left3;
    MonadThrow = {
      URI: URI2,
      map: _map2,
      ap: _ap,
      of,
      chain: _chain,
      throwError
    };
    FromEither = {
      URI: URI2,
      fromEither: identity
    };
    fromPredicate2 = fromPredicate(FromEither);
    fromOption2 = fromOption(FromEither);
    isLeft2 = isLeft;
    isRight2 = isRight;
    matchW = function(onLeft, onRight) {
      return function(ma) {
        return isLeft2(ma) ? onLeft(ma.left) : onRight(ma.right);
      };
    };
    foldW = matchW;
    match = matchW;
    fold = match;
    getOrElseW = function(onLeft) {
      return function(ma) {
        return isLeft2(ma) ? onLeft(ma.left) : ma.right;
      };
    };
    getOrElse = getOrElseW;
    flap3 = flap(Functor2);
    apFirst2 = apFirst(Apply);
    apFirstW = apFirst2;
    apSecond2 = apSecond(Apply);
    apSecondW = apSecond2;
    chainFirst2 = chainFirst(Chain);
    chainFirstW = chainFirst2;
    flattenW = chainW(identity);
    flatten = flattenW;
    duplicate = extend(identity);
    fromOptionK2 = fromOptionK(FromEither);
    chainOptionK2 = chainOptionK(FromEither, Chain);
    filterOrElse2 = filterOrElse(FromEither, Chain);
    filterOrElseW = filterOrElse2;
    swap = function(ma) {
      return isLeft2(ma) ? right3(ma.left) : left3(ma.right);
    };
    orElseW = function(onLeft) {
      return function(ma) {
        return isLeft2(ma) ? onLeft(ma.left) : ma;
      };
    };
    orElse = orElseW;
    fromNullable = function(e) {
      return function(a) {
        return a == null ? left3(e) : right3(a);
      };
    };
    tryCatch = function(f, onThrow) {
      try {
        return right3(f());
      } catch (e) {
        return left3(onThrow(e));
      }
    };
    tryCatchK = function(f, onThrow) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return tryCatch(function() {
          return f.apply(void 0, a);
        }, onThrow);
      };
    };
    fromNullableK = function(e) {
      var from = fromNullable(e);
      return function(f) {
        return flow(f, from);
      };
    };
    chainNullableK = function(e) {
      var from = fromNullableK(e);
      return function(f) {
        return chain(from(f));
      };
    };
    toUnion = foldW(identity, identity);
    exists = function(predicate) {
      return function(ma) {
        return isLeft2(ma) ? false : predicate(ma.right);
      };
    };
    Do = of(emptyRecord);
    bindTo2 = bindTo(Functor2);
    let_2 = let_(Functor2);
    bind2 = bind(Chain);
    bindW = bind2;
    apS2 = apS(Apply);
    apSW = apS2;
    ApT = of(emptyReadonlyArray);
    traverseReadonlyNonEmptyArrayWithIndex = function(f) {
      return function(as) {
        var e = f(0, head(as));
        if (isLeft2(e)) {
          return e;
        }
        var out = [e.right];
        for (var i = 1; i < as.length; i++) {
          var e_1 = f(i, as[i]);
          if (isLeft2(e_1)) {
            return e_1;
          }
          out.push(e_1.right);
        }
        return right3(out);
      };
    };
    traverseReadonlyArrayWithIndex = function(f) {
      var g = traverseReadonlyNonEmptyArrayWithIndex(f);
      return function(as) {
        return isNonEmpty(as) ? g(as) : ApT;
      };
    };
    traverseArrayWithIndex = traverseReadonlyArrayWithIndex;
    traverseArray = function(f) {
      return traverseReadonlyArrayWithIndex(function(_, a) {
        return f(a);
      });
    };
    sequenceArray = traverseArray(identity);
    stringifyJSON = function(u, onError) {
      return tryCatch(function() {
        var s = JSON.stringify(u);
        if (typeof s !== "string") {
          throw new Error("Converting unsupported structure to JSON");
        }
        return s;
      }, onError);
    };
    either = {
      URI: URI2,
      map: _map2,
      of,
      ap: _ap,
      chain: _chain,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence,
      bimap: _bimap,
      mapLeft: _mapLeft,
      alt: _alt,
      extend: _extend,
      chainRec: _chainRec,
      throwError
    };
    getApplySemigroup2 = getApplySemigroup(Apply);
    getApplyMonoid = getApplicativeMonoid(Applicative);
    getValidationSemigroup = function(SE, SA) {
      return getApplySemigroup(getApplicativeValidation(SE))(SA);
    };
    getValidationMonoid = function(SE, MA) {
      return getApplicativeMonoid(getApplicativeValidation(SE))(MA);
    };
  }
});

// node_modules/io-ts/es6/index.js
var es6_exports = {};
__export(es6_exports, {
  AnyArrayType: () => AnyArrayType,
  AnyDictionaryType: () => AnyDictionaryType,
  AnyType: () => AnyType,
  Array: () => UnknownArray,
  ArrayType: () => ArrayType,
  BigIntType: () => BigIntType,
  BooleanType: () => BooleanType,
  Dictionary: () => Dictionary,
  DictionaryType: () => DictionaryType,
  ExactType: () => ExactType,
  Function: () => Function,
  FunctionType: () => FunctionType,
  Int: () => Int,
  Integer: () => Integer,
  InterfaceType: () => InterfaceType,
  IntersectionType: () => IntersectionType,
  KeyofType: () => KeyofType,
  LiteralType: () => LiteralType,
  NeverType: () => NeverType,
  NullType: () => NullType,
  NumberType: () => NumberType,
  ObjectType: () => ObjectType,
  PartialType: () => PartialType,
  ReadonlyArrayType: () => ReadonlyArrayType,
  ReadonlyType: () => ReadonlyType,
  RecursiveType: () => RecursiveType,
  RefinementType: () => RefinementType,
  StrictType: () => StrictType,
  StringType: () => StringType,
  TaggedUnionType: () => TaggedUnionType,
  TupleType: () => TupleType,
  Type: () => Type,
  UndefinedType: () => UndefinedType,
  UnionType: () => UnionType,
  UnknownArray: () => UnknownArray,
  UnknownRecord: () => UnknownRecord,
  UnknownType: () => UnknownType,
  VoidType: () => VoidType,
  alias: () => alias,
  any: () => any,
  appendContext: () => appendContext,
  array: () => array,
  bigint: () => bigint,
  boolean: () => boolean,
  brand: () => brand,
  clean: () => clean,
  dictionary: () => dictionary,
  emptyTags: () => emptyTags,
  exact: () => exact,
  failure: () => failure,
  failures: () => failures,
  getContextEntry: () => getContextEntry,
  getDefaultContext: () => getDefaultContext,
  getDomainKeys: () => getDomainKeys,
  getFunctionName: () => getFunctionName,
  getIndex: () => getIndex,
  getTags: () => getTags,
  getValidationError: () => getValidationError,
  identity: () => identity2,
  interface: () => type,
  intersection: () => intersection,
  keyof: () => keyof,
  literal: () => literal,
  mergeAll: () => mergeAll,
  never: () => never,
  null: () => nullType,
  nullType: () => nullType,
  number: () => number,
  object: () => object,
  partial: () => partial,
  readonly: () => readonly,
  readonlyArray: () => readonlyArray,
  record: () => record,
  recursion: () => recursion,
  refinement: () => refinement,
  strict: () => strict,
  string: () => string,
  success: () => success,
  taggedUnion: () => taggedUnion,
  tuple: () => tuple2,
  type: () => type,
  undefined: () => undefinedType,
  union: () => union,
  unknown: () => unknown,
  void: () => voidType,
  voidType: () => voidType
});
function getFunctionName(f) {
  return f.displayName || f.name || "<function".concat(f.length, ">");
}
function getContextEntry(key, decoder) {
  return { key, type: decoder };
}
function appendContext(c, key, decoder, actual) {
  var len = c.length;
  var r = Array(len + 1);
  for (var i = 0; i < len; i++) {
    r[i] = c[i];
  }
  r[len] = { key, type: decoder, actual };
  return r;
}
function pushAll(xs, ys) {
  var l = ys.length;
  for (var i = 0; i < l; i++) {
    xs.push(ys[i]);
  }
}
function getNameFromProps(props) {
  return Object.keys(props).map(function(k) {
    return "".concat(k, ": ").concat(props[k].name);
  }).join(", ");
}
function useIdentity(codecs) {
  for (var i = 0; i < codecs.length; i++) {
    if (codecs[i].encode !== identity2) {
      return false;
    }
  }
  return true;
}
function getInterfaceTypeName(props) {
  return "{ ".concat(getNameFromProps(props), " }");
}
function getPartialTypeName(inner) {
  return "Partial<".concat(inner, ">");
}
function enumerableRecord(keys3, domain, codomain, name) {
  if (name === void 0) {
    name = "{ [K in ".concat(domain.name, "]: ").concat(codomain.name, " }");
  }
  var len = keys3.length;
  return new DictionaryType(name, function(u) {
    return UnknownRecord.is(u) && keys3.every(function(k) {
      return codomain.is(u[k]);
    });
  }, function(u, c) {
    var e = UnknownRecord.validate(u, c);
    if (isLeft2(e)) {
      return e;
    }
    var o = e.right;
    var a = {};
    var errors = [];
    var changed = false;
    for (var i = 0; i < len; i++) {
      var k = keys3[i];
      var ok = o[k];
      var codomainResult = codomain.validate(ok, appendContext(c, k, codomain, ok));
      if (isLeft2(codomainResult)) {
        pushAll(errors, codomainResult.left);
      } else {
        var vok = codomainResult.right;
        changed = changed || vok !== ok;
        a[k] = vok;
      }
    }
    return errors.length > 0 ? failures(errors) : success(changed || Object.keys(o).length !== len ? a : o);
  }, codomain.encode === identity2 ? identity2 : function(a) {
    var s = {};
    for (var i = 0; i < len; i++) {
      var k = keys3[i];
      s[k] = codomain.encode(a[k]);
    }
    return s;
  }, domain, codomain);
}
function getDomainKeys(domain) {
  var _a;
  if (isLiteralC(domain)) {
    var literal_1 = domain.value;
    if (string.is(literal_1)) {
      return _a = {}, _a[literal_1] = null, _a;
    }
  } else if (isKeyofC(domain)) {
    return domain.keys;
  } else if (isUnionC(domain)) {
    var keys3 = domain.types.map(function(type2) {
      return getDomainKeys(type2);
    });
    return keys3.some(undefinedType.is) ? void 0 : Object.assign.apply(Object, __spreadArray2([{}], keys3, false));
  }
  return void 0;
}
function nonEnumerableRecord(domain, codomain, name) {
  if (name === void 0) {
    name = "{ [K in ".concat(domain.name, "]: ").concat(codomain.name, " }");
  }
  return new DictionaryType(name, function(u) {
    if (UnknownRecord.is(u)) {
      return Object.keys(u).every(function(k) {
        return domain.is(k) && codomain.is(u[k]);
      });
    }
    return isAnyC(codomain) && Array.isArray(u);
  }, function(u, c) {
    if (UnknownRecord.is(u)) {
      var a = {};
      var errors = [];
      var keys3 = Object.keys(u);
      var len = keys3.length;
      var changed = false;
      for (var i = 0; i < len; i++) {
        var k = keys3[i];
        var ok = u[k];
        var domainResult = domain.validate(k, appendContext(c, k, domain, k));
        if (isLeft2(domainResult)) {
          pushAll(errors, domainResult.left);
        } else {
          var vk = domainResult.right;
          changed = changed || vk !== k;
          k = vk;
          var codomainResult = codomain.validate(ok, appendContext(c, k, codomain, ok));
          if (isLeft2(codomainResult)) {
            pushAll(errors, codomainResult.left);
          } else {
            var vok = codomainResult.right;
            changed = changed || vok !== ok;
            a[k] = vok;
          }
        }
      }
      return errors.length > 0 ? failures(errors) : success(changed ? a : u);
    }
    if (isAnyC(codomain) && Array.isArray(u)) {
      return success(u);
    }
    return failure(u, c);
  }, domain.encode === identity2 && codomain.encode === identity2 ? identity2 : function(a) {
    var s = {};
    var keys3 = Object.keys(a);
    var len = keys3.length;
    for (var i = 0; i < len; i++) {
      var k = keys3[i];
      s[String(domain.encode(k))] = codomain.encode(a[k]);
    }
    return s;
  }, domain, codomain);
}
function getUnionName(codecs) {
  return "(" + codecs.map(function(type2) {
    return type2.name;
  }).join(" | ") + ")";
}
function mergeAll(base, us) {
  var equal = true;
  var primitive = true;
  var baseIsNotADictionary = !UnknownRecord.is(base);
  for (var _i = 0, us_1 = us; _i < us_1.length; _i++) {
    var u = us_1[_i];
    if (u !== base) {
      equal = false;
    }
    if (UnknownRecord.is(u)) {
      primitive = false;
    }
  }
  if (equal) {
    return base;
  } else if (primitive) {
    return us[us.length - 1];
  }
  var r = {};
  for (var _a = 0, us_2 = us; _a < us_2.length; _a++) {
    var u = us_2[_a];
    for (var k in u) {
      if (!hasOwnProperty.call(r, k) || baseIsNotADictionary || u[k] !== base[k]) {
        r[k] = u[k];
      }
    }
  }
  return r;
}
function getProps(codec) {
  switch (codec._tag) {
    case "RefinementType":
    case "ReadonlyType":
      return getProps(codec.type);
    case "InterfaceType":
    case "StrictType":
    case "PartialType":
      return codec.props;
    case "IntersectionType":
      return codec.types.reduce(function(props, type2) {
        return Object.assign(props, getProps(type2));
      }, {});
  }
}
function stripKeys(o, props) {
  var keys3 = Object.getOwnPropertyNames(o);
  var shouldStrip = false;
  var r = {};
  for (var i = 0; i < keys3.length; i++) {
    var key = keys3[i];
    if (!hasOwnProperty.call(props, key)) {
      shouldStrip = true;
    } else {
      r[key] = o[key];
    }
  }
  return shouldStrip ? r : o;
}
function getExactTypeName(codec) {
  if (isTypeC(codec)) {
    return "{| ".concat(getNameFromProps(codec.props), " |}");
  } else if (isPartialC(codec)) {
    return getPartialTypeName("{| ".concat(getNameFromProps(codec.props), " |}"));
  }
  return "Exact<".concat(codec.name, ">");
}
function isNonEmpty2(as) {
  return as.length > 0;
}
function intersect(a, b) {
  var r = [];
  for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {
    var v = a_1[_i];
    if (b.indexOf(v) !== -1) {
      r.push(v);
    }
  }
  return r;
}
function mergeTags(a, b) {
  if (a === emptyTags) {
    return b;
  }
  if (b === emptyTags) {
    return a;
  }
  var r = Object.assign({}, a);
  for (var k in b) {
    if (hasOwnProperty.call(a, k)) {
      var intersection_1 = intersect(a[k], b[k]);
      if (isNonEmpty2(intersection_1)) {
        r[k] = intersection_1;
      } else {
        r = emptyTags;
        break;
      }
    } else {
      r[k] = b[k];
    }
  }
  return r;
}
function intersectTags(a, b) {
  if (a === emptyTags || b === emptyTags) {
    return emptyTags;
  }
  var r = emptyTags;
  for (var k in a) {
    if (hasOwnProperty.call(b, k)) {
      var intersection_2 = intersect(a[k], b[k]);
      if (intersection_2.length === 0) {
        if (r === emptyTags) {
          r = {};
        }
        r[k] = a[k].concat(b[k]);
      }
    }
  }
  return r;
}
function isAnyC(codec) {
  return codec._tag === "AnyType";
}
function isLiteralC(codec) {
  return codec._tag === "LiteralType";
}
function isKeyofC(codec) {
  return codec._tag === "KeyofType";
}
function isTypeC(codec) {
  return codec._tag === "InterfaceType";
}
function isPartialC(codec) {
  return codec._tag === "PartialType";
}
function isStrictC(codec) {
  return codec._tag === "StrictType";
}
function isExactC(codec) {
  return codec._tag === "ExactType";
}
function isRefinementC(codec) {
  return codec._tag === "RefinementType";
}
function isIntersectionC(codec) {
  return codec._tag === "IntersectionType";
}
function isUnionC(codec) {
  return codec._tag === "UnionType";
}
function isRecursiveC(codec) {
  return codec._tag === "RecursiveType";
}
function getTags(codec) {
  if (lazyCodecs.indexOf(codec) !== -1) {
    return emptyTags;
  }
  if (isTypeC(codec) || isStrictC(codec)) {
    var index = emptyTags;
    for (var k in codec.props) {
      var prop = codec.props[k];
      if (isLiteralC(prop)) {
        if (index === emptyTags) {
          index = {};
        }
        index[k] = [prop.value];
      }
    }
    return index;
  } else if (isExactC(codec) || isRefinementC(codec)) {
    return getTags(codec.type);
  } else if (isIntersectionC(codec)) {
    return codec.types.reduce(function(tags2, codec2) {
      return mergeTags(tags2, getTags(codec2));
    }, emptyTags);
  } else if (isUnionC(codec)) {
    return codec.types.slice(1).reduce(function(tags2, codec2) {
      return intersectTags(tags2, getTags(codec2));
    }, getTags(codec.types[0]));
  } else if (isRecursiveC(codec)) {
    lazyCodecs.push(codec);
    var tags = getTags(codec.type);
    lazyCodecs.pop();
    return tags;
  }
  return emptyTags;
}
function getIndex(codecs) {
  var tags = getTags(codecs[0]);
  var keys3 = Object.keys(tags);
  var len = codecs.length;
  var _loop_1 = function(k2) {
    var all = tags[k2].slice();
    var index = [tags[k2]];
    for (var i = 1; i < len; i++) {
      var codec = codecs[i];
      var ctags = getTags(codec);
      var values = ctags[k2];
      if (values === void 0) {
        return "continue-keys";
      } else {
        if (values.some(function(v) {
          return all.indexOf(v) !== -1;
        })) {
          return "continue-keys";
        } else {
          all.push.apply(all, values);
          index.push(values);
        }
      }
    }
    return { value: [k2, index] };
  };
  keys:
    for (var _i = 0, keys_1 = keys3; _i < keys_1.length; _i++) {
      var k = keys_1[_i];
      var state_1 = _loop_1(k);
      if (typeof state_1 === "object")
        return state_1.value;
      switch (state_1) {
        case "continue-keys":
          continue keys;
      }
    }
  return void 0;
}
function literal(value, name) {
  if (name === void 0) {
    name = JSON.stringify(value);
  }
  var is = function(u) {
    return u === value;
  };
  return new LiteralType(name, is, function(u, c) {
    return is(u) ? success(value) : failure(u, c);
  }, identity2, value);
}
function keyof(keys3, name) {
  if (name === void 0) {
    name = Object.keys(keys3).map(function(k) {
      return JSON.stringify(k);
    }).join(" | ");
  }
  var is = function(u) {
    return string.is(u) && hasOwnProperty.call(keys3, u);
  };
  return new KeyofType(name, is, function(u, c) {
    return is(u) ? success(u) : failure(u, c);
  }, identity2, keys3);
}
function brand(codec, predicate, name) {
  return refinement(codec, predicate, name);
}
function recursion(name, definition) {
  var cache;
  var runDefinition = function() {
    if (!cache) {
      cache = definition(Self);
      cache.name = name;
    }
    return cache;
  };
  var Self = new RecursiveType(name, function(u) {
    return runDefinition().is(u);
  }, function(u, c) {
    return runDefinition().validate(u, c);
  }, function(a) {
    return runDefinition().encode(a);
  }, runDefinition);
  return Self;
}
function array(item, name) {
  if (name === void 0) {
    name = "Array<".concat(item.name, ">");
  }
  return new ArrayType(name, function(u) {
    return UnknownArray.is(u) && u.every(item.is);
  }, function(u, c) {
    var e = UnknownArray.validate(u, c);
    if (isLeft2(e)) {
      return e;
    }
    var us = e.right;
    var len = us.length;
    var as = us;
    var errors = [];
    for (var i = 0; i < len; i++) {
      var ui = us[i];
      var result = item.validate(ui, appendContext(c, String(i), item, ui));
      if (isLeft2(result)) {
        pushAll(errors, result.left);
      } else {
        var ai = result.right;
        if (ai !== ui) {
          if (as === us) {
            as = us.slice();
          }
          as[i] = ai;
        }
      }
    }
    return errors.length > 0 ? failures(errors) : success(as);
  }, item.encode === identity2 ? identity2 : function(a) {
    return a.map(item.encode);
  }, item);
}
function type(props, name) {
  if (name === void 0) {
    name = getInterfaceTypeName(props);
  }
  var keys3 = Object.keys(props);
  var types = keys3.map(function(key) {
    return props[key];
  });
  var len = keys3.length;
  return new InterfaceType(name, function(u) {
    if (UnknownRecord.is(u)) {
      for (var i = 0; i < len; i++) {
        var k = keys3[i];
        var uk = u[k];
        if (uk === void 0 && !hasOwnProperty.call(u, k) || !types[i].is(uk)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }, function(u, c) {
    var e = UnknownRecord.validate(u, c);
    if (isLeft2(e)) {
      return e;
    }
    var o = e.right;
    var a = o;
    var errors = [];
    for (var i = 0; i < len; i++) {
      var k = keys3[i];
      var ak = a[k];
      var type_1 = types[i];
      var result = type_1.validate(ak, appendContext(c, k, type_1, ak));
      if (isLeft2(result)) {
        pushAll(errors, result.left);
      } else {
        var vak = result.right;
        if (vak !== ak || vak === void 0 && !hasOwnProperty.call(a, k)) {
          if (a === o) {
            a = __assign({}, o);
          }
          a[k] = vak;
        }
      }
    }
    return errors.length > 0 ? failures(errors) : success(a);
  }, useIdentity(types) ? identity2 : function(a) {
    var s = __assign({}, a);
    for (var i = 0; i < len; i++) {
      var k = keys3[i];
      var encode = types[i].encode;
      if (encode !== identity2) {
        s[k] = encode(a[k]);
      }
    }
    return s;
  }, props);
}
function partial(props, name) {
  if (name === void 0) {
    name = getPartialTypeName(getInterfaceTypeName(props));
  }
  var keys3 = Object.keys(props);
  var types = keys3.map(function(key) {
    return props[key];
  });
  var len = keys3.length;
  return new PartialType(name, function(u) {
    if (UnknownRecord.is(u)) {
      for (var i = 0; i < len; i++) {
        var k = keys3[i];
        var uk = u[k];
        if (uk !== void 0 && !props[k].is(uk)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }, function(u, c) {
    var e = UnknownRecord.validate(u, c);
    if (isLeft2(e)) {
      return e;
    }
    var o = e.right;
    var a = o;
    var errors = [];
    for (var i = 0; i < len; i++) {
      var k = keys3[i];
      var ak = a[k];
      var type_2 = props[k];
      var result = type_2.validate(ak, appendContext(c, k, type_2, ak));
      if (isLeft2(result)) {
        if (ak !== void 0) {
          pushAll(errors, result.left);
        }
      } else {
        var vak = result.right;
        if (vak !== ak) {
          if (a === o) {
            a = __assign({}, o);
          }
          a[k] = vak;
        }
      }
    }
    return errors.length > 0 ? failures(errors) : success(a);
  }, useIdentity(types) ? identity2 : function(a) {
    var s = __assign({}, a);
    for (var i = 0; i < len; i++) {
      var k = keys3[i];
      var ak = a[k];
      if (ak !== void 0) {
        s[k] = types[i].encode(ak);
      }
    }
    return s;
  }, props);
}
function record(domain, codomain, name) {
  var keys3 = getDomainKeys(domain);
  return keys3 ? enumerableRecord(Object.keys(keys3), domain, codomain, name) : nonEnumerableRecord(domain, codomain, name);
}
function union(codecs, name) {
  if (name === void 0) {
    name = getUnionName(codecs);
  }
  var index = getIndex(codecs);
  if (index !== void 0 && codecs.length > 0) {
    var tag_1 = index[0], groups_1 = index[1];
    var len_1 = groups_1.length;
    var find_1 = function(value) {
      for (var i = 0; i < len_1; i++) {
        if (groups_1[i].indexOf(value) !== -1) {
          return i;
        }
      }
      return void 0;
    };
    return new TaggedUnionType(name, function(u) {
      if (UnknownRecord.is(u)) {
        var i = find_1(u[tag_1]);
        return i !== void 0 ? codecs[i].is(u) : false;
      }
      return false;
    }, function(u, c) {
      var e = UnknownRecord.validate(u, c);
      if (isLeft2(e)) {
        return e;
      }
      var r = e.right;
      var i = find_1(r[tag_1]);
      if (i === void 0) {
        return failure(u, c);
      }
      var codec = codecs[i];
      return codec.validate(r, appendContext(c, String(i), codec, r));
    }, useIdentity(codecs) ? identity2 : function(a) {
      var i = find_1(a[tag_1]);
      if (i === void 0) {
        throw new Error("no codec found to encode value in union codec ".concat(name));
      } else {
        return codecs[i].encode(a);
      }
    }, codecs, tag_1);
  } else {
    return new UnionType(name, function(u) {
      return codecs.some(function(type2) {
        return type2.is(u);
      });
    }, function(u, c) {
      var errors = [];
      for (var i = 0; i < codecs.length; i++) {
        var codec = codecs[i];
        var result = codec.validate(u, appendContext(c, String(i), codec, u));
        if (isLeft2(result)) {
          pushAll(errors, result.left);
        } else {
          return success(result.right);
        }
      }
      return failures(errors);
    }, useIdentity(codecs) ? identity2 : function(a) {
      for (var _i = 0, codecs_1 = codecs; _i < codecs_1.length; _i++) {
        var codec = codecs_1[_i];
        if (codec.is(a)) {
          return codec.encode(a);
        }
      }
      throw new Error("no codec found to encode value in union type ".concat(name));
    }, codecs);
  }
}
function intersection(codecs, name) {
  if (name === void 0) {
    name = "(".concat(codecs.map(function(type2) {
      return type2.name;
    }).join(" & "), ")");
  }
  var len = codecs.length;
  return new IntersectionType(name, function(u) {
    return codecs.every(function(type2) {
      return type2.is(u);
    });
  }, codecs.length === 0 ? success : function(u, c) {
    var us = [];
    var errors = [];
    for (var i = 0; i < len; i++) {
      var codec = codecs[i];
      var result = codec.validate(u, appendContext(c, String(i), codec, u));
      if (isLeft2(result)) {
        pushAll(errors, result.left);
      } else {
        us.push(result.right);
      }
    }
    return errors.length > 0 ? failures(errors) : success(mergeAll(u, us));
  }, codecs.length === 0 ? identity2 : function(a) {
    return mergeAll(a, codecs.map(function(codec) {
      return codec.encode(a);
    }));
  }, codecs);
}
function tuple2(codecs, name) {
  if (name === void 0) {
    name = "[".concat(codecs.map(function(type2) {
      return type2.name;
    }).join(", "), "]");
  }
  var len = codecs.length;
  return new TupleType(name, function(u) {
    return UnknownArray.is(u) && u.length === len && codecs.every(function(type2, i) {
      return type2.is(u[i]);
    });
  }, function(u, c) {
    var e = UnknownArray.validate(u, c);
    if (isLeft2(e)) {
      return e;
    }
    var us = e.right;
    var as = us.length > len ? us.slice(0, len) : us;
    var errors = [];
    for (var i = 0; i < len; i++) {
      var a = us[i];
      var type_3 = codecs[i];
      var result = type_3.validate(a, appendContext(c, String(i), type_3, a));
      if (isLeft2(result)) {
        pushAll(errors, result.left);
      } else {
        var va = result.right;
        if (va !== a) {
          if (as === us) {
            as = us.slice();
          }
          as[i] = va;
        }
      }
    }
    return errors.length > 0 ? failures(errors) : success(as);
  }, useIdentity(codecs) ? identity2 : function(a) {
    return codecs.map(function(type2, i) {
      return type2.encode(a[i]);
    });
  }, codecs);
}
function readonly(codec, name) {
  if (name === void 0) {
    name = "Readonly<".concat(codec.name, ">");
  }
  return new ReadonlyType(name, codec.is, codec.validate, codec.encode, codec);
}
function readonlyArray(item, name) {
  if (name === void 0) {
    name = "ReadonlyArray<".concat(item.name, ">");
  }
  var codec = array(item);
  return new ReadonlyArrayType(name, codec.is, codec.validate, codec.encode, item);
}
function exact(codec, name) {
  if (name === void 0) {
    name = getExactTypeName(codec);
  }
  var props = getProps(codec);
  return new ExactType(name, codec.is, function(u, c) {
    var e = UnknownRecord.validate(u, c);
    if (isLeft2(e)) {
      return e;
    }
    var ce = codec.validate(u, c);
    if (isLeft2(ce)) {
      return ce;
    }
    return right3(stripKeys(ce.right, props));
  }, function(a) {
    return codec.encode(stripKeys(a, props));
  }, codec);
}
function refinement(codec, predicate, name) {
  if (name === void 0) {
    name = "(".concat(codec.name, " | ").concat(getFunctionName(predicate), ")");
  }
  return new RefinementType(name, function(u) {
    return codec.is(u) && predicate(u);
  }, function(i, c) {
    var e = codec.validate(i, c);
    if (isLeft2(e)) {
      return e;
    }
    var a = e.right;
    return predicate(a) ? success(a) : failure(a, c);
  }, codec.encode, codec, predicate);
}
function clean(codec) {
  return codec;
}
function alias(codec) {
  return function() {
    return codec;
  };
}
var __extends, __assign, __spreadArray2, failures, failure, success, Type, identity2, hasOwnProperty, emptyTags, lazyCodecs, NullType, nullType, UndefinedType, undefinedType, VoidType, voidType, UnknownType, unknown, StringType, string, NumberType, number, BigIntType, bigint, BooleanType, boolean, AnyArrayType, UnknownArray, AnyDictionaryType, UnknownRecord, LiteralType, KeyofType, RefinementType, Int, RecursiveType, ArrayType, InterfaceType, PartialType, DictionaryType, UnionType, IntersectionType, TupleType, ReadonlyType, ReadonlyArrayType, strict, ExactType, FunctionType, Function, NeverType, never, AnyType, any, Integer, TaggedUnionType, taggedUnion, getValidationError, getDefaultContext, Dictionary, ObjectType, object, dictionary, StrictType;
var init_es6 = __esm({
  "node_modules/io-ts/es6/index.js"() {
    init_shim();
    init_Either();
    __extends = function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __assign = function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    __spreadArray2 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    failures = left3;
    failure = function(value, context, message) {
      return failures([{ value, context, message }]);
    };
    success = right3;
    Type = /** @class */
    function() {
      function Type2(name, is, validate, encode) {
        this.name = name;
        this.is = is;
        this.validate = validate;
        this.encode = encode;
        this.decode = this.decode.bind(this);
      }
      Type2.prototype.pipe = function(ab, name) {
        var _this = this;
        if (name === void 0) {
          name = "pipe(".concat(this.name, ", ").concat(ab.name, ")");
        }
        return new Type2(name, ab.is, function(i, c) {
          var e = _this.validate(i, c);
          if (isLeft2(e)) {
            return e;
          }
          return ab.validate(e.right, c);
        }, this.encode === identity2 && ab.encode === identity2 ? identity2 : function(b) {
          return _this.encode(ab.encode(b));
        });
      };
      Type2.prototype.asDecoder = function() {
        return this;
      };
      Type2.prototype.asEncoder = function() {
        return this;
      };
      Type2.prototype.decode = function(i) {
        return this.validate(i, [{ key: "", type: this, actual: i }]);
      };
      return Type2;
    }();
    identity2 = function(a) {
      return a;
    };
    hasOwnProperty = Object.prototype.hasOwnProperty;
    emptyTags = {};
    lazyCodecs = [];
    NullType = /** @class */
    function(_super) {
      __extends(NullType2, _super);
      function NullType2() {
        var _this = _super.call(this, "null", function(u) {
          return u === null;
        }, function(u, c) {
          return _this.is(u) ? success(u) : failure(u, c);
        }, identity2) || this;
        _this._tag = "NullType";
        return _this;
      }
      return NullType2;
    }(Type);
    nullType = new NullType();
    UndefinedType = /** @class */
    function(_super) {
      __extends(UndefinedType2, _super);
      function UndefinedType2() {
        var _this = _super.call(this, "undefined", function(u) {
          return u === void 0;
        }, function(u, c) {
          return _this.is(u) ? success(u) : failure(u, c);
        }, identity2) || this;
        _this._tag = "UndefinedType";
        return _this;
      }
      return UndefinedType2;
    }(Type);
    undefinedType = new UndefinedType();
    VoidType = /** @class */
    function(_super) {
      __extends(VoidType2, _super);
      function VoidType2() {
        var _this = _super.call(this, "void", undefinedType.is, undefinedType.validate, identity2) || this;
        _this._tag = "VoidType";
        return _this;
      }
      return VoidType2;
    }(Type);
    voidType = new VoidType();
    UnknownType = /** @class */
    function(_super) {
      __extends(UnknownType2, _super);
      function UnknownType2() {
        var _this = _super.call(this, "unknown", function(_) {
          return true;
        }, success, identity2) || this;
        _this._tag = "UnknownType";
        return _this;
      }
      return UnknownType2;
    }(Type);
    unknown = new UnknownType();
    StringType = /** @class */
    function(_super) {
      __extends(StringType2, _super);
      function StringType2() {
        var _this = _super.call(this, "string", function(u) {
          return typeof u === "string";
        }, function(u, c) {
          return _this.is(u) ? success(u) : failure(u, c);
        }, identity2) || this;
        _this._tag = "StringType";
        return _this;
      }
      return StringType2;
    }(Type);
    string = new StringType();
    NumberType = /** @class */
    function(_super) {
      __extends(NumberType2, _super);
      function NumberType2() {
        var _this = _super.call(this, "number", function(u) {
          return typeof u === "number";
        }, function(u, c) {
          return _this.is(u) ? success(u) : failure(u, c);
        }, identity2) || this;
        _this._tag = "NumberType";
        return _this;
      }
      return NumberType2;
    }(Type);
    number = new NumberType();
    BigIntType = /** @class */
    function(_super) {
      __extends(BigIntType2, _super);
      function BigIntType2() {
        var _this = _super.call(
          this,
          "bigint",
          // tslint:disable-next-line: valid-typeof
          function(u) {
            return typeof u === "bigint";
          },
          function(u, c) {
            return _this.is(u) ? success(u) : failure(u, c);
          },
          identity2
        ) || this;
        _this._tag = "BigIntType";
        return _this;
      }
      return BigIntType2;
    }(Type);
    bigint = new BigIntType();
    BooleanType = /** @class */
    function(_super) {
      __extends(BooleanType2, _super);
      function BooleanType2() {
        var _this = _super.call(this, "boolean", function(u) {
          return typeof u === "boolean";
        }, function(u, c) {
          return _this.is(u) ? success(u) : failure(u, c);
        }, identity2) || this;
        _this._tag = "BooleanType";
        return _this;
      }
      return BooleanType2;
    }(Type);
    boolean = new BooleanType();
    AnyArrayType = /** @class */
    function(_super) {
      __extends(AnyArrayType2, _super);
      function AnyArrayType2() {
        var _this = _super.call(this, "UnknownArray", Array.isArray, function(u, c) {
          return _this.is(u) ? success(u) : failure(u, c);
        }, identity2) || this;
        _this._tag = "AnyArrayType";
        return _this;
      }
      return AnyArrayType2;
    }(Type);
    UnknownArray = new AnyArrayType();
    AnyDictionaryType = /** @class */
    function(_super) {
      __extends(AnyDictionaryType2, _super);
      function AnyDictionaryType2() {
        var _this = _super.call(this, "UnknownRecord", function(u) {
          return u !== null && typeof u === "object" && !Array.isArray(u);
        }, function(u, c) {
          return _this.is(u) ? success(u) : failure(u, c);
        }, identity2) || this;
        _this._tag = "AnyDictionaryType";
        return _this;
      }
      return AnyDictionaryType2;
    }(Type);
    UnknownRecord = new AnyDictionaryType();
    LiteralType = /** @class */
    function(_super) {
      __extends(LiteralType2, _super);
      function LiteralType2(name, is, validate, encode, value) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.value = value;
        _this._tag = "LiteralType";
        return _this;
      }
      return LiteralType2;
    }(Type);
    KeyofType = /** @class */
    function(_super) {
      __extends(KeyofType2, _super);
      function KeyofType2(name, is, validate, encode, keys3) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.keys = keys3;
        _this._tag = "KeyofType";
        return _this;
      }
      return KeyofType2;
    }(Type);
    RefinementType = /** @class */
    function(_super) {
      __extends(RefinementType2, _super);
      function RefinementType2(name, is, validate, encode, type2, predicate) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.type = type2;
        _this.predicate = predicate;
        _this._tag = "RefinementType";
        return _this;
      }
      return RefinementType2;
    }(Type);
    Int = brand(number, function(n) {
      return Number.isInteger(n);
    }, "Int");
    RecursiveType = /** @class */
    function(_super) {
      __extends(RecursiveType2, _super);
      function RecursiveType2(name, is, validate, encode, runDefinition) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.runDefinition = runDefinition;
        _this._tag = "RecursiveType";
        return _this;
      }
      return RecursiveType2;
    }(Type);
    Object.defineProperty(RecursiveType.prototype, "type", {
      get: function() {
        return this.runDefinition();
      },
      enumerable: true,
      configurable: true
    });
    ArrayType = /** @class */
    function(_super) {
      __extends(ArrayType2, _super);
      function ArrayType2(name, is, validate, encode, type2) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.type = type2;
        _this._tag = "ArrayType";
        return _this;
      }
      return ArrayType2;
    }(Type);
    InterfaceType = /** @class */
    function(_super) {
      __extends(InterfaceType2, _super);
      function InterfaceType2(name, is, validate, encode, props) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.props = props;
        _this._tag = "InterfaceType";
        return _this;
      }
      return InterfaceType2;
    }(Type);
    PartialType = /** @class */
    function(_super) {
      __extends(PartialType2, _super);
      function PartialType2(name, is, validate, encode, props) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.props = props;
        _this._tag = "PartialType";
        return _this;
      }
      return PartialType2;
    }(Type);
    DictionaryType = /** @class */
    function(_super) {
      __extends(DictionaryType2, _super);
      function DictionaryType2(name, is, validate, encode, domain, codomain) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.domain = domain;
        _this.codomain = codomain;
        _this._tag = "DictionaryType";
        return _this;
      }
      return DictionaryType2;
    }(Type);
    UnionType = /** @class */
    function(_super) {
      __extends(UnionType2, _super);
      function UnionType2(name, is, validate, encode, types) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.types = types;
        _this._tag = "UnionType";
        return _this;
      }
      return UnionType2;
    }(Type);
    IntersectionType = /** @class */
    function(_super) {
      __extends(IntersectionType2, _super);
      function IntersectionType2(name, is, validate, encode, types) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.types = types;
        _this._tag = "IntersectionType";
        return _this;
      }
      return IntersectionType2;
    }(Type);
    TupleType = /** @class */
    function(_super) {
      __extends(TupleType2, _super);
      function TupleType2(name, is, validate, encode, types) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.types = types;
        _this._tag = "TupleType";
        return _this;
      }
      return TupleType2;
    }(Type);
    ReadonlyType = /** @class */
    function(_super) {
      __extends(ReadonlyType2, _super);
      function ReadonlyType2(name, is, validate, encode, type2) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.type = type2;
        _this._tag = "ReadonlyType";
        return _this;
      }
      return ReadonlyType2;
    }(Type);
    ReadonlyArrayType = /** @class */
    function(_super) {
      __extends(ReadonlyArrayType2, _super);
      function ReadonlyArrayType2(name, is, validate, encode, type2) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.type = type2;
        _this._tag = "ReadonlyArrayType";
        return _this;
      }
      return ReadonlyArrayType2;
    }(Type);
    strict = function(props, name) {
      return exact(type(props), name);
    };
    ExactType = /** @class */
    function(_super) {
      __extends(ExactType2, _super);
      function ExactType2(name, is, validate, encode, type2) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.type = type2;
        _this._tag = "ExactType";
        return _this;
      }
      return ExactType2;
    }(Type);
    FunctionType = /** @class */
    function(_super) {
      __extends(FunctionType2, _super);
      function FunctionType2() {
        var _this = _super.call(
          this,
          "Function",
          // tslint:disable-next-line:strict-type-predicates
          function(u) {
            return typeof u === "function";
          },
          function(u, c) {
            return _this.is(u) ? success(u) : failure(u, c);
          },
          identity2
        ) || this;
        _this._tag = "FunctionType";
        return _this;
      }
      return FunctionType2;
    }(Type);
    Function = new FunctionType();
    NeverType = /** @class */
    function(_super) {
      __extends(NeverType2, _super);
      function NeverType2() {
        var _this = _super.call(
          this,
          "never",
          function(_) {
            return false;
          },
          function(u, c) {
            return failure(u, c);
          },
          /* istanbul ignore next */
          function() {
            throw new Error("cannot encode never");
          }
        ) || this;
        _this._tag = "NeverType";
        return _this;
      }
      return NeverType2;
    }(Type);
    never = new NeverType();
    AnyType = /** @class */
    function(_super) {
      __extends(AnyType2, _super);
      function AnyType2() {
        var _this = _super.call(this, "any", function(_) {
          return true;
        }, success, identity2) || this;
        _this._tag = "AnyType";
        return _this;
      }
      return AnyType2;
    }(Type);
    any = new AnyType();
    Integer = refinement(number, Number.isInteger, "Integer");
    TaggedUnionType = /** @class */
    function(_super) {
      __extends(TaggedUnionType2, _super);
      function TaggedUnionType2(name, is, validate, encode, codecs, tag) {
        var _this = _super.call(this, name, is, validate, encode, codecs) || this;
        _this.tag = tag;
        return _this;
      }
      return TaggedUnionType2;
    }(UnionType);
    taggedUnion = function(tag, codecs, name) {
      if (name === void 0) {
        name = getUnionName(codecs);
      }
      var U = union(codecs, name);
      if (U instanceof TaggedUnionType) {
        return U;
      } else {
        console.warn("[io-ts] Cannot build a tagged union for ".concat(name, ", returning a de-optimized union"));
        return new TaggedUnionType(name, U.is, U.validate, U.encode, codecs, tag);
      }
    };
    getValidationError = function(value, context) {
      return {
        value,
        context
      };
    };
    getDefaultContext = function(decoder) {
      return [
        { key: "", type: decoder }
      ];
    };
    Dictionary = UnknownRecord;
    ObjectType = /** @class */
    function(_super) {
      __extends(ObjectType2, _super);
      function ObjectType2() {
        var _this = _super.call(this, "object", function(u) {
          return u !== null && typeof u === "object";
        }, function(u, c) {
          return _this.is(u) ? success(u) : failure(u, c);
        }, identity2) || this;
        _this._tag = "ObjectType";
        return _this;
      }
      return ObjectType2;
    }(Type);
    object = new ObjectType();
    dictionary = record;
    StrictType = /** @class */
    function(_super) {
      __extends(StrictType2, _super);
      function StrictType2(name, is, validate, encode, props) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.props = props;
        _this._tag = "StrictType";
        return _this;
      }
      return StrictType2;
    }(Type);
  }
});

// node_modules/fp-ts/lib/function.js
var require_function = __commonJS({
  "node_modules/fp-ts/lib/function.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEndomorphismMonoid = exports.not = exports.SK = exports.hole = exports.pipe = exports.untupled = exports.tupled = exports.absurd = exports.decrement = exports.increment = exports.tuple = exports.flow = exports.flip = exports.constVoid = exports.constUndefined = exports.constNull = exports.constFalse = exports.constTrue = exports.constant = exports.unsafeCoerce = exports.identity = exports.apply = exports.getRing = exports.getSemiring = exports.getMonoid = exports.getSemigroup = exports.getBooleanAlgebra = void 0;
    var getBooleanAlgebra = function(B) {
      return function() {
        return {
          meet: function(x, y) {
            return function(a) {
              return B.meet(x(a), y(a));
            };
          },
          join: function(x, y) {
            return function(a) {
              return B.join(x(a), y(a));
            };
          },
          zero: function() {
            return B.zero;
          },
          one: function() {
            return B.one;
          },
          implies: function(x, y) {
            return function(a) {
              return B.implies(x(a), y(a));
            };
          },
          not: function(x) {
            return function(a) {
              return B.not(x(a));
            };
          }
        };
      };
    };
    exports.getBooleanAlgebra = getBooleanAlgebra;
    var getSemigroup6 = function(S) {
      return function() {
        return {
          concat: function(f, g) {
            return function(a) {
              return S.concat(f(a), g(a));
            };
          }
        };
      };
    };
    exports.getSemigroup = getSemigroup6;
    var getMonoid6 = function(M) {
      var getSemigroupM = (0, exports.getSemigroup)(M);
      return function() {
        return {
          concat: getSemigroupM().concat,
          empty: function() {
            return M.empty;
          }
        };
      };
    };
    exports.getMonoid = getMonoid6;
    var getSemiring = function(S) {
      return {
        add: function(f, g) {
          return function(x) {
            return S.add(f(x), g(x));
          };
        },
        zero: function() {
          return S.zero;
        },
        mul: function(f, g) {
          return function(x) {
            return S.mul(f(x), g(x));
          };
        },
        one: function() {
          return S.one;
        }
      };
    };
    exports.getSemiring = getSemiring;
    var getRing = function(R) {
      var S = (0, exports.getSemiring)(R);
      return {
        add: S.add,
        mul: S.mul,
        one: S.one,
        zero: S.zero,
        sub: function(f, g) {
          return function(x) {
            return R.sub(f(x), g(x));
          };
        }
      };
    };
    exports.getRing = getRing;
    var apply = function(a) {
      return function(f) {
        return f(a);
      };
    };
    exports.apply = apply;
    function identity3(a) {
      return a;
    }
    exports.identity = identity3;
    exports.unsafeCoerce = identity3;
    function constant3(a) {
      return function() {
        return a;
      };
    }
    exports.constant = constant3;
    exports.constTrue = constant3(true);
    exports.constFalse = constant3(false);
    exports.constNull = constant3(null);
    exports.constUndefined = constant3(void 0);
    exports.constVoid = exports.constUndefined;
    function flip(f) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (args.length > 1) {
          return f(args[1], args[0]);
        }
        return function(a) {
          return f(a)(args[0]);
        };
      };
    }
    exports.flip = flip;
    function flow2(ab, bc, cd, de, ef, fg, gh, hi, ij) {
      switch (arguments.length) {
        case 1:
          return ab;
        case 2:
          return function() {
            return bc(ab.apply(this, arguments));
          };
        case 3:
          return function() {
            return cd(bc(ab.apply(this, arguments)));
          };
        case 4:
          return function() {
            return de(cd(bc(ab.apply(this, arguments))));
          };
        case 5:
          return function() {
            return ef(de(cd(bc(ab.apply(this, arguments)))));
          };
        case 6:
          return function() {
            return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
          };
        case 7:
          return function() {
            return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
          };
        case 8:
          return function() {
            return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
          };
        case 9:
          return function() {
            return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
          };
      }
      return;
    }
    exports.flow = flow2;
    function tuple3() {
      var t = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        t[_i] = arguments[_i];
      }
      return t;
    }
    exports.tuple = tuple3;
    function increment(n) {
      return n + 1;
    }
    exports.increment = increment;
    function decrement(n) {
      return n - 1;
    }
    exports.decrement = decrement;
    function absurd(_) {
      throw new Error("Called `absurd` function which should be uncallable");
    }
    exports.absurd = absurd;
    function tupled(f) {
      return function(a) {
        return f.apply(void 0, a);
      };
    }
    exports.tupled = tupled;
    function untupled(f) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return f(a);
      };
    }
    exports.untupled = untupled;
    function pipe3(a, ab, bc, cd, de, ef, fg, gh, hi) {
      switch (arguments.length) {
        case 1:
          return a;
        case 2:
          return ab(a);
        case 3:
          return bc(ab(a));
        case 4:
          return cd(bc(ab(a)));
        case 5:
          return de(cd(bc(ab(a))));
        case 6:
          return ef(de(cd(bc(ab(a)))));
        case 7:
          return fg(ef(de(cd(bc(ab(a))))));
        case 8:
          return gh(fg(ef(de(cd(bc(ab(a)))))));
        case 9:
          return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
        default: {
          var ret = arguments[0];
          for (var i = 1; i < arguments.length; i++) {
            ret = arguments[i](ret);
          }
          return ret;
        }
      }
    }
    exports.pipe = pipe3;
    exports.hole = absurd;
    var SK2 = function(_, b) {
      return b;
    };
    exports.SK = SK2;
    function not2(predicate) {
      return function(a) {
        return !predicate(a);
      };
    }
    exports.not = not2;
    var getEndomorphismMonoid = function() {
      return {
        concat: function(first2, second) {
          return flow2(first2, second);
        },
        empty: identity3
      };
    };
    exports.getEndomorphismMonoid = getEndomorphismMonoid;
  }
});

// node_modules/fp-ts/lib/internal.js
var require_internal = __commonJS({
  "node_modules/fp-ts/lib/internal.js"(exports) {
    "use strict";
    init_shim();
    var __spreadArray6 = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromReadonlyNonEmptyArray = exports.has = exports.emptyRecord = exports.emptyReadonlyArray = exports.tail = exports.head = exports.isNonEmpty = exports.singleton = exports.right = exports.left = exports.isRight = exports.isLeft = exports.some = exports.none = exports.isSome = exports.isNone = void 0;
    var isNone3 = function(fa) {
      return fa._tag === "None";
    };
    exports.isNone = isNone3;
    var isSome3 = function(fa) {
      return fa._tag === "Some";
    };
    exports.isSome = isSome3;
    exports.none = { _tag: "None" };
    var some6 = function(a) {
      return { _tag: "Some", value: a };
    };
    exports.some = some6;
    var isLeft3 = function(ma) {
      return ma._tag === "Left";
    };
    exports.isLeft = isLeft3;
    var isRight3 = function(ma) {
      return ma._tag === "Right";
    };
    exports.isRight = isRight3;
    var left4 = function(e) {
      return { _tag: "Left", left: e };
    };
    exports.left = left4;
    var right4 = function(a) {
      return { _tag: "Right", right: a };
    };
    exports.right = right4;
    var singleton4 = function(a) {
      return [a];
    };
    exports.singleton = singleton4;
    var isNonEmpty7 = function(as) {
      return as.length > 0;
    };
    exports.isNonEmpty = isNonEmpty7;
    var head6 = function(as) {
      return as[0];
    };
    exports.head = head6;
    var tail5 = function(as) {
      return as.slice(1);
    };
    exports.tail = tail5;
    exports.emptyReadonlyArray = [];
    exports.emptyRecord = {};
    exports.has = Object.prototype.hasOwnProperty;
    var fromReadonlyNonEmptyArray3 = function(as) {
      return __spreadArray6([as[0]], as.slice(1), true);
    };
    exports.fromReadonlyNonEmptyArray = fromReadonlyNonEmptyArray3;
  }
});

// node_modules/fp-ts/lib/Apply.js
var require_Apply = __commonJS({
  "node_modules/fp-ts/lib/Apply.js"(exports) {
    "use strict";
    init_shim();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sequenceS = exports.sequenceT = exports.getApplySemigroup = exports.apS = exports.apSecond = exports.apFirst = exports.ap = void 0;
    var function_1 = require_function();
    var _ = __importStar(require_internal());
    function ap9(F, G) {
      return function(fa) {
        return function(fab) {
          return F.ap(F.map(fab, function(gab) {
            return function(ga) {
              return G.ap(gab, ga);
            };
          }), fa);
        };
      };
    }
    exports.ap = ap9;
    function apFirst8(A) {
      return function(second) {
        return function(first2) {
          return A.ap(A.map(first2, function(a) {
            return function() {
              return a;
            };
          }), second);
        };
      };
    }
    exports.apFirst = apFirst8;
    function apSecond8(A) {
      return function(second) {
        return function(first2) {
          return A.ap(A.map(first2, function() {
            return function(b) {
              return b;
            };
          }), second);
        };
      };
    }
    exports.apSecond = apSecond8;
    function apS8(F) {
      return function(name, fb) {
        return function(fa) {
          return F.ap(F.map(fa, function(a) {
            return function(b) {
              var _a;
              return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
            };
          }), fb);
        };
      };
    }
    exports.apS = apS8;
    function getApplySemigroup4(F) {
      return function(S) {
        return {
          concat: function(first2, second) {
            return F.ap(F.map(first2, function(x) {
              return function(y) {
                return S.concat(x, y);
              };
            }), second);
          }
        };
      };
    }
    exports.getApplySemigroup = getApplySemigroup4;
    function curried(f, n, acc) {
      return function(x) {
        var combined = Array(acc.length + 1);
        for (var i = 0; i < acc.length; i++) {
          combined[i] = acc[i];
        }
        combined[acc.length] = x;
        return n === 0 ? f.apply(null, combined) : curried(f, n - 1, combined);
      };
    }
    var tupleConstructors = {
      1: function(a) {
        return [a];
      },
      2: function(a) {
        return function(b) {
          return [a, b];
        };
      },
      3: function(a) {
        return function(b) {
          return function(c) {
            return [a, b, c];
          };
        };
      },
      4: function(a) {
        return function(b) {
          return function(c) {
            return function(d) {
              return [a, b, c, d];
            };
          };
        };
      },
      5: function(a) {
        return function(b) {
          return function(c) {
            return function(d) {
              return function(e) {
                return [a, b, c, d, e];
              };
            };
          };
        };
      }
    };
    function getTupleConstructor(len) {
      if (!_.has.call(tupleConstructors, len)) {
        tupleConstructors[len] = curried(function_1.tuple, len - 1, []);
      }
      return tupleConstructors[len];
    }
    function sequenceT(F) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var len = args.length;
        var f = getTupleConstructor(len);
        var fas = F.map(args[0], f);
        for (var i = 1; i < len; i++) {
          fas = F.ap(fas, args[i]);
        }
        return fas;
      };
    }
    exports.sequenceT = sequenceT;
    function getRecordConstructor(keys3) {
      var len = keys3.length;
      switch (len) {
        case 1:
          return function(a) {
            var _a;
            return _a = {}, _a[keys3[0]] = a, _a;
          };
        case 2:
          return function(a) {
            return function(b) {
              var _a;
              return _a = {}, _a[keys3[0]] = a, _a[keys3[1]] = b, _a;
            };
          };
        case 3:
          return function(a) {
            return function(b) {
              return function(c) {
                var _a;
                return _a = {}, _a[keys3[0]] = a, _a[keys3[1]] = b, _a[keys3[2]] = c, _a;
              };
            };
          };
        case 4:
          return function(a) {
            return function(b) {
              return function(c) {
                return function(d) {
                  var _a;
                  return _a = {}, _a[keys3[0]] = a, _a[keys3[1]] = b, _a[keys3[2]] = c, _a[keys3[3]] = d, _a;
                };
              };
            };
          };
        case 5:
          return function(a) {
            return function(b) {
              return function(c) {
                return function(d) {
                  return function(e) {
                    var _a;
                    return _a = {}, _a[keys3[0]] = a, _a[keys3[1]] = b, _a[keys3[2]] = c, _a[keys3[3]] = d, _a[keys3[4]] = e, _a;
                  };
                };
              };
            };
          };
        default:
          return curried(function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var r = {};
            for (var i = 0; i < len; i++) {
              r[keys3[i]] = args[i];
            }
            return r;
          }, len - 1, []);
      }
    }
    function sequenceS(F) {
      return function(r) {
        var keys3 = Object.keys(r);
        var len = keys3.length;
        var f = getRecordConstructor(keys3);
        var fr = F.map(r[keys3[0]], f);
        for (var i = 1; i < len; i++) {
          fr = F.ap(fr, r[keys3[i]]);
        }
        return fr;
      };
    }
    exports.sequenceS = sequenceS;
  }
});

// node_modules/fp-ts/lib/Functor.js
var require_Functor = __commonJS({
  "node_modules/fp-ts/lib/Functor.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFunctorComposition = exports.let = exports.bindTo = exports.flap = exports.map = void 0;
    var function_1 = require_function();
    function map11(F, G) {
      return function(f) {
        return function(fa) {
          return F.map(fa, function(ga) {
            return G.map(ga, f);
          });
        };
      };
    }
    exports.map = map11;
    function flap11(F) {
      return function(a) {
        return function(fab) {
          return F.map(fab, function(f) {
            return f(a);
          });
        };
      };
    }
    exports.flap = flap11;
    function bindTo8(F) {
      return function(name) {
        return function(fa) {
          return F.map(fa, function(a) {
            var _a;
            return _a = {}, _a[name] = a, _a;
          });
        };
      };
    }
    exports.bindTo = bindTo8;
    function let_8(F) {
      return function(name, f) {
        return function(fa) {
          return F.map(fa, function(a) {
            var _a;
            return Object.assign({}, a, (_a = {}, _a[name] = f(a), _a));
          });
        };
      };
    }
    exports.let = let_8;
    function getFunctorComposition2(F, G) {
      var _map10 = map11(F, G);
      return {
        map: function(fga, f) {
          return (0, function_1.pipe)(fga, _map10(f));
        }
      };
    }
    exports.getFunctorComposition = getFunctorComposition2;
  }
});

// node_modules/fp-ts/lib/Applicative.js
var require_Applicative = __commonJS({
  "node_modules/fp-ts/lib/Applicative.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getApplicativeComposition = exports.getApplicativeMonoid = void 0;
    var Apply_1 = require_Apply();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    function getApplicativeMonoid2(F) {
      var f = (0, Apply_1.getApplySemigroup)(F);
      return function(M) {
        return {
          concat: f(M).concat,
          empty: F.of(M.empty)
        };
      };
    }
    exports.getApplicativeMonoid = getApplicativeMonoid2;
    function getApplicativeComposition(F, G) {
      var map11 = (0, Functor_1.getFunctorComposition)(F, G).map;
      var _ap7 = (0, Apply_1.ap)(F, G);
      return {
        map: map11,
        of: function(a) {
          return F.of(G.of(a));
        },
        ap: function(fgab, fga) {
          return (0, function_1.pipe)(fgab, _ap7(fga));
        }
      };
    }
    exports.getApplicativeComposition = getApplicativeComposition;
  }
});

// node_modules/fp-ts/lib/Chain.js
var require_Chain = __commonJS({
  "node_modules/fp-ts/lib/Chain.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bind = exports.chainFirst = void 0;
    function chainFirst8(M) {
      return function(f) {
        return function(first2) {
          return M.chain(first2, function(a) {
            return M.map(f(a), function() {
              return a;
            });
          });
        };
      };
    }
    exports.chainFirst = chainFirst8;
    function bind8(M) {
      return function(name, f) {
        return function(ma) {
          return M.chain(ma, function(a) {
            return M.map(f(a), function(b) {
              var _a;
              return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
            });
          });
        };
      };
    }
    exports.bind = bind8;
  }
});

// node_modules/fp-ts/lib/ChainRec.js
var require_ChainRec = __commonJS({
  "node_modules/fp-ts/lib/ChainRec.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tailRec = void 0;
    var tailRec2 = function(startWith, f) {
      var ab = f(startWith);
      while (ab._tag === "Left") {
        ab = f(ab.left);
      }
      return ab.right;
    };
    exports.tailRec = tailRec2;
  }
});

// node_modules/fp-ts/lib/FromEither.js
var require_FromEither = __commonJS({
  "node_modules/fp-ts/lib/FromEither.js"(exports) {
    "use strict";
    init_shim();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filterOrElse = exports.chainFirstEitherK = exports.chainEitherK = exports.fromEitherK = exports.chainOptionK = exports.fromOptionK = exports.fromPredicate = exports.fromOption = void 0;
    var Chain_1 = require_Chain();
    var function_1 = require_function();
    var _ = __importStar(require_internal());
    function fromOption4(F) {
      return function(onNone) {
        return function(ma) {
          return F.fromEither(_.isNone(ma) ? _.left(onNone()) : _.right(ma.value));
        };
      };
    }
    exports.fromOption = fromOption4;
    function fromPredicate5(F) {
      return function(predicate, onFalse) {
        return function(a) {
          return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a)));
        };
      };
    }
    exports.fromPredicate = fromPredicate5;
    function fromOptionK4(F) {
      var fromOptionF = fromOption4(F);
      return function(onNone) {
        var from = fromOptionF(onNone);
        return function(f) {
          return (0, function_1.flow)(f, from);
        };
      };
    }
    exports.fromOptionK = fromOptionK4;
    function chainOptionK3(F, M) {
      var fromOptionKF = fromOptionK4(F);
      return function(onNone) {
        var from = fromOptionKF(onNone);
        return function(f) {
          return function(ma) {
            return M.chain(ma, from(f));
          };
        };
      };
    }
    exports.chainOptionK = chainOptionK3;
    function fromEitherK5(F) {
      return function(f) {
        return (0, function_1.flow)(f, F.fromEither);
      };
    }
    exports.fromEitherK = fromEitherK5;
    function chainEitherK3(F, M) {
      var fromEitherKF = fromEitherK5(F);
      return function(f) {
        return function(ma) {
          return M.chain(ma, fromEitherKF(f));
        };
      };
    }
    exports.chainEitherK = chainEitherK3;
    function chainFirstEitherK3(F, M) {
      return (0, function_1.flow)(fromEitherK5(F), (0, Chain_1.chainFirst)(M));
    }
    exports.chainFirstEitherK = chainFirstEitherK3;
    function filterOrElse3(F, M) {
      return function(predicate, onFalse) {
        return function(ma) {
          return M.chain(ma, function(a) {
            return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a)));
          });
        };
      };
    }
    exports.filterOrElse = filterOrElse3;
  }
});

// node_modules/fp-ts/lib/Separated.js
var require_Separated = __commonJS({
  "node_modules/fp-ts/lib/Separated.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.right = exports.left = exports.flap = exports.Functor = exports.Bifunctor = exports.URI = exports.bimap = exports.mapLeft = exports.map = exports.separated = void 0;
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var separated2 = function(left5, right5) {
      return { left: left5, right: right5 };
    };
    exports.separated = separated2;
    var _map10 = function(fa, f) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f));
    };
    var _mapLeft2 = function(fa, f) {
      return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f));
    };
    var _bimap2 = function(fa, g, f) {
      return (0, function_1.pipe)(fa, (0, exports.bimap)(g, f));
    };
    var map11 = function(f) {
      return function(fa) {
        return (0, exports.separated)((0, exports.left)(fa), f((0, exports.right)(fa)));
      };
    };
    exports.map = map11;
    var mapLeft3 = function(f) {
      return function(fa) {
        return (0, exports.separated)(f((0, exports.left)(fa)), (0, exports.right)(fa));
      };
    };
    exports.mapLeft = mapLeft3;
    var bimap3 = function(f, g) {
      return function(fa) {
        return (0, exports.separated)(f((0, exports.left)(fa)), g((0, exports.right)(fa)));
      };
    };
    exports.bimap = bimap3;
    exports.URI = "Separated";
    exports.Bifunctor = {
      URI: exports.URI,
      mapLeft: _mapLeft2,
      bimap: _bimap2
    };
    exports.Functor = {
      URI: exports.URI,
      map: _map10
    };
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    var left4 = function(s) {
      return s.left;
    };
    exports.left = left4;
    var right4 = function(s) {
      return s.right;
    };
    exports.right = right4;
  }
});

// node_modules/fp-ts/lib/Witherable.js
var require_Witherable = __commonJS({
  "node_modules/fp-ts/lib/Witherable.js"(exports) {
    "use strict";
    init_shim();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filterE = exports.witherDefault = exports.wiltDefault = void 0;
    var _ = __importStar(require_internal());
    function wiltDefault2(T, C) {
      return function(F) {
        var traverseF = T.traverse(F);
        return function(wa, f) {
          return F.map(traverseF(wa, f), C.separate);
        };
      };
    }
    exports.wiltDefault = wiltDefault2;
    function witherDefault2(T, C) {
      return function(F) {
        var traverseF = T.traverse(F);
        return function(wa, f) {
          return F.map(traverseF(wa, f), C.compact);
        };
      };
    }
    exports.witherDefault = witherDefault2;
    function filterE4(W) {
      return function(F) {
        var witherF = W.wither(F);
        return function(predicate) {
          return function(ga) {
            return witherF(ga, function(a) {
              return F.map(predicate(a), function(b) {
                return b ? _.some(a) : _.none;
              });
            });
          };
        };
      };
    }
    exports.filterE = filterE4;
  }
});

// node_modules/fp-ts/lib/Either.js
var require_Either = __commonJS({
  "node_modules/fp-ts/lib/Either.js"(exports) {
    "use strict";
    init_shim();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fold = exports.match = exports.foldW = exports.matchW = exports.isRight = exports.isLeft = exports.fromOption = exports.fromPredicate = exports.FromEither = exports.MonadThrow = exports.throwError = exports.ChainRec = exports.Extend = exports.extend = exports.Alt = exports.alt = exports.altW = exports.Bifunctor = exports.mapLeft = exports.bimap = exports.Traversable = exports.sequence = exports.traverse = exports.Foldable = exports.reduceRight = exports.foldMap = exports.reduce = exports.Monad = exports.Chain = exports.chain = exports.chainW = exports.Applicative = exports.Apply = exports.ap = exports.apW = exports.Pointed = exports.of = exports.Functor = exports.map = exports.getAltValidation = exports.getApplicativeValidation = exports.getWitherable = exports.getFilterable = exports.getCompactable = exports.getSemigroup = exports.getEq = exports.getShow = exports.URI = exports.right = exports.left = void 0;
    exports.getValidation = exports.getValidationMonoid = exports.getValidationSemigroup = exports.getApplyMonoid = exports.getApplySemigroup = exports.either = exports.stringifyJSON = exports.parseJSON = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.let = exports.bindTo = exports.Do = exports.exists = exports.elem = exports.toError = exports.toUnion = exports.chainNullableK = exports.fromNullableK = exports.tryCatchK = exports.tryCatch = exports.fromNullable = exports.orElse = exports.orElseW = exports.swap = exports.filterOrElseW = exports.filterOrElse = exports.chainOptionK = exports.fromOptionK = exports.duplicate = exports.flatten = exports.flattenW = exports.chainFirstW = exports.chainFirst = exports.apSecondW = exports.apSecond = exports.apFirstW = exports.apFirst = exports.flap = exports.getOrElse = exports.getOrElseW = void 0;
    var Applicative_1 = require_Applicative();
    var Apply_1 = require_Apply();
    var Chain_1 = require_Chain();
    var ChainRec_1 = require_ChainRec();
    var FromEither_1 = require_FromEither();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var Separated_1 = require_Separated();
    var Witherable_1 = require_Witherable();
    exports.left = _.left;
    exports.right = _.right;
    var _map10 = function(fa, f) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f));
    };
    var _ap7 = function(fab, fa) {
      return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
    };
    var _chain7 = function(ma, f) {
      return (0, function_1.pipe)(ma, (0, exports.chain)(f));
    };
    var _reduce8 = function(fa, b, f) {
      return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f));
    };
    var _foldMap8 = function(M) {
      return function(fa, f) {
        var foldMapM = (0, exports.foldMap)(M);
        return (0, function_1.pipe)(fa, foldMapM(f));
      };
    };
    var _reduceRight8 = function(fa, b, f) {
      return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f));
    };
    var _traverse8 = function(F) {
      var traverseF = (0, exports.traverse)(F);
      return function(ta, f) {
        return (0, function_1.pipe)(ta, traverseF(f));
      };
    };
    var _bimap2 = function(fa, f, g) {
      return (0, function_1.pipe)(fa, (0, exports.bimap)(f, g));
    };
    var _mapLeft2 = function(fa, f) {
      return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f));
    };
    var _alt5 = function(fa, that) {
      return (0, function_1.pipe)(fa, (0, exports.alt)(that));
    };
    var _extend5 = function(wa, f) {
      return (0, function_1.pipe)(wa, (0, exports.extend)(f));
    };
    var _chainRec2 = function(a, f) {
      return (0, ChainRec_1.tailRec)(f(a), function(e) {
        return (0, exports.isLeft)(e) ? (0, exports.right)((0, exports.left)(e.left)) : (0, exports.isLeft)(e.right) ? (0, exports.left)(f(e.right.left)) : (0, exports.right)((0, exports.right)(e.right.right));
      });
    };
    exports.URI = "Either";
    var getShow9 = function(SE, SA) {
      return {
        show: function(ma) {
          return (0, exports.isLeft)(ma) ? "left(".concat(SE.show(ma.left), ")") : "right(".concat(SA.show(ma.right), ")");
        }
      };
    };
    exports.getShow = getShow9;
    var getEq9 = function(EL, EA) {
      return {
        equals: function(x, y) {
          return x === y || ((0, exports.isLeft)(x) ? (0, exports.isLeft)(y) && EL.equals(x.left, y.left) : (0, exports.isRight)(y) && EA.equals(x.right, y.right));
        }
      };
    };
    exports.getEq = getEq9;
    var getSemigroup6 = function(S) {
      return {
        concat: function(x, y) {
          return (0, exports.isLeft)(y) ? x : (0, exports.isLeft)(x) ? y : (0, exports.right)(S.concat(x.right, y.right));
        }
      };
    };
    exports.getSemigroup = getSemigroup6;
    var getCompactable2 = function(M) {
      var empty7 = (0, exports.left)(M.empty);
      return {
        URI: exports.URI,
        _E: void 0,
        compact: function(ma) {
          return (0, exports.isLeft)(ma) ? ma : ma.right._tag === "None" ? empty7 : (0, exports.right)(ma.right.value);
        },
        separate: function(ma) {
          return (0, exports.isLeft)(ma) ? (0, Separated_1.separated)(ma, ma) : (0, exports.isLeft)(ma.right) ? (0, Separated_1.separated)((0, exports.right)(ma.right.left), empty7) : (0, Separated_1.separated)(empty7, (0, exports.right)(ma.right.right));
        }
      };
    };
    exports.getCompactable = getCompactable2;
    var getFilterable2 = function(M) {
      var empty7 = (0, exports.left)(M.empty);
      var _a = (0, exports.getCompactable)(M), compact6 = _a.compact, separate6 = _a.separate;
      var filter8 = function(ma, predicate) {
        return (0, exports.isLeft)(ma) ? ma : predicate(ma.right) ? ma : empty7;
      };
      var partition7 = function(ma, p) {
        return (0, exports.isLeft)(ma) ? (0, Separated_1.separated)(ma, ma) : p(ma.right) ? (0, Separated_1.separated)(empty7, (0, exports.right)(ma.right)) : (0, Separated_1.separated)((0, exports.right)(ma.right), empty7);
      };
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map10,
        compact: compact6,
        separate: separate6,
        filter: filter8,
        filterMap: function(ma, f) {
          if ((0, exports.isLeft)(ma)) {
            return ma;
          }
          var ob = f(ma.right);
          return ob._tag === "None" ? empty7 : (0, exports.right)(ob.value);
        },
        partition: partition7,
        partitionMap: function(ma, f) {
          if ((0, exports.isLeft)(ma)) {
            return (0, Separated_1.separated)(ma, ma);
          }
          var e = f(ma.right);
          return (0, exports.isLeft)(e) ? (0, Separated_1.separated)((0, exports.right)(e.left), empty7) : (0, Separated_1.separated)(empty7, (0, exports.right)(e.right));
        }
      };
    };
    exports.getFilterable = getFilterable2;
    var getWitherable3 = function(M) {
      var F_ = (0, exports.getFilterable)(M);
      var C = (0, exports.getCompactable)(M);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map10,
        compact: F_.compact,
        separate: F_.separate,
        filter: F_.filter,
        filterMap: F_.filterMap,
        partition: F_.partition,
        partitionMap: F_.partitionMap,
        traverse: _traverse8,
        sequence: exports.sequence,
        reduce: _reduce8,
        foldMap: _foldMap8,
        reduceRight: _reduceRight8,
        wither: (0, Witherable_1.witherDefault)(exports.Traversable, C),
        wilt: (0, Witherable_1.wiltDefault)(exports.Traversable, C)
      };
    };
    exports.getWitherable = getWitherable3;
    var getApplicativeValidation2 = function(SE) {
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map10,
        ap: function(fab, fa) {
          return (0, exports.isLeft)(fab) ? (0, exports.isLeft)(fa) ? (0, exports.left)(SE.concat(fab.left, fa.left)) : fab : (0, exports.isLeft)(fa) ? fa : (0, exports.right)(fab.right(fa.right));
        },
        of: exports.of
      };
    };
    exports.getApplicativeValidation = getApplicativeValidation2;
    var getAltValidation2 = function(SE) {
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map10,
        alt: function(me, that) {
          if ((0, exports.isRight)(me)) {
            return me;
          }
          var ea = that();
          return (0, exports.isLeft)(ea) ? (0, exports.left)(SE.concat(me.left, ea.left)) : ea;
        }
      };
    };
    exports.getAltValidation = getAltValidation2;
    var map11 = function(f) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? fa : (0, exports.right)(f(fa.right));
      };
    };
    exports.map = map11;
    exports.Functor = {
      URI: exports.URI,
      map: _map10
    };
    exports.of = exports.right;
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    var apW2 = function(fa) {
      return function(fab) {
        return (0, exports.isLeft)(fab) ? fab : (0, exports.isLeft)(fa) ? fa : (0, exports.right)(fab.right(fa.right));
      };
    };
    exports.apW = apW2;
    exports.ap = exports.apW;
    exports.Apply = {
      URI: exports.URI,
      map: _map10,
      ap: _ap7
    };
    exports.Applicative = {
      URI: exports.URI,
      map: _map10,
      ap: _ap7,
      of: exports.of
    };
    var chainW2 = function(f) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? ma : f(ma.right);
      };
    };
    exports.chainW = chainW2;
    exports.chain = exports.chainW;
    exports.Chain = {
      URI: exports.URI,
      map: _map10,
      ap: _ap7,
      chain: _chain7
    };
    exports.Monad = {
      URI: exports.URI,
      map: _map10,
      ap: _ap7,
      of: exports.of,
      chain: _chain7
    };
    var reduce10 = function(b, f) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? b : f(b, fa.right);
      };
    };
    exports.reduce = reduce10;
    var foldMap10 = function(M) {
      return function(f) {
        return function(fa) {
          return (0, exports.isLeft)(fa) ? M.empty : f(fa.right);
        };
      };
    };
    exports.foldMap = foldMap10;
    var reduceRight10 = function(b, f) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? b : f(fa.right, b);
      };
    };
    exports.reduceRight = reduceRight10;
    exports.Foldable = {
      URI: exports.URI,
      reduce: _reduce8,
      foldMap: _foldMap8,
      reduceRight: _reduceRight8
    };
    var traverse8 = function(F) {
      return function(f) {
        return function(ta) {
          return (0, exports.isLeft)(ta) ? F.of((0, exports.left)(ta.left)) : F.map(f(ta.right), exports.right);
        };
      };
    };
    exports.traverse = traverse8;
    var sequence8 = function(F) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? F.of((0, exports.left)(ma.left)) : F.map(ma.right, exports.right);
      };
    };
    exports.sequence = sequence8;
    exports.Traversable = {
      URI: exports.URI,
      map: _map10,
      reduce: _reduce8,
      foldMap: _foldMap8,
      reduceRight: _reduceRight8,
      traverse: _traverse8,
      sequence: exports.sequence
    };
    var bimap3 = function(f, g) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? (0, exports.left)(f(fa.left)) : (0, exports.right)(g(fa.right));
      };
    };
    exports.bimap = bimap3;
    var mapLeft3 = function(f) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? (0, exports.left)(f(fa.left)) : fa;
      };
    };
    exports.mapLeft = mapLeft3;
    exports.Bifunctor = {
      URI: exports.URI,
      bimap: _bimap2,
      mapLeft: _mapLeft2
    };
    var altW5 = function(that) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? that() : fa;
      };
    };
    exports.altW = altW5;
    exports.alt = exports.altW;
    exports.Alt = {
      URI: exports.URI,
      map: _map10,
      alt: _alt5
    };
    var extend8 = function(f) {
      return function(wa) {
        return (0, exports.isLeft)(wa) ? wa : (0, exports.right)(f(wa));
      };
    };
    exports.extend = extend8;
    exports.Extend = {
      URI: exports.URI,
      map: _map10,
      extend: _extend5
    };
    exports.ChainRec = {
      URI: exports.URI,
      map: _map10,
      ap: _ap7,
      chain: _chain7,
      chainRec: _chainRec2
    };
    exports.throwError = exports.left;
    exports.MonadThrow = {
      URI: exports.URI,
      map: _map10,
      ap: _ap7,
      of: exports.of,
      chain: _chain7,
      throwError: exports.throwError
    };
    exports.FromEither = {
      URI: exports.URI,
      fromEither: function_1.identity
    };
    exports.fromPredicate = (0, FromEither_1.fromPredicate)(exports.FromEither);
    exports.fromOption = (0, FromEither_1.fromOption)(exports.FromEither);
    exports.isLeft = _.isLeft;
    exports.isRight = _.isRight;
    var matchW5 = function(onLeft, onRight) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? onLeft(ma.left) : onRight(ma.right);
      };
    };
    exports.matchW = matchW5;
    exports.foldW = exports.matchW;
    exports.match = exports.matchW;
    exports.fold = exports.match;
    var getOrElseW3 = function(onLeft) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? onLeft(ma.left) : ma.right;
      };
    };
    exports.getOrElseW = getOrElseW3;
    exports.getOrElse = exports.getOrElseW;
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
    exports.apFirstW = exports.apFirst;
    exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
    exports.apSecondW = exports.apSecond;
    exports.chainFirst = (0, Chain_1.chainFirst)(exports.Chain);
    exports.chainFirstW = exports.chainFirst;
    exports.flattenW = (0, exports.chainW)(function_1.identity);
    exports.flatten = exports.flattenW;
    exports.duplicate = (0, exports.extend)(function_1.identity);
    exports.fromOptionK = (0, FromEither_1.fromOptionK)(exports.FromEither);
    exports.chainOptionK = (0, FromEither_1.chainOptionK)(exports.FromEither, exports.Chain);
    exports.filterOrElse = (0, FromEither_1.filterOrElse)(exports.FromEither, exports.Chain);
    exports.filterOrElseW = exports.filterOrElse;
    var swap2 = function(ma) {
      return (0, exports.isLeft)(ma) ? (0, exports.right)(ma.left) : (0, exports.left)(ma.right);
    };
    exports.swap = swap2;
    var orElseW2 = function(onLeft) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? onLeft(ma.left) : ma;
      };
    };
    exports.orElseW = orElseW2;
    exports.orElse = exports.orElseW;
    var fromNullable3 = function(e) {
      return function(a) {
        return a == null ? (0, exports.left)(e) : (0, exports.right)(a);
      };
    };
    exports.fromNullable = fromNullable3;
    var tryCatch3 = function(f, onThrow) {
      try {
        return (0, exports.right)(f());
      } catch (e) {
        return (0, exports.left)(onThrow(e));
      }
    };
    exports.tryCatch = tryCatch3;
    var tryCatchK3 = function(f, onThrow) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return (0, exports.tryCatch)(function() {
          return f.apply(void 0, a);
        }, onThrow);
      };
    };
    exports.tryCatchK = tryCatchK3;
    var fromNullableK3 = function(e) {
      var from = (0, exports.fromNullable)(e);
      return function(f) {
        return (0, function_1.flow)(f, from);
      };
    };
    exports.fromNullableK = fromNullableK3;
    var chainNullableK3 = function(e) {
      var from = (0, exports.fromNullableK)(e);
      return function(f) {
        return (0, exports.chain)(from(f));
      };
    };
    exports.chainNullableK = chainNullableK3;
    exports.toUnion = (0, exports.foldW)(function_1.identity, function_1.identity);
    function toError2(e) {
      return e instanceof Error ? e : new Error(String(e));
    }
    exports.toError = toError2;
    function elem7(E) {
      return function(a, ma) {
        if (ma === void 0) {
          var elemE_1 = elem7(E);
          return function(ma2) {
            return elemE_1(a, ma2);
          };
        }
        return (0, exports.isLeft)(ma) ? false : E.equals(a, ma.right);
      };
    }
    exports.elem = elem7;
    var exists4 = function(predicate) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? false : predicate(ma.right);
      };
    };
    exports.exists = exists4;
    exports.Do = (0, exports.of)(_.emptyRecord);
    exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
    var let_8 = (0, Functor_1.let)(exports.Functor);
    exports.let = let_8;
    exports.bind = (0, Chain_1.bind)(exports.Chain);
    exports.bindW = exports.bind;
    exports.apS = (0, Apply_1.apS)(exports.Apply);
    exports.apSW = exports.apS;
    exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
    var traverseReadonlyNonEmptyArrayWithIndex3 = function(f) {
      return function(as) {
        var e = f(0, _.head(as));
        if ((0, exports.isLeft)(e)) {
          return e;
        }
        var out = [e.right];
        for (var i = 1; i < as.length; i++) {
          var e_1 = f(i, as[i]);
          if ((0, exports.isLeft)(e_1)) {
            return e_1;
          }
          out.push(e_1.right);
        }
        return (0, exports.right)(out);
      };
    };
    exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex3;
    var traverseReadonlyArrayWithIndex3 = function(f) {
      var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f);
      return function(as) {
        return _.isNonEmpty(as) ? g(as) : exports.ApT;
      };
    };
    exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex3;
    exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
    var traverseArray3 = function(f) {
      return (0, exports.traverseReadonlyArrayWithIndex)(function(_2, a) {
        return f(a);
      });
    };
    exports.traverseArray = traverseArray3;
    exports.sequenceArray = (0, exports.traverseArray)(function_1.identity);
    function parseJSON2(s, onError) {
      return (0, exports.tryCatch)(function() {
        return JSON.parse(s);
      }, onError);
    }
    exports.parseJSON = parseJSON2;
    var stringifyJSON2 = function(u, onError) {
      return (0, exports.tryCatch)(function() {
        var s = JSON.stringify(u);
        if (typeof s !== "string") {
          throw new Error("Converting unsupported structure to JSON");
        }
        return s;
      }, onError);
    };
    exports.stringifyJSON = stringifyJSON2;
    exports.either = {
      URI: exports.URI,
      map: _map10,
      of: exports.of,
      ap: _ap7,
      chain: _chain7,
      reduce: _reduce8,
      foldMap: _foldMap8,
      reduceRight: _reduceRight8,
      traverse: _traverse8,
      sequence: exports.sequence,
      bimap: _bimap2,
      mapLeft: _mapLeft2,
      alt: _alt5,
      extend: _extend5,
      chainRec: _chainRec2,
      throwError: exports.throwError
    };
    exports.getApplySemigroup = (0, Apply_1.getApplySemigroup)(exports.Apply);
    exports.getApplyMonoid = (0, Applicative_1.getApplicativeMonoid)(exports.Applicative);
    var getValidationSemigroup2 = function(SE, SA) {
      return (0, Apply_1.getApplySemigroup)((0, exports.getApplicativeValidation)(SE))(SA);
    };
    exports.getValidationSemigroup = getValidationSemigroup2;
    var getValidationMonoid2 = function(SE, MA) {
      return (0, Applicative_1.getApplicativeMonoid)((0, exports.getApplicativeValidation)(SE))(MA);
    };
    exports.getValidationMonoid = getValidationMonoid2;
    function getValidation2(SE) {
      var ap9 = (0, exports.getApplicativeValidation)(SE).ap;
      var alt6 = (0, exports.getAltValidation)(SE).alt;
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map10,
        of: exports.of,
        chain: _chain7,
        bimap: _bimap2,
        mapLeft: _mapLeft2,
        reduce: _reduce8,
        foldMap: _foldMap8,
        reduceRight: _reduceRight8,
        extend: _extend5,
        traverse: _traverse8,
        sequence: exports.sequence,
        chainRec: _chainRec2,
        throwError: exports.throwError,
        ap: ap9,
        alt: alt6
      };
    }
    exports.getValidation = getValidation2;
  }
});

// node_modules/fp-ts/es6/Eq.js
var fromEquals, eqStrict, strictEqual;
var init_Eq = __esm({
  "node_modules/fp-ts/es6/Eq.js"() {
    init_shim();
    init_function();
    fromEquals = function(equals) {
      return {
        equals: function(x, y) {
          return x === y || equals(x, y);
        }
      };
    };
    eqStrict = {
      equals: function(a, b) {
        return a === b;
      }
    };
    strictEqual = eqStrict.equals;
  }
});

// node_modules/fp-ts/es6/Ord.js
function compare(first2, second) {
  return first2 < second ? -1 : first2 > second ? 1 : 0;
}
var equalsDefault, fromCompare, contramap, getSemigroup2, getMonoid, trivial, min, max, strictOrd, ordNumber, ordDate;
var init_Ord = __esm({
  "node_modules/fp-ts/es6/Ord.js"() {
    init_shim();
    init_Eq();
    init_function();
    equalsDefault = function(compare2) {
      return function(first2, second) {
        return first2 === second || compare2(first2, second) === 0;
      };
    };
    fromCompare = function(compare2) {
      return {
        equals: equalsDefault(compare2),
        compare: function(first2, second) {
          return first2 === second ? 0 : compare2(first2, second);
        }
      };
    };
    contramap = function(f) {
      return function(fa) {
        return fromCompare(function(first2, second) {
          return fa.compare(f(first2), f(second));
        });
      };
    };
    getSemigroup2 = function() {
      return {
        concat: function(first2, second) {
          return fromCompare(function(a, b) {
            var ox = first2.compare(a, b);
            return ox !== 0 ? ox : second.compare(a, b);
          });
        }
      };
    };
    getMonoid = function() {
      return {
        concat: getSemigroup2().concat,
        empty: fromCompare(function() {
          return 0;
        })
      };
    };
    trivial = {
      equals: constTrue,
      compare: constant(0)
    };
    min = function(O) {
      return function(first2, second) {
        return first2 === second || O.compare(first2, second) < 1 ? first2 : second;
      };
    };
    max = function(O) {
      return function(first2, second) {
        return first2 === second || O.compare(first2, second) > -1 ? first2 : second;
      };
    };
    strictOrd = {
      equals: eqStrict.equals,
      compare
    };
    ordNumber = strictOrd;
    ordDate = pipe(
      ordNumber,
      contramap(function(date) {
        return date.valueOf();
      })
    );
  }
});

// node_modules/fp-ts/es6/Magma.js
var init_Magma = __esm({
  "node_modules/fp-ts/es6/Magma.js"() {
    init_shim();
  }
});

// node_modules/fp-ts/es6/Semigroup.js
var min2, max2, constant2, first, last, semigroupVoid;
var init_Semigroup = __esm({
  "node_modules/fp-ts/es6/Semigroup.js"() {
    init_shim();
    init_function();
    init_internal();
    init_Magma();
    init_Ord();
    min2 = function(O) {
      return {
        concat: min(O)
      };
    };
    max2 = function(O) {
      return {
        concat: max(O)
      };
    };
    constant2 = function(a) {
      return {
        concat: function() {
          return a;
        }
      };
    };
    first = function() {
      return { concat: identity };
    };
    last = function() {
      return { concat: function(_, y) {
        return y;
      } };
    };
    semigroupVoid = constant2(void 0);
  }
});

// node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js
var __spreadArray3, empty, isNonEmpty3, isOutOfBound, prependW, prepend, appendW, append, prependAll, intersperse, chainWithIndex, _map3, _ap2, _chain2, of2, ap3, chain2, extend2, duplicate2, flatten2, map3, mapWithIndex, reduce2, foldMap2, reduceRight2, reduceWithIndex, foldMapWithIndex, reduceRightWithIndex, extract, URI3, getShow2, getEq2, Functor3, flap4, Apply2, apFirst3, apSecond3, Chain2, chainFirst3, Do2, bindTo3, let_3, bind3, apS3, head2, tail2, last2, min3, max3, concatAll2, intercalate;
var init_ReadonlyNonEmptyArray = __esm({
  "node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js"() {
    init_shim();
    init_Apply();
    init_Chain();
    init_Eq();
    init_function();
    init_Functor();
    init_internal();
    init_Ord();
    init_Semigroup();
    __spreadArray3 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    empty = emptyReadonlyArray;
    isNonEmpty3 = isNonEmpty;
    isOutOfBound = function(i, as) {
      return i < 0 || i >= as.length;
    };
    prependW = function(head6) {
      return function(tail5) {
        return __spreadArray3([head6], tail5, true);
      };
    };
    prepend = prependW;
    appendW = function(end) {
      return function(init4) {
        return __spreadArray3(__spreadArray3([], init4, true), [end], false);
      };
    };
    append = appendW;
    prependAll = function(middle) {
      return function(as) {
        var out = [middle, as[0]];
        for (var i = 1; i < as.length; i++) {
          out.push(middle, as[i]);
        }
        return out;
      };
    };
    intersperse = function(middle) {
      return function(as) {
        var rest = tail2(as);
        return isNonEmpty3(rest) ? pipe(rest, prependAll(middle), prepend(head2(as))) : as;
      };
    };
    chainWithIndex = function(f) {
      return function(as) {
        var out = fromReadonlyNonEmptyArray(f(0, head2(as)));
        for (var i = 1; i < as.length; i++) {
          out.push.apply(out, f(i, as[i]));
        }
        return out;
      };
    };
    _map3 = function(fa, f) {
      return pipe(fa, map3(f));
    };
    _ap2 = function(fab, fa) {
      return pipe(fab, ap3(fa));
    };
    _chain2 = function(ma, f) {
      return pipe(ma, chain2(f));
    };
    of2 = singleton;
    ap3 = function(as) {
      return chain2(function(f) {
        return pipe(as, map3(f));
      });
    };
    chain2 = function(f) {
      return chainWithIndex(function(_, a) {
        return f(a);
      });
    };
    extend2 = function(f) {
      return function(as) {
        var next = tail2(as);
        var out = [f(as)];
        while (isNonEmpty3(next)) {
          out.push(f(next));
          next = tail2(next);
        }
        return out;
      };
    };
    duplicate2 = extend2(identity);
    flatten2 = chain2(identity);
    map3 = function(f) {
      return mapWithIndex(function(_, a) {
        return f(a);
      });
    };
    mapWithIndex = function(f) {
      return function(as) {
        var out = [f(0, head2(as))];
        for (var i = 1; i < as.length; i++) {
          out.push(f(i, as[i]));
        }
        return out;
      };
    };
    reduce2 = function(b, f) {
      return reduceWithIndex(b, function(_, b2, a) {
        return f(b2, a);
      });
    };
    foldMap2 = function(S) {
      return function(f) {
        return function(as) {
          return as.slice(1).reduce(function(s, a) {
            return S.concat(s, f(a));
          }, f(as[0]));
        };
      };
    };
    reduceRight2 = function(b, f) {
      return reduceRightWithIndex(b, function(_, b2, a) {
        return f(b2, a);
      });
    };
    reduceWithIndex = function(b, f) {
      return function(as) {
        return as.reduce(function(b2, a, i) {
          return f(i, b2, a);
        }, b);
      };
    };
    foldMapWithIndex = function(S) {
      return function(f) {
        return function(as) {
          return as.slice(1).reduce(function(s, a, i) {
            return S.concat(s, f(i + 1, a));
          }, f(0, as[0]));
        };
      };
    };
    reduceRightWithIndex = function(b, f) {
      return function(as) {
        return as.reduceRight(function(b2, a, i) {
          return f(i, a, b2);
        }, b);
      };
    };
    extract = head;
    URI3 = "ReadonlyNonEmptyArray";
    getShow2 = function(S) {
      return {
        show: function(as) {
          return "[".concat(as.map(S.show).join(", "), "]");
        }
      };
    };
    getEq2 = function(E) {
      return fromEquals(function(xs, ys) {
        return xs.length === ys.length && xs.every(function(x, i) {
          return E.equals(x, ys[i]);
        });
      });
    };
    Functor3 = {
      URI: URI3,
      map: _map3
    };
    flap4 = flap(Functor3);
    Apply2 = {
      URI: URI3,
      map: _map3,
      ap: _ap2
    };
    apFirst3 = apFirst(Apply2);
    apSecond3 = apSecond(Apply2);
    Chain2 = {
      URI: URI3,
      map: _map3,
      ap: _ap2,
      chain: _chain2
    };
    chainFirst3 = chainFirst(Chain2);
    Do2 = of2(emptyRecord);
    bindTo3 = bindTo(Functor3);
    let_3 = let_(Functor3);
    bind3 = bind(Chain2);
    apS3 = apS(Apply2);
    head2 = extract;
    tail2 = tail;
    last2 = function(as) {
      return as[as.length - 1];
    };
    min3 = function(O) {
      var S = min2(O);
      return function(as) {
        return as.reduce(S.concat);
      };
    };
    max3 = function(O) {
      var S = max2(O);
      return function(as) {
        return as.reduce(S.concat);
      };
    };
    concatAll2 = function(S) {
      return function(as) {
        return as.reduce(S.concat);
      };
    };
    intercalate = function(S) {
      var concatAllS = concatAll2(S);
      return function(middle) {
        return flow(intersperse(middle), concatAllS);
      };
    };
  }
});

// node_modules/fp-ts/es6/NonEmptyArray.js
var NonEmptyArray_exports = {};
__export(NonEmptyArray_exports, {
  Alt: () => Alt2,
  Applicative: () => Applicative2,
  Apply: () => Apply3,
  Chain: () => Chain3,
  Comonad: () => Comonad,
  Do: () => Do3,
  Foldable: () => Foldable2,
  FoldableWithIndex: () => FoldableWithIndex,
  Functor: () => Functor4,
  FunctorWithIndex: () => FunctorWithIndex,
  Monad: () => Monad2,
  Pointed: () => Pointed2,
  Traversable: () => Traversable2,
  TraversableWithIndex: () => TraversableWithIndex,
  URI: () => URI4,
  alt: () => alt2,
  altW: () => altW2,
  ap: () => ap4,
  apFirst: () => apFirst4,
  apS: () => apS4,
  apSecond: () => apSecond4,
  append: () => append2,
  appendW: () => appendW2,
  bind: () => bind4,
  bindTo: () => bindTo4,
  chain: () => chain3,
  chainFirst: () => chainFirst4,
  chainWithIndex: () => chainWithIndex2,
  chop: () => chop,
  chunksOf: () => chunksOf,
  concat: () => concat,
  concatAll: () => concatAll3,
  concatW: () => concatW,
  cons: () => cons,
  copy: () => copy,
  duplicate: () => duplicate3,
  extend: () => extend3,
  extract: () => extract2,
  filter: () => filter,
  filterWithIndex: () => filterWithIndex,
  flap: () => flap5,
  flatten: () => flatten3,
  fold: () => fold2,
  foldMap: () => foldMap3,
  foldMapWithIndex: () => foldMapWithIndex2,
  fromArray: () => fromArray,
  fromReadonlyNonEmptyArray: () => fromReadonlyNonEmptyArray2,
  getEq: () => getEq3,
  getSemigroup: () => getSemigroup4,
  getShow: () => getShow3,
  getUnionSemigroup: () => getUnionSemigroup,
  group: () => group,
  groupBy: () => groupBy,
  groupSort: () => groupSort,
  head: () => head3,
  init: () => init,
  insertAt: () => insertAt,
  intercalate: () => intercalate2,
  intersperse: () => intersperse2,
  isNonEmpty: () => isNonEmpty4,
  isOutOfBound: () => isOutOfBound2,
  last: () => last3,
  let: () => let_4,
  makeBy: () => makeBy,
  map: () => map4,
  mapWithIndex: () => mapWithIndex2,
  matchLeft: () => matchLeft,
  matchRight: () => matchRight,
  max: () => max4,
  min: () => min4,
  modifyAt: () => modifyAt,
  modifyHead: () => modifyHead,
  modifyLast: () => modifyLast,
  nonEmptyArray: () => nonEmptyArray,
  of: () => of3,
  prepend: () => prepend2,
  prependAll: () => prependAll2,
  prependToAll: () => prependToAll,
  prependW: () => prependW2,
  range: () => range,
  reduce: () => reduce3,
  reduceRight: () => reduceRight3,
  reduceRightWithIndex: () => reduceRightWithIndex2,
  reduceWithIndex: () => reduceWithIndex2,
  replicate: () => replicate,
  reverse: () => reverse2,
  rotate: () => rotate,
  sequence: () => sequence2,
  snoc: () => snoc,
  sort: () => sort,
  sortBy: () => sortBy,
  splitAt: () => splitAt,
  tail: () => tail3,
  traverse: () => traverse2,
  traverseWithIndex: () => traverseWithIndex,
  unappend: () => unappend,
  uncons: () => uncons,
  union: () => union2,
  uniq: () => uniq,
  unprepend: () => unprepend,
  unsafeInsertAt: () => unsafeInsertAt,
  unsafeUpdateAt: () => unsafeUpdateAt,
  unsnoc: () => unsnoc,
  unzip: () => unzip,
  updateAt: () => updateAt,
  updateHead: () => updateHead,
  updateLast: () => updateLast,
  zip: () => zip,
  zipWith: () => zipWith
});
function concatW(second) {
  return function(first2) {
    return first2.concat(second);
  };
}
function concat(x, y) {
  return y ? x.concat(y) : function(y2) {
    return y2.concat(x);
  };
}
function group(E) {
  return function(as) {
    var len = as.length;
    if (len === 0) {
      return [];
    }
    var out = [];
    var head6 = as[0];
    var nea = [head6];
    for (var i = 1; i < len; i++) {
      var a = as[i];
      if (E.equals(a, head6)) {
        nea.push(a);
      } else {
        out.push(nea);
        head6 = a;
        nea = [head6];
      }
    }
    out.push(nea);
    return out;
  };
}
function zip(as, bs) {
  if (bs === void 0) {
    return function(bs2) {
      return zip(bs2, as);
    };
  }
  return zipWith(as, bs, function(a, b) {
    return [a, b];
  });
}
function groupSort(O) {
  var sortO = sort(O);
  var groupO = group(O);
  return function(as) {
    return isNonEmpty4(as) ? groupO(sortO(as)) : [];
  };
}
function filter(predicate) {
  return filterWithIndex(function(_, a) {
    return predicate(a);
  });
}
function cons(head6, tail5) {
  return tail5 === void 0 ? prepend2(head6) : pipe(tail5, prepend2(head6));
}
var __spreadArray4, isNonEmpty4, isOutOfBound2, prependW2, prepend2, appendW2, append2, unsafeInsertAt, unsafeUpdateAt, uniq, sortBy, union2, rotate, fromReadonlyNonEmptyArray2, fromArray, makeBy, replicate, range, unprepend, unappend, reverse2, groupBy, sort, insertAt, updateAt, modifyAt, copy, of3, zipWith, unzip, prependAll2, intersperse2, foldMapWithIndex2, foldMap3, chainWithIndex2, chop, splitAt, chunksOf, _map4, _mapWithIndex, _ap3, _chain3, _extend2, _reduce2, _foldMap2, _reduceRight2, _traverse2, _alt2, _reduceWithIndex, _foldMapWithIndex, _reduceRightWithIndex, _traverseWithIndex, altW2, alt2, ap4, chain3, extend3, duplicate3, flatten3, map4, mapWithIndex2, reduce3, reduceWithIndex2, reduceRight3, reduceRightWithIndex2, traverse2, sequence2, traverseWithIndex, extract2, URI4, getShow3, getSemigroup4, getEq3, getUnionSemigroup, Functor4, flap5, Pointed2, FunctorWithIndex, Apply3, apFirst4, apSecond4, Applicative2, Chain3, chainFirst4, Monad2, Foldable2, FoldableWithIndex, Traversable2, TraversableWithIndex, Alt2, Comonad, Do3, bindTo4, let_4, bind4, apS4, head3, tail3, last3, init, min4, max4, concatAll3, matchLeft, matchRight, modifyHead, updateHead, modifyLast, updateLast, intercalate2, filterWithIndex, uncons, unsnoc, snoc, prependToAll, fold2, nonEmptyArray;
var init_NonEmptyArray = __esm({
  "node_modules/fp-ts/es6/NonEmptyArray.js"() {
    init_shim();
    init_Apply();
    init_Chain();
    init_function();
    init_Functor();
    init_internal();
    init_Ord();
    init_ReadonlyNonEmptyArray();
    __spreadArray4 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    isNonEmpty4 = function(as) {
      return as.length > 0;
    };
    isOutOfBound2 = function(i, as) {
      return i < 0 || i >= as.length;
    };
    prependW2 = function(head6) {
      return function(tail5) {
        return __spreadArray4([head6], tail5, true);
      };
    };
    prepend2 = prependW2;
    appendW2 = function(end) {
      return function(init4) {
        return __spreadArray4(__spreadArray4([], init4, true), [end], false);
      };
    };
    append2 = appendW2;
    unsafeInsertAt = function(i, a, as) {
      if (isNonEmpty4(as)) {
        var xs = fromReadonlyNonEmptyArray2(as);
        xs.splice(i, 0, a);
        return xs;
      }
      return [a];
    };
    unsafeUpdateAt = function(i, a, as) {
      var xs = fromReadonlyNonEmptyArray2(as);
      xs[i] = a;
      return xs;
    };
    uniq = function(E) {
      return function(as) {
        if (as.length === 1) {
          return copy(as);
        }
        var out = [head3(as)];
        var rest = tail3(as);
        var _loop_1 = function(a2) {
          if (out.every(function(o) {
            return !E.equals(o, a2);
          })) {
            out.push(a2);
          }
        };
        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {
          var a = rest_1[_i];
          _loop_1(a);
        }
        return out;
      };
    };
    sortBy = function(ords) {
      if (isNonEmpty4(ords)) {
        var M = getMonoid();
        return sort(ords.reduce(M.concat, M.empty));
      }
      return copy;
    };
    union2 = function(E) {
      var uniqE = uniq(E);
      return function(second) {
        return function(first2) {
          return uniqE(pipe(first2, concat(second)));
        };
      };
    };
    rotate = function(n) {
      return function(as) {
        var len = as.length;
        var m = Math.round(n) % len;
        if (isOutOfBound2(Math.abs(m), as) || m === 0) {
          return copy(as);
        }
        if (m < 0) {
          var _a = splitAt(-m)(as), f = _a[0], s = _a[1];
          return pipe(s, concat(f));
        } else {
          return rotate(m - len)(as);
        }
      };
    };
    fromReadonlyNonEmptyArray2 = fromReadonlyNonEmptyArray;
    fromArray = function(as) {
      return isNonEmpty4(as) ? some(as) : none;
    };
    makeBy = function(f) {
      return function(n) {
        var j = Math.max(0, Math.floor(n));
        var out = [f(0)];
        for (var i = 1; i < j; i++) {
          out.push(f(i));
        }
        return out;
      };
    };
    replicate = function(a) {
      return makeBy(function() {
        return a;
      });
    };
    range = function(start, end) {
      return start <= end ? makeBy(function(i) {
        return start + i;
      })(end - start + 1) : [start];
    };
    unprepend = function(as) {
      return [head3(as), tail3(as)];
    };
    unappend = function(as) {
      return [init(as), last3(as)];
    };
    reverse2 = function(as) {
      return __spreadArray4([last3(as)], as.slice(0, -1).reverse(), true);
    };
    groupBy = function(f) {
      return function(as) {
        var out = {};
        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
          var a = as_1[_i];
          var k = f(a);
          if (has.call(out, k)) {
            out[k].push(a);
          } else {
            out[k] = [a];
          }
        }
        return out;
      };
    };
    sort = function(O) {
      return function(as) {
        return as.slice().sort(O.compare);
      };
    };
    insertAt = function(i, a) {
      return function(as) {
        return i < 0 || i > as.length ? none : some(unsafeInsertAt(i, a, as));
      };
    };
    updateAt = function(i, a) {
      return modifyAt(i, function() {
        return a;
      });
    };
    modifyAt = function(i, f) {
      return function(as) {
        return isOutOfBound2(i, as) ? none : some(unsafeUpdateAt(i, f(as[i]), as));
      };
    };
    copy = fromReadonlyNonEmptyArray2;
    of3 = function(a) {
      return [a];
    };
    zipWith = function(as, bs, f) {
      var cs = [f(as[0], bs[0])];
      var len = Math.min(as.length, bs.length);
      for (var i = 1; i < len; i++) {
        cs[i] = f(as[i], bs[i]);
      }
      return cs;
    };
    unzip = function(abs) {
      var fa = [abs[0][0]];
      var fb = [abs[0][1]];
      for (var i = 1; i < abs.length; i++) {
        fa[i] = abs[i][0];
        fb[i] = abs[i][1];
      }
      return [fa, fb];
    };
    prependAll2 = function(middle) {
      return function(as) {
        var out = [middle, as[0]];
        for (var i = 1; i < as.length; i++) {
          out.push(middle, as[i]);
        }
        return out;
      };
    };
    intersperse2 = function(middle) {
      return function(as) {
        var rest = tail3(as);
        return isNonEmpty4(rest) ? pipe(rest, prependAll2(middle), prepend2(head3(as))) : copy(as);
      };
    };
    foldMapWithIndex2 = foldMapWithIndex;
    foldMap3 = foldMap2;
    chainWithIndex2 = function(f) {
      return function(as) {
        var out = fromReadonlyNonEmptyArray2(f(0, head3(as)));
        for (var i = 1; i < as.length; i++) {
          out.push.apply(out, f(i, as[i]));
        }
        return out;
      };
    };
    chop = function(f) {
      return function(as) {
        var _a = f(as), b = _a[0], rest = _a[1];
        var out = [b];
        var next = rest;
        while (isNonEmpty4(next)) {
          var _b = f(next), b_1 = _b[0], rest_2 = _b[1];
          out.push(b_1);
          next = rest_2;
        }
        return out;
      };
    };
    splitAt = function(n) {
      return function(as) {
        var m = Math.max(1, n);
        return m >= as.length ? [copy(as), []] : [pipe(as.slice(1, m), prepend2(head3(as))), as.slice(m)];
      };
    };
    chunksOf = function(n) {
      return chop(splitAt(n));
    };
    _map4 = function(fa, f) {
      return pipe(fa, map4(f));
    };
    _mapWithIndex = function(fa, f) {
      return pipe(fa, mapWithIndex2(f));
    };
    _ap3 = function(fab, fa) {
      return pipe(fab, ap4(fa));
    };
    _chain3 = function(ma, f) {
      return pipe(ma, chain3(f));
    };
    _extend2 = function(wa, f) {
      return pipe(wa, extend3(f));
    };
    _reduce2 = function(fa, b, f) {
      return pipe(fa, reduce3(b, f));
    };
    _foldMap2 = function(M) {
      var foldMapM = foldMap3(M);
      return function(fa, f) {
        return pipe(fa, foldMapM(f));
      };
    };
    _reduceRight2 = function(fa, b, f) {
      return pipe(fa, reduceRight3(b, f));
    };
    _traverse2 = function(F) {
      var traverseF = traverse2(F);
      return function(ta, f) {
        return pipe(ta, traverseF(f));
      };
    };
    _alt2 = function(fa, that) {
      return pipe(fa, alt2(that));
    };
    _reduceWithIndex = function(fa, b, f) {
      return pipe(fa, reduceWithIndex2(b, f));
    };
    _foldMapWithIndex = function(M) {
      var foldMapWithIndexM = foldMapWithIndex2(M);
      return function(fa, f) {
        return pipe(fa, foldMapWithIndexM(f));
      };
    };
    _reduceRightWithIndex = function(fa, b, f) {
      return pipe(fa, reduceRightWithIndex2(b, f));
    };
    _traverseWithIndex = function(F) {
      var traverseWithIndexF = traverseWithIndex(F);
      return function(ta, f) {
        return pipe(ta, traverseWithIndexF(f));
      };
    };
    altW2 = function(that) {
      return function(as) {
        return pipe(as, concatW(that()));
      };
    };
    alt2 = altW2;
    ap4 = function(as) {
      return chain3(function(f) {
        return pipe(as, map4(f));
      });
    };
    chain3 = function(f) {
      return chainWithIndex2(function(_, a) {
        return f(a);
      });
    };
    extend3 = function(f) {
      return function(as) {
        var next = tail3(as);
        var out = [f(as)];
        while (isNonEmpty4(next)) {
          out.push(f(next));
          next = tail3(next);
        }
        return out;
      };
    };
    duplicate3 = extend3(identity);
    flatten3 = chain3(identity);
    map4 = function(f) {
      return mapWithIndex2(function(_, a) {
        return f(a);
      });
    };
    mapWithIndex2 = function(f) {
      return function(as) {
        var out = [f(0, head3(as))];
        for (var i = 1; i < as.length; i++) {
          out.push(f(i, as[i]));
        }
        return out;
      };
    };
    reduce3 = reduce2;
    reduceWithIndex2 = reduceWithIndex;
    reduceRight3 = reduceRight2;
    reduceRightWithIndex2 = reduceRightWithIndex;
    traverse2 = function(F) {
      var traverseWithIndexF = traverseWithIndex(F);
      return function(f) {
        return traverseWithIndexF(function(_, a) {
          return f(a);
        });
      };
    };
    sequence2 = function(F) {
      return traverseWithIndex(F)(function(_, a) {
        return a;
      });
    };
    traverseWithIndex = function(F) {
      return function(f) {
        return function(as) {
          var out = F.map(f(0, head3(as)), of3);
          for (var i = 1; i < as.length; i++) {
            out = F.ap(F.map(out, function(bs) {
              return function(b) {
                return pipe(bs, append2(b));
              };
            }), f(i, as[i]));
          }
          return out;
        };
      };
    };
    extract2 = head2;
    URI4 = "NonEmptyArray";
    getShow3 = getShow2;
    getSemigroup4 = function() {
      return {
        concat
      };
    };
    getEq3 = getEq2;
    getUnionSemigroup = function(E) {
      var unionE = union2(E);
      return {
        concat: function(first2, second) {
          return unionE(second)(first2);
        }
      };
    };
    Functor4 = {
      URI: URI4,
      map: _map4
    };
    flap5 = flap(Functor4);
    Pointed2 = {
      URI: URI4,
      of: of3
    };
    FunctorWithIndex = {
      URI: URI4,
      map: _map4,
      mapWithIndex: _mapWithIndex
    };
    Apply3 = {
      URI: URI4,
      map: _map4,
      ap: _ap3
    };
    apFirst4 = apFirst(Apply3);
    apSecond4 = apSecond(Apply3);
    Applicative2 = {
      URI: URI4,
      map: _map4,
      ap: _ap3,
      of: of3
    };
    Chain3 = {
      URI: URI4,
      map: _map4,
      ap: _ap3,
      chain: _chain3
    };
    chainFirst4 = chainFirst(Chain3);
    Monad2 = {
      URI: URI4,
      map: _map4,
      ap: _ap3,
      of: of3,
      chain: _chain3
    };
    Foldable2 = {
      URI: URI4,
      reduce: _reduce2,
      foldMap: _foldMap2,
      reduceRight: _reduceRight2
    };
    FoldableWithIndex = {
      URI: URI4,
      reduce: _reduce2,
      foldMap: _foldMap2,
      reduceRight: _reduceRight2,
      reduceWithIndex: _reduceWithIndex,
      foldMapWithIndex: _foldMapWithIndex,
      reduceRightWithIndex: _reduceRightWithIndex
    };
    Traversable2 = {
      URI: URI4,
      map: _map4,
      reduce: _reduce2,
      foldMap: _foldMap2,
      reduceRight: _reduceRight2,
      traverse: _traverse2,
      sequence: sequence2
    };
    TraversableWithIndex = {
      URI: URI4,
      map: _map4,
      mapWithIndex: _mapWithIndex,
      reduce: _reduce2,
      foldMap: _foldMap2,
      reduceRight: _reduceRight2,
      traverse: _traverse2,
      sequence: sequence2,
      reduceWithIndex: _reduceWithIndex,
      foldMapWithIndex: _foldMapWithIndex,
      reduceRightWithIndex: _reduceRightWithIndex,
      traverseWithIndex: _traverseWithIndex
    };
    Alt2 = {
      URI: URI4,
      map: _map4,
      alt: _alt2
    };
    Comonad = {
      URI: URI4,
      map: _map4,
      extend: _extend2,
      extract: extract2
    };
    Do3 = of3(emptyRecord);
    bindTo4 = bindTo(Functor4);
    let_4 = let_(Functor4);
    bind4 = bind(Chain3);
    apS4 = apS(Apply3);
    head3 = head2;
    tail3 = function(as) {
      return as.slice(1);
    };
    last3 = last2;
    init = function(as) {
      return as.slice(0, -1);
    };
    min4 = min3;
    max4 = max3;
    concatAll3 = function(S) {
      return function(as) {
        return as.reduce(S.concat);
      };
    };
    matchLeft = function(f) {
      return function(as) {
        return f(head3(as), tail3(as));
      };
    };
    matchRight = function(f) {
      return function(as) {
        return f(init(as), last3(as));
      };
    };
    modifyHead = function(f) {
      return function(as) {
        return __spreadArray4([f(head3(as))], tail3(as), true);
      };
    };
    updateHead = function(a) {
      return modifyHead(function() {
        return a;
      });
    };
    modifyLast = function(f) {
      return function(as) {
        return pipe(init(as), append2(f(last3(as))));
      };
    };
    updateLast = function(a) {
      return modifyLast(function() {
        return a;
      });
    };
    intercalate2 = intercalate;
    filterWithIndex = function(predicate) {
      return function(as) {
        return fromArray(as.filter(function(a, i) {
          return predicate(i, a);
        }));
      };
    };
    uncons = unprepend;
    unsnoc = unappend;
    snoc = function(init4, end) {
      return pipe(init4, append2(end));
    };
    prependToAll = prependAll2;
    fold2 = concatAll2;
    nonEmptyArray = {
      URI: URI4,
      of: of3,
      map: _map4,
      mapWithIndex: _mapWithIndex,
      ap: _ap3,
      chain: _chain3,
      extend: _extend2,
      extract: extract2,
      reduce: _reduce2,
      foldMap: _foldMap2,
      reduceRight: _reduceRight2,
      traverse: _traverse2,
      sequence: sequence2,
      reduceWithIndex: _reduceWithIndex,
      foldMapWithIndex: _foldMapWithIndex,
      reduceRightWithIndex: _reduceRightWithIndex,
      traverseWithIndex: _traverseWithIndex,
      alt: _alt2
    };
  }
});

// node_modules/fp-ts/es6/number.js
var Eq, Ord, Bounded, MagmaSub, SemigroupSum, SemigroupProduct, MonoidSum, MonoidProduct, Field;
var init_number = __esm({
  "node_modules/fp-ts/es6/number.js"() {
    init_shim();
    Eq = {
      equals: function(first2, second) {
        return first2 === second;
      }
    };
    Ord = {
      equals: Eq.equals,
      compare: function(first2, second) {
        return first2 < second ? -1 : first2 > second ? 1 : 0;
      }
    };
    Bounded = {
      equals: Eq.equals,
      compare: Ord.compare,
      top: Infinity,
      bottom: -Infinity
    };
    MagmaSub = {
      concat: function(first2, second) {
        return first2 - second;
      }
    };
    SemigroupSum = {
      concat: function(first2, second) {
        return first2 + second;
      }
    };
    SemigroupProduct = {
      concat: function(first2, second) {
        return first2 * second;
      }
    };
    MonoidSum = {
      concat: SemigroupSum.concat,
      empty: 0
    };
    MonoidProduct = {
      concat: SemigroupProduct.concat,
      empty: 1
    };
    Field = {
      add: SemigroupSum.concat,
      zero: 0,
      mul: SemigroupProduct.concat,
      one: 1,
      sub: MagmaSub.concat,
      degree: function(_) {
        return 1;
      },
      div: function(first2, second) {
        return first2 / second;
      },
      mod: function(first2, second) {
        return first2 % second;
      }
    };
  }
});

// node_modules/fp-ts/es6/Zero.js
function guard(F, P) {
  return function(b) {
    return b ? P.of(void 0) : F.zero();
  };
}
var init_Zero = __esm({
  "node_modules/fp-ts/es6/Zero.js"() {
    init_shim();
  }
});

// node_modules/fp-ts/es6/ReadonlyArray.js
function lookup(i, as) {
  return as === void 0 ? function(as2) {
    return lookup(i, as2);
  } : isOutOfBound3(i, as) ? none : some(as[i]);
}
function findFirst(predicate) {
  return function(as) {
    for (var i = 0; i < as.length; i++) {
      if (predicate(as[i])) {
        return some(as[i]);
      }
    }
    return none;
  };
}
function findLast(predicate) {
  return function(as) {
    for (var i = as.length - 1; i >= 0; i--) {
      if (predicate(as[i])) {
        return some(as[i]);
      }
    }
    return none;
  };
}
function elem2(E) {
  return function(a, as) {
    if (as === void 0) {
      var elemE_1 = elem2(E);
      return function(as2) {
        return elemE_1(a, as2);
      };
    }
    var predicate = function(element) {
      return E.equals(element, a);
    };
    var i = 0;
    for (; i < as.length; i++) {
      if (predicate(as[i])) {
        return true;
      }
    }
    return false;
  };
}
function every(predicate) {
  return function(as) {
    return as.every(predicate);
  };
}
var __spreadArray5, isEmpty, isNonEmpty5, append3, fromEither, matchW2, match2, chainWithIndex3, isOutOfBound3, head4, last4, findIndex, findFirstMap, findLastMap, findLastIndex, _map5, _ap4, _chain4, _filter, _filterMap, _partition, _partitionMap, _reduce3, _foldMap3, _reduceRight3, _traverse3, _chainRecDepthFirst, _chainRecBreadthFirst, of4, zero, ap5, chain4, flatten4, map5, separate, filter2, filterMapWithIndex, filterMap, compact, partition, partitionWithIndex, partitionMap, partitionMapWithIndex, extend4, duplicate4, foldMapWithIndex3, reduce4, foldMap4, reduceWithIndex3, reduceRight4, reduceRightWithIndex3, traverse3, sequence3, traverseWithIndex2, URI5, getShow4, getEq4, getOrd, Functor5, flap6, Pointed3, Apply4, apFirst5, apSecond5, Chain4, chainFirst5, Zero, guard2, Compactable, Traversable3, chainRecDepthFirst, chainRecBreadthFirst, _wither, _wilt, Witherable, filterE2, FromEither2, fromEitherK2, empty2, intercalate3, Do4, bindTo5, let_5, bind5, apS5;
var init_ReadonlyArray = __esm({
  "node_modules/fp-ts/es6/ReadonlyArray.js"() {
    init_shim();
    init_Apply();
    init_Chain();
    init_Eq();
    init_FromEither();
    init_function();
    init_Functor();
    init_internal();
    init_number();
    init_Ord();
    init_ReadonlyNonEmptyArray();
    init_Separated();
    init_Witherable();
    init_Zero();
    __spreadArray5 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    isEmpty = function(as) {
      return as.length === 0;
    };
    isNonEmpty5 = isNonEmpty3;
    append3 = append;
    fromEither = function(e) {
      return isLeft(e) ? empty2 : [e.right];
    };
    matchW2 = function(onEmpty, onNonEmpty) {
      return function(as) {
        return isNonEmpty5(as) ? onNonEmpty(as) : onEmpty();
      };
    };
    match2 = matchW2;
    chainWithIndex3 = function(f) {
      return function(as) {
        if (isEmpty(as)) {
          return empty2;
        }
        var out = [];
        for (var i = 0; i < as.length; i++) {
          out.push.apply(out, f(i, as[i]));
        }
        return out;
      };
    };
    isOutOfBound3 = isOutOfBound;
    head4 = function(as) {
      return isNonEmpty5(as) ? some(head2(as)) : none;
    };
    last4 = function(as) {
      return isNonEmpty5(as) ? some(last2(as)) : none;
    };
    findIndex = function(predicate) {
      return function(as) {
        for (var i = 0; i < as.length; i++) {
          if (predicate(as[i])) {
            return some(i);
          }
        }
        return none;
      };
    };
    findFirstMap = function(f) {
      return function(as) {
        for (var i = 0; i < as.length; i++) {
          var out = f(as[i]);
          if (isSome(out)) {
            return out;
          }
        }
        return none;
      };
    };
    findLastMap = function(f) {
      return function(as) {
        for (var i = as.length - 1; i >= 0; i--) {
          var out = f(as[i]);
          if (isSome(out)) {
            return out;
          }
        }
        return none;
      };
    };
    findLastIndex = function(predicate) {
      return function(as) {
        for (var i = as.length - 1; i >= 0; i--) {
          if (predicate(as[i])) {
            return some(i);
          }
        }
        return none;
      };
    };
    _map5 = function(fa, f) {
      return pipe(fa, map5(f));
    };
    _ap4 = function(fab, fa) {
      return pipe(fab, ap5(fa));
    };
    _chain4 = function(ma, f) {
      return pipe(ma, chain4(f));
    };
    _filter = function(fa, predicate) {
      return pipe(fa, filter2(predicate));
    };
    _filterMap = function(fa, f) {
      return pipe(fa, filterMap(f));
    };
    _partition = function(fa, predicate) {
      return pipe(fa, partition(predicate));
    };
    _partitionMap = function(fa, f) {
      return pipe(fa, partitionMap(f));
    };
    _reduce3 = function(fa, b, f) {
      return pipe(fa, reduce4(b, f));
    };
    _foldMap3 = function(M) {
      var foldMapM = foldMap4(M);
      return function(fa, f) {
        return pipe(fa, foldMapM(f));
      };
    };
    _reduceRight3 = function(fa, b, f) {
      return pipe(fa, reduceRight4(b, f));
    };
    _traverse3 = function(F) {
      var traverseF = traverse3(F);
      return function(ta, f) {
        return pipe(ta, traverseF(f));
      };
    };
    _chainRecDepthFirst = function(a, f) {
      return pipe(a, chainRecDepthFirst(f));
    };
    _chainRecBreadthFirst = function(a, f) {
      return pipe(a, chainRecBreadthFirst(f));
    };
    of4 = of2;
    zero = function() {
      return empty2;
    };
    ap5 = function(fa) {
      return chain4(function(f) {
        return pipe(fa, map5(f));
      });
    };
    chain4 = function(f) {
      return function(ma) {
        return pipe(ma, chainWithIndex3(function(_, a) {
          return f(a);
        }));
      };
    };
    flatten4 = chain4(identity);
    map5 = function(f) {
      return function(fa) {
        return fa.map(function(a) {
          return f(a);
        });
      };
    };
    separate = function(fa) {
      var left4 = [];
      var right4 = [];
      for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {
        var e = fa_1[_i];
        if (e._tag === "Left") {
          left4.push(e.left);
        } else {
          right4.push(e.right);
        }
      }
      return separated(left4, right4);
    };
    filter2 = function(predicate) {
      return function(as) {
        return as.filter(predicate);
      };
    };
    filterMapWithIndex = function(f) {
      return function(fa) {
        var out = [];
        for (var i = 0; i < fa.length; i++) {
          var optionB = f(i, fa[i]);
          if (isSome(optionB)) {
            out.push(optionB.value);
          }
        }
        return out;
      };
    };
    filterMap = function(f) {
      return filterMapWithIndex(function(_, a) {
        return f(a);
      });
    };
    compact = filterMap(identity);
    partition = function(predicate) {
      return partitionWithIndex(function(_, a) {
        return predicate(a);
      });
    };
    partitionWithIndex = function(predicateWithIndex) {
      return function(as) {
        var left4 = [];
        var right4 = [];
        for (var i = 0; i < as.length; i++) {
          var a = as[i];
          if (predicateWithIndex(i, a)) {
            right4.push(a);
          } else {
            left4.push(a);
          }
        }
        return separated(left4, right4);
      };
    };
    partitionMap = function(f) {
      return partitionMapWithIndex(function(_, a) {
        return f(a);
      });
    };
    partitionMapWithIndex = function(f) {
      return function(fa) {
        var left4 = [];
        var right4 = [];
        for (var i = 0; i < fa.length; i++) {
          var e = f(i, fa[i]);
          if (e._tag === "Left") {
            left4.push(e.left);
          } else {
            right4.push(e.right);
          }
        }
        return separated(left4, right4);
      };
    };
    extend4 = function(f) {
      return function(wa) {
        return wa.map(function(_, i) {
          return f(wa.slice(i));
        });
      };
    };
    duplicate4 = extend4(identity);
    foldMapWithIndex3 = function(M) {
      return function(f) {
        return function(fa) {
          return fa.reduce(function(b, a, i) {
            return M.concat(b, f(i, a));
          }, M.empty);
        };
      };
    };
    reduce4 = function(b, f) {
      return reduceWithIndex3(b, function(_, b2, a) {
        return f(b2, a);
      });
    };
    foldMap4 = function(M) {
      var foldMapWithIndexM = foldMapWithIndex3(M);
      return function(f) {
        return foldMapWithIndexM(function(_, a) {
          return f(a);
        });
      };
    };
    reduceWithIndex3 = function(b, f) {
      return function(fa) {
        var len = fa.length;
        var out = b;
        for (var i = 0; i < len; i++) {
          out = f(i, out, fa[i]);
        }
        return out;
      };
    };
    reduceRight4 = function(b, f) {
      return reduceRightWithIndex3(b, function(_, a, b2) {
        return f(a, b2);
      });
    };
    reduceRightWithIndex3 = function(b, f) {
      return function(fa) {
        return fa.reduceRight(function(b2, a, i) {
          return f(i, a, b2);
        }, b);
      };
    };
    traverse3 = function(F) {
      var traverseWithIndexF = traverseWithIndex2(F);
      return function(f) {
        return traverseWithIndexF(function(_, a) {
          return f(a);
        });
      };
    };
    sequence3 = function(F) {
      return function(ta) {
        return _reduce3(ta, F.of(zero()), function(fas, fa) {
          return F.ap(F.map(fas, function(as) {
            return function(a) {
              return pipe(as, append3(a));
            };
          }), fa);
        });
      };
    };
    traverseWithIndex2 = function(F) {
      return function(f) {
        return reduceWithIndex3(F.of(zero()), function(i, fbs, a) {
          return F.ap(F.map(fbs, function(bs) {
            return function(b) {
              return pipe(bs, append3(b));
            };
          }), f(i, a));
        });
      };
    };
    URI5 = "ReadonlyArray";
    getShow4 = function(S) {
      return {
        show: function(as) {
          return "[".concat(as.map(S.show).join(", "), "]");
        }
      };
    };
    getEq4 = function(E) {
      return fromEquals(function(xs, ys) {
        return xs.length === ys.length && xs.every(function(x, i) {
          return E.equals(x, ys[i]);
        });
      });
    };
    getOrd = function(O) {
      return fromCompare(function(a, b) {
        var aLen = a.length;
        var bLen = b.length;
        var len = Math.min(aLen, bLen);
        for (var i = 0; i < len; i++) {
          var ordering = O.compare(a[i], b[i]);
          if (ordering !== 0) {
            return ordering;
          }
        }
        return Ord.compare(aLen, bLen);
      });
    };
    Functor5 = {
      URI: URI5,
      map: _map5
    };
    flap6 = flap(Functor5);
    Pointed3 = {
      URI: URI5,
      of: of4
    };
    Apply4 = {
      URI: URI5,
      map: _map5,
      ap: _ap4
    };
    apFirst5 = apFirst(Apply4);
    apSecond5 = apSecond(Apply4);
    Chain4 = {
      URI: URI5,
      map: _map5,
      ap: _ap4,
      chain: _chain4
    };
    chainFirst5 = chainFirst(Chain4);
    Zero = {
      URI: URI5,
      zero
    };
    guard2 = guard(Zero, Pointed3);
    Compactable = {
      URI: URI5,
      compact,
      separate
    };
    Traversable3 = {
      URI: URI5,
      map: _map5,
      reduce: _reduce3,
      foldMap: _foldMap3,
      reduceRight: _reduceRight3,
      traverse: _traverse3,
      sequence: sequence3
    };
    chainRecDepthFirst = function(f) {
      return function(a) {
        var todo = __spreadArray5([], f(a), true);
        var out = [];
        while (todo.length > 0) {
          var e = todo.shift();
          if (isLeft(e)) {
            todo.unshift.apply(todo, f(e.left));
          } else {
            out.push(e.right);
          }
        }
        return out;
      };
    };
    chainRecBreadthFirst = function(f) {
      return function(a) {
        var initial = f(a);
        var todo = [];
        var out = [];
        function go(e2) {
          if (isLeft(e2)) {
            f(e2.left).forEach(function(v) {
              return todo.push(v);
            });
          } else {
            out.push(e2.right);
          }
        }
        for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {
          var e = initial_1[_i];
          go(e);
        }
        while (todo.length > 0) {
          go(todo.shift());
        }
        return out;
      };
    };
    _wither = witherDefault(Traversable3, Compactable);
    _wilt = wiltDefault(Traversable3, Compactable);
    Witherable = {
      URI: URI5,
      map: _map5,
      compact,
      separate,
      filter: _filter,
      filterMap: _filterMap,
      partition: _partition,
      partitionMap: _partitionMap,
      reduce: _reduce3,
      foldMap: _foldMap3,
      reduceRight: _reduceRight3,
      traverse: _traverse3,
      sequence: sequence3,
      wither: _wither,
      wilt: _wilt
    };
    filterE2 = filterE(Witherable);
    FromEither2 = {
      URI: URI5,
      fromEither
    };
    fromEitherK2 = fromEitherK(FromEither2);
    empty2 = empty;
    intercalate3 = function(M) {
      var intercalateM = intercalate(M);
      return function(middle) {
        return match2(function() {
          return M.empty;
        }, intercalateM(middle));
      };
    };
    Do4 = of4(emptyRecord);
    bindTo5 = bindTo(Functor5);
    let_5 = let_(Functor5);
    bind5 = bind(Chain4);
    apS5 = apS(Apply4);
  }
});

// node_modules/fp-ts/es6/Array.js
var Array_exports = {};
__export(Array_exports, {
  Alt: () => Alt3,
  Alternative: () => Alternative,
  Applicative: () => Applicative3,
  Apply: () => Apply5,
  Chain: () => Chain5,
  ChainRecBreadthFirst: () => ChainRecBreadthFirst,
  ChainRecDepthFirst: () => ChainRecDepthFirst,
  Compactable: () => Compactable2,
  Do: () => Do5,
  Extend: () => Extend2,
  Filterable: () => Filterable,
  FilterableWithIndex: () => FilterableWithIndex,
  Foldable: () => Foldable3,
  FoldableWithIndex: () => FoldableWithIndex2,
  FromEither: () => FromEither3,
  Functor: () => Functor6,
  FunctorWithIndex: () => FunctorWithIndex2,
  Monad: () => Monad3,
  Pointed: () => Pointed4,
  Traversable: () => Traversable4,
  TraversableWithIndex: () => TraversableWithIndex2,
  URI: () => URI6,
  Unfoldable: () => Unfoldable,
  Witherable: () => Witherable2,
  Zero: () => Zero2,
  alt: () => alt3,
  altW: () => altW3,
  ap: () => ap6,
  apFirst: () => apFirst6,
  apS: () => apS6,
  apSecond: () => apSecond6,
  append: () => append4,
  appendW: () => appendW3,
  array: () => array2,
  bind: () => bind6,
  bindTo: () => bindTo6,
  chain: () => chain5,
  chainFirst: () => chainFirst6,
  chainRecBreadthFirst: () => chainRecBreadthFirst2,
  chainRecDepthFirst: () => chainRecDepthFirst2,
  chainWithIndex: () => chainWithIndex4,
  chop: () => chop3,
  chunksOf: () => chunksOf3,
  compact: () => compact2,
  comprehension: () => comprehension,
  concat: () => concat2,
  concatW: () => concatW2,
  cons: () => cons3,
  copy: () => copy2,
  deleteAt: () => deleteAt,
  difference: () => difference,
  dropLeft: () => dropLeft,
  dropLeftWhile: () => dropLeftWhile,
  dropRight: () => dropRight,
  duplicate: () => duplicate5,
  elem: () => elem3,
  empty: () => empty3,
  every: () => every2,
  exists: () => exists2,
  extend: () => extend5,
  filter: () => filter3,
  filterE: () => filterE3,
  filterMap: () => filterMap2,
  filterMapWithIndex: () => filterMapWithIndex2,
  filterWithIndex: () => filterWithIndex2,
  findFirst: () => findFirst2,
  findFirstMap: () => findFirstMap2,
  findIndex: () => findIndex2,
  findLast: () => findLast2,
  findLastIndex: () => findLastIndex2,
  findLastMap: () => findLastMap2,
  flap: () => flap7,
  flatten: () => flatten5,
  foldLeft: () => foldLeft,
  foldMap: () => foldMap5,
  foldMapWithIndex: () => foldMapWithIndex4,
  foldRight: () => foldRight,
  fromEither: () => fromEither2,
  fromEitherK: () => fromEitherK3,
  fromOption: () => fromOption3,
  fromOptionK: () => fromOptionK3,
  fromPredicate: () => fromPredicate3,
  getDifferenceMagma: () => getDifferenceMagma,
  getEq: () => getEq5,
  getIntersectionSemigroup: () => getIntersectionSemigroup,
  getMonoid: () => getMonoid2,
  getOrd: () => getOrd2,
  getSemigroup: () => getSemigroup5,
  getShow: () => getShow5,
  getUnionMonoid: () => getUnionMonoid,
  getUnionSemigroup: () => getUnionSemigroup2,
  guard: () => guard3,
  head: () => head5,
  init: () => init3,
  insertAt: () => insertAt2,
  intercalate: () => intercalate4,
  intersection: () => intersection2,
  intersperse: () => intersperse3,
  isEmpty: () => isEmpty2,
  isNonEmpty: () => isNonEmpty6,
  isOutOfBound: () => isOutOfBound4,
  last: () => last5,
  lefts: () => lefts,
  let: () => let_6,
  lookup: () => lookup2,
  makeBy: () => makeBy3,
  map: () => map6,
  mapWithIndex: () => mapWithIndex3,
  match: () => match3,
  matchLeft: () => matchLeft2,
  matchLeftW: () => matchLeftW,
  matchRight: () => matchRight2,
  matchRightW: () => matchRightW,
  matchW: () => matchW3,
  modifyAt: () => modifyAt2,
  of: () => of5,
  partition: () => partition2,
  partitionMap: () => partitionMap2,
  partitionMapWithIndex: () => partitionMapWithIndex2,
  partitionWithIndex: () => partitionWithIndex2,
  prepend: () => prepend3,
  prependAll: () => prependAll3,
  prependToAll: () => prependToAll2,
  prependW: () => prependW3,
  range: () => range3,
  reduce: () => reduce5,
  reduceRight: () => reduceRight5,
  reduceRightWithIndex: () => reduceRightWithIndex4,
  reduceWithIndex: () => reduceWithIndex4,
  replicate: () => replicate2,
  reverse: () => reverse3,
  rights: () => rights,
  rotate: () => rotate3,
  scanLeft: () => scanLeft,
  scanRight: () => scanRight,
  separate: () => separate2,
  sequence: () => sequence4,
  size: () => size,
  snoc: () => snoc3,
  some: () => some2,
  sort: () => sort2,
  sortBy: () => sortBy3,
  spanLeft: () => spanLeft,
  splitAt: () => splitAt3,
  tail: () => tail4,
  takeLeft: () => takeLeft,
  takeLeftWhile: () => takeLeftWhile,
  takeRight: () => takeRight,
  traverse: () => traverse4,
  traverseWithIndex: () => traverseWithIndex3,
  unfold: () => unfold,
  union: () => union4,
  uniq: () => uniq3,
  unsafeDeleteAt: () => unsafeDeleteAt,
  unsafeInsertAt: () => unsafeInsertAt3,
  unsafeUpdateAt: () => unsafeUpdateAt3,
  unzip: () => unzip2,
  updateAt: () => updateAt2,
  wilt: () => wilt,
  wither: () => wither,
  zero: () => zero2,
  zip: () => zip2,
  zipWith: () => zipWith2
});
function fromPredicate3(predicate) {
  return function(a) {
    return predicate(a) ? [a] : [];
  };
}
function takeLeftWhile(predicate) {
  return function(as) {
    var out = [];
    for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
      var a = as_1[_i];
      if (!predicate(a)) {
        break;
      }
      out.push(a);
    }
    return out;
  };
}
function spanLeft(predicate) {
  return function(as) {
    var _a = splitAt3(spanLeftIndex(as, predicate))(as), init4 = _a[0], rest = _a[1];
    return { init: init4, rest };
  };
}
function dropLeftWhile(predicate) {
  return function(as) {
    return as.slice(spanLeftIndex(as, predicate));
  };
}
function findFirst2(predicate) {
  return findFirst(predicate);
}
function findLast2(predicate) {
  return findLast(predicate);
}
function zip2(as, bs) {
  if (bs === void 0) {
    return function(bs2) {
      return zip2(bs2, as);
    };
  }
  return zipWith2(as, bs, function(a, b) {
    return [a, b];
  });
}
function comprehension(input, f, g) {
  if (g === void 0) {
    g = function() {
      return true;
    };
  }
  var go = function(scope, input2) {
    return isNonEmpty6(input2) ? pipe(head3(input2), chain5(function(x) {
      return go(pipe(scope, append4(x)), tail3(input2));
    })) : g.apply(void 0, scope) ? [f.apply(void 0, scope)] : [];
  };
  return go([], input);
}
function union4(E) {
  var unionE = union2(E);
  return function(first2, second) {
    if (second === void 0) {
      var unionE_1 = union4(E);
      return function(second2) {
        return unionE_1(second2, first2);
      };
    }
    return isNonEmpty6(first2) && isNonEmpty6(second) ? unionE(second)(first2) : isNonEmpty6(first2) ? copy2(first2) : copy2(second);
  };
}
function intersection2(E) {
  var elemE = elem3(E);
  return function(xs, ys) {
    if (ys === void 0) {
      var intersectionE_1 = intersection2(E);
      return function(ys2) {
        return intersectionE_1(ys2, xs);
      };
    }
    return xs.filter(function(a) {
      return elemE(a, ys);
    });
  };
}
function difference(E) {
  var elemE = elem3(E);
  return function(xs, ys) {
    if (ys === void 0) {
      var differenceE_1 = difference(E);
      return function(ys2) {
        return differenceE_1(ys2, xs);
      };
    }
    return xs.filter(function(a) {
      return !elemE(a, ys);
    });
  };
}
var isEmpty2, isNonEmpty6, prepend3, prependW3, append4, appendW3, makeBy3, replicate2, fromOption3, fromEither2, matchW3, match3, matchLeftW, matchLeft2, foldLeft, matchRightW, matchRight2, foldRight, chainWithIndex4, scanLeft, scanRight, size, isOutOfBound4, lookup2, head5, last5, tail4, init3, takeLeft, takeRight, spanLeftIndex, dropLeft, dropRight, findIndex2, findFirstMap2, findLastMap2, findLastIndex2, copy2, insertAt2, updateAt2, deleteAt, modifyAt2, reverse3, rights, lefts, sort2, zipWith2, unzip2, prependAll3, intersperse3, rotate3, elem3, uniq3, sortBy3, chop3, splitAt3, chunksOf3, fromOptionK3, concatW2, concat2, _map6, _mapWithIndex2, _ap5, _chain5, _filter2, _filterMap2, _partition2, _partitionMap2, _partitionWithIndex, _partitionMapWithIndex, _alt3, _reduce4, _foldMap4, _reduceRight4, _reduceWithIndex2, _foldMapWithIndex2, _reduceRightWithIndex2, _filterMapWithIndex, _filterWithIndex, _extend3, _traverse4, _traverseWithIndex2, _chainRecDepthFirst2, _chainRecBreadthFirst2, of5, zero2, map6, ap6, chain5, flatten5, mapWithIndex3, filterMapWithIndex2, filterMap2, compact2, separate2, filter3, partition2, partitionWithIndex2, partitionMap2, partitionMapWithIndex2, altW3, alt3, filterWithIndex2, extend5, duplicate5, foldMap5, foldMapWithIndex4, reduce5, reduceWithIndex4, reduceRight5, reduceRightWithIndex4, traverse4, sequence4, traverseWithIndex3, wither, wilt, unfold, URI6, getShow5, getSemigroup5, getMonoid2, getEq5, getOrd2, getUnionSemigroup2, getUnionMonoid, getIntersectionSemigroup, getDifferenceMagma, Functor6, flap7, Pointed4, FunctorWithIndex2, Apply5, apFirst6, apSecond6, Applicative3, Chain5, chainFirst6, Monad3, Unfoldable, Alt3, Zero2, guard3, Alternative, Extend2, Compactable2, Filterable, FilterableWithIndex, Foldable3, FoldableWithIndex2, Traversable4, TraversableWithIndex2, _wither2, _wilt2, Witherable2, chainRecDepthFirst2, ChainRecDepthFirst, chainRecBreadthFirst2, ChainRecBreadthFirst, filterE3, FromEither3, fromEitherK3, unsafeInsertAt3, unsafeUpdateAt3, unsafeDeleteAt, every2, some2, exists2, intercalate4, Do5, bindTo6, let_6, bind6, apS6, range3, empty3, cons3, snoc3, prependToAll2, array2;
var init_Array = __esm({
  "node_modules/fp-ts/es6/Array.js"() {
    init_shim();
    init_Apply();
    init_Chain();
    init_FromEither();
    init_function();
    init_Functor();
    init_internal();
    init_NonEmptyArray();
    init_ReadonlyArray();
    init_Separated();
    init_Witherable();
    init_Zero();
    isEmpty2 = function(as) {
      return as.length === 0;
    };
    isNonEmpty6 = isNonEmpty4;
    prepend3 = prepend2;
    prependW3 = prependW2;
    append4 = append2;
    appendW3 = appendW2;
    makeBy3 = function(n, f) {
      return n <= 0 ? [] : makeBy(f)(n);
    };
    replicate2 = function(n, a) {
      return makeBy3(n, function() {
        return a;
      });
    };
    fromOption3 = function(ma) {
      return isNone(ma) ? [] : [ma.value];
    };
    fromEither2 = function(e) {
      return isLeft(e) ? [] : [e.right];
    };
    matchW3 = function(onEmpty, onNonEmpty) {
      return function(as) {
        return isNonEmpty6(as) ? onNonEmpty(as) : onEmpty();
      };
    };
    match3 = matchW3;
    matchLeftW = function(onEmpty, onNonEmpty) {
      return function(as) {
        return isNonEmpty6(as) ? onNonEmpty(head3(as), tail3(as)) : onEmpty();
      };
    };
    matchLeft2 = matchLeftW;
    foldLeft = matchLeft2;
    matchRightW = function(onEmpty, onNonEmpty) {
      return function(as) {
        return isNonEmpty6(as) ? onNonEmpty(init(as), last3(as)) : onEmpty();
      };
    };
    matchRight2 = matchRightW;
    foldRight = matchRight2;
    chainWithIndex4 = function(f) {
      return function(as) {
        var out = [];
        for (var i = 0; i < as.length; i++) {
          out.push.apply(out, f(i, as[i]));
        }
        return out;
      };
    };
    scanLeft = function(b, f) {
      return function(as) {
        var len = as.length;
        var out = new Array(len + 1);
        out[0] = b;
        for (var i = 0; i < len; i++) {
          out[i + 1] = f(out[i], as[i]);
        }
        return out;
      };
    };
    scanRight = function(b, f) {
      return function(as) {
        var len = as.length;
        var out = new Array(len + 1);
        out[len] = b;
        for (var i = len - 1; i >= 0; i--) {
          out[i] = f(as[i], out[i + 1]);
        }
        return out;
      };
    };
    size = function(as) {
      return as.length;
    };
    isOutOfBound4 = isOutOfBound2;
    lookup2 = lookup;
    head5 = head4;
    last5 = last4;
    tail4 = function(as) {
      return isNonEmpty6(as) ? some(tail3(as)) : none;
    };
    init3 = function(as) {
      return isNonEmpty6(as) ? some(init(as)) : none;
    };
    takeLeft = function(n) {
      return function(as) {
        return isOutOfBound4(n, as) ? copy2(as) : as.slice(0, n);
      };
    };
    takeRight = function(n) {
      return function(as) {
        return isOutOfBound4(n, as) ? copy2(as) : n === 0 ? [] : as.slice(-n);
      };
    };
    spanLeftIndex = function(as, predicate) {
      var l = as.length;
      var i = 0;
      for (; i < l; i++) {
        if (!predicate(as[i])) {
          break;
        }
      }
      return i;
    };
    dropLeft = function(n) {
      return function(as) {
        return n <= 0 || isEmpty2(as) ? copy2(as) : n >= as.length ? [] : as.slice(n, as.length);
      };
    };
    dropRight = function(n) {
      return function(as) {
        return n <= 0 || isEmpty2(as) ? copy2(as) : n >= as.length ? [] : as.slice(0, as.length - n);
      };
    };
    findIndex2 = findIndex;
    findFirstMap2 = findFirstMap;
    findLastMap2 = findLastMap;
    findLastIndex2 = findLastIndex;
    copy2 = function(as) {
      return as.slice();
    };
    insertAt2 = function(i, a) {
      return function(as) {
        return i < 0 || i > as.length ? none : some(unsafeInsertAt3(i, a, as));
      };
    };
    updateAt2 = function(i, a) {
      return modifyAt2(i, function() {
        return a;
      });
    };
    deleteAt = function(i) {
      return function(as) {
        return isOutOfBound4(i, as) ? none : some(unsafeDeleteAt(i, as));
      };
    };
    modifyAt2 = function(i, f) {
      return function(as) {
        return isOutOfBound4(i, as) ? none : some(unsafeUpdateAt3(i, f(as[i]), as));
      };
    };
    reverse3 = function(as) {
      return isEmpty2(as) ? [] : as.slice().reverse();
    };
    rights = function(as) {
      var r = [];
      for (var i = 0; i < as.length; i++) {
        var a = as[i];
        if (a._tag === "Right") {
          r.push(a.right);
        }
      }
      return r;
    };
    lefts = function(as) {
      var r = [];
      for (var i = 0; i < as.length; i++) {
        var a = as[i];
        if (a._tag === "Left") {
          r.push(a.left);
        }
      }
      return r;
    };
    sort2 = function(O) {
      return function(as) {
        return as.length <= 1 ? copy2(as) : as.slice().sort(O.compare);
      };
    };
    zipWith2 = function(fa, fb, f) {
      var fc = [];
      var len = Math.min(fa.length, fb.length);
      for (var i = 0; i < len; i++) {
        fc[i] = f(fa[i], fb[i]);
      }
      return fc;
    };
    unzip2 = function(as) {
      var fa = [];
      var fb = [];
      for (var i = 0; i < as.length; i++) {
        fa[i] = as[i][0];
        fb[i] = as[i][1];
      }
      return [fa, fb];
    };
    prependAll3 = function(middle) {
      var f = prependAll2(middle);
      return function(as) {
        return isNonEmpty6(as) ? f(as) : [];
      };
    };
    intersperse3 = function(middle) {
      var f = intersperse2(middle);
      return function(as) {
        return isNonEmpty6(as) ? f(as) : copy2(as);
      };
    };
    rotate3 = function(n) {
      var f = rotate(n);
      return function(as) {
        return isNonEmpty6(as) ? f(as) : copy2(as);
      };
    };
    elem3 = elem2;
    uniq3 = function(E) {
      var f = uniq(E);
      return function(as) {
        return isNonEmpty6(as) ? f(as) : copy2(as);
      };
    };
    sortBy3 = function(ords) {
      var f = sortBy(ords);
      return function(as) {
        return isNonEmpty6(as) ? f(as) : copy2(as);
      };
    };
    chop3 = function(f) {
      var g = chop(f);
      return function(as) {
        return isNonEmpty6(as) ? g(as) : [];
      };
    };
    splitAt3 = function(n) {
      return function(as) {
        return n >= 1 && isNonEmpty6(as) ? splitAt(n)(as) : isEmpty2(as) ? [copy2(as), []] : [[], copy2(as)];
      };
    };
    chunksOf3 = function(n) {
      var f = chunksOf(n);
      return function(as) {
        return isNonEmpty6(as) ? f(as) : [];
      };
    };
    fromOptionK3 = function(f) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return fromOption3(f.apply(void 0, a));
      };
    };
    concatW2 = function(second) {
      return function(first2) {
        return isEmpty2(first2) ? copy2(second) : isEmpty2(second) ? copy2(first2) : first2.concat(second);
      };
    };
    concat2 = concatW2;
    _map6 = function(fa, f) {
      return pipe(fa, map6(f));
    };
    _mapWithIndex2 = function(fa, f) {
      return pipe(fa, mapWithIndex3(f));
    };
    _ap5 = function(fab, fa) {
      return pipe(fab, ap6(fa));
    };
    _chain5 = function(ma, f) {
      return pipe(ma, chain5(f));
    };
    _filter2 = function(fa, predicate) {
      return pipe(fa, filter3(predicate));
    };
    _filterMap2 = function(fa, f) {
      return pipe(fa, filterMap2(f));
    };
    _partition2 = function(fa, predicate) {
      return pipe(fa, partition2(predicate));
    };
    _partitionMap2 = function(fa, f) {
      return pipe(fa, partitionMap2(f));
    };
    _partitionWithIndex = function(fa, predicateWithIndex) {
      return pipe(fa, partitionWithIndex2(predicateWithIndex));
    };
    _partitionMapWithIndex = function(fa, f) {
      return pipe(fa, partitionMapWithIndex2(f));
    };
    _alt3 = function(fa, that) {
      return pipe(fa, alt3(that));
    };
    _reduce4 = function(fa, b, f) {
      return pipe(fa, reduce5(b, f));
    };
    _foldMap4 = function(M) {
      var foldMapM = foldMap5(M);
      return function(fa, f) {
        return pipe(fa, foldMapM(f));
      };
    };
    _reduceRight4 = function(fa, b, f) {
      return pipe(fa, reduceRight5(b, f));
    };
    _reduceWithIndex2 = function(fa, b, f) {
      return pipe(fa, reduceWithIndex4(b, f));
    };
    _foldMapWithIndex2 = function(M) {
      var foldMapWithIndexM = foldMapWithIndex4(M);
      return function(fa, f) {
        return pipe(fa, foldMapWithIndexM(f));
      };
    };
    _reduceRightWithIndex2 = function(fa, b, f) {
      return pipe(fa, reduceRightWithIndex4(b, f));
    };
    _filterMapWithIndex = function(fa, f) {
      return pipe(fa, filterMapWithIndex2(f));
    };
    _filterWithIndex = function(fa, predicateWithIndex) {
      return pipe(fa, filterWithIndex2(predicateWithIndex));
    };
    _extend3 = function(fa, f) {
      return pipe(fa, extend5(f));
    };
    _traverse4 = function(F) {
      var traverseF = traverse4(F);
      return function(ta, f) {
        return pipe(ta, traverseF(f));
      };
    };
    _traverseWithIndex2 = function(F) {
      var traverseWithIndexF = traverseWithIndex3(F);
      return function(ta, f) {
        return pipe(ta, traverseWithIndexF(f));
      };
    };
    _chainRecDepthFirst2 = _chainRecDepthFirst;
    _chainRecBreadthFirst2 = _chainRecBreadthFirst;
    of5 = of3;
    zero2 = function() {
      return [];
    };
    map6 = function(f) {
      return function(fa) {
        return fa.map(function(a) {
          return f(a);
        });
      };
    };
    ap6 = function(fa) {
      return chain5(function(f) {
        return pipe(fa, map6(f));
      });
    };
    chain5 = function(f) {
      return function(ma) {
        return pipe(ma, chainWithIndex4(function(_, a) {
          return f(a);
        }));
      };
    };
    flatten5 = chain5(identity);
    mapWithIndex3 = function(f) {
      return function(fa) {
        return fa.map(function(a, i) {
          return f(i, a);
        });
      };
    };
    filterMapWithIndex2 = function(f) {
      return function(fa) {
        var out = [];
        for (var i = 0; i < fa.length; i++) {
          var optionB = f(i, fa[i]);
          if (isSome(optionB)) {
            out.push(optionB.value);
          }
        }
        return out;
      };
    };
    filterMap2 = function(f) {
      return filterMapWithIndex2(function(_, a) {
        return f(a);
      });
    };
    compact2 = filterMap2(identity);
    separate2 = function(fa) {
      var left4 = [];
      var right4 = [];
      for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {
        var e = fa_1[_i];
        if (e._tag === "Left") {
          left4.push(e.left);
        } else {
          right4.push(e.right);
        }
      }
      return separated(left4, right4);
    };
    filter3 = function(predicate) {
      return function(as) {
        return as.filter(predicate);
      };
    };
    partition2 = function(predicate) {
      return partitionWithIndex2(function(_, a) {
        return predicate(a);
      });
    };
    partitionWithIndex2 = function(predicateWithIndex) {
      return function(as) {
        var left4 = [];
        var right4 = [];
        for (var i = 0; i < as.length; i++) {
          var b = as[i];
          if (predicateWithIndex(i, b)) {
            right4.push(b);
          } else {
            left4.push(b);
          }
        }
        return separated(left4, right4);
      };
    };
    partitionMap2 = function(f) {
      return partitionMapWithIndex2(function(_, a) {
        return f(a);
      });
    };
    partitionMapWithIndex2 = function(f) {
      return function(fa) {
        var left4 = [];
        var right4 = [];
        for (var i = 0; i < fa.length; i++) {
          var e = f(i, fa[i]);
          if (e._tag === "Left") {
            left4.push(e.left);
          } else {
            right4.push(e.right);
          }
        }
        return separated(left4, right4);
      };
    };
    altW3 = function(that) {
      return function(fa) {
        return fa.concat(that());
      };
    };
    alt3 = altW3;
    filterWithIndex2 = function(predicateWithIndex) {
      return function(as) {
        return as.filter(function(b, i) {
          return predicateWithIndex(i, b);
        });
      };
    };
    extend5 = function(f) {
      return function(wa) {
        return wa.map(function(_, i) {
          return f(wa.slice(i));
        });
      };
    };
    duplicate5 = extend5(identity);
    foldMap5 = foldMap4;
    foldMapWithIndex4 = foldMapWithIndex3;
    reduce5 = reduce4;
    reduceWithIndex4 = reduceWithIndex3;
    reduceRight5 = reduceRight4;
    reduceRightWithIndex4 = reduceRightWithIndex3;
    traverse4 = function(F) {
      var traverseWithIndexF = traverseWithIndex3(F);
      return function(f) {
        return traverseWithIndexF(function(_, a) {
          return f(a);
        });
      };
    };
    sequence4 = function(F) {
      return function(ta) {
        return _reduce4(ta, F.of(zero2()), function(fas, fa) {
          return F.ap(F.map(fas, function(as) {
            return function(a) {
              return pipe(as, append4(a));
            };
          }), fa);
        });
      };
    };
    traverseWithIndex3 = function(F) {
      return function(f) {
        return reduceWithIndex4(F.of(zero2()), function(i, fbs, a) {
          return F.ap(F.map(fbs, function(bs) {
            return function(b) {
              return pipe(bs, append4(b));
            };
          }), f(i, a));
        });
      };
    };
    wither = function(F) {
      var _witherF = _wither2(F);
      return function(f) {
        return function(fa) {
          return _witherF(fa, f);
        };
      };
    };
    wilt = function(F) {
      var _wiltF = _wilt2(F);
      return function(f) {
        return function(fa) {
          return _wiltF(fa, f);
        };
      };
    };
    unfold = function(b, f) {
      var out = [];
      var bb = b;
      while (true) {
        var mt = f(bb);
        if (isSome(mt)) {
          var _a = mt.value, a = _a[0], b_1 = _a[1];
          out.push(a);
          bb = b_1;
        } else {
          break;
        }
      }
      return out;
    };
    URI6 = "Array";
    getShow5 = getShow4;
    getSemigroup5 = function() {
      return {
        concat: function(first2, second) {
          return first2.concat(second);
        }
      };
    };
    getMonoid2 = function() {
      return {
        concat: getSemigroup5().concat,
        empty: []
      };
    };
    getEq5 = getEq4;
    getOrd2 = getOrd;
    getUnionSemigroup2 = function(E) {
      var unionE = union4(E);
      return {
        concat: function(first2, second) {
          return unionE(second)(first2);
        }
      };
    };
    getUnionMonoid = function(E) {
      return {
        concat: getUnionSemigroup2(E).concat,
        empty: []
      };
    };
    getIntersectionSemigroup = function(E) {
      var intersectionE = intersection2(E);
      return {
        concat: function(first2, second) {
          return intersectionE(second)(first2);
        }
      };
    };
    getDifferenceMagma = function(E) {
      var differenceE = difference(E);
      return {
        concat: function(first2, second) {
          return differenceE(second)(first2);
        }
      };
    };
    Functor6 = {
      URI: URI6,
      map: _map6
    };
    flap7 = flap(Functor6);
    Pointed4 = {
      URI: URI6,
      of: of5
    };
    FunctorWithIndex2 = {
      URI: URI6,
      map: _map6,
      mapWithIndex: _mapWithIndex2
    };
    Apply5 = {
      URI: URI6,
      map: _map6,
      ap: _ap5
    };
    apFirst6 = apFirst(Apply5);
    apSecond6 = apSecond(Apply5);
    Applicative3 = {
      URI: URI6,
      map: _map6,
      ap: _ap5,
      of: of5
    };
    Chain5 = {
      URI: URI6,
      map: _map6,
      ap: _ap5,
      chain: _chain5
    };
    chainFirst6 = chainFirst(Chain5);
    Monad3 = {
      URI: URI6,
      map: _map6,
      ap: _ap5,
      of: of5,
      chain: _chain5
    };
    Unfoldable = {
      URI: URI6,
      unfold
    };
    Alt3 = {
      URI: URI6,
      map: _map6,
      alt: _alt3
    };
    Zero2 = {
      URI: URI6,
      zero: zero2
    };
    guard3 = guard(Zero2, Pointed4);
    Alternative = {
      URI: URI6,
      map: _map6,
      ap: _ap5,
      of: of5,
      alt: _alt3,
      zero: zero2
    };
    Extend2 = {
      URI: URI6,
      map: _map6,
      extend: _extend3
    };
    Compactable2 = {
      URI: URI6,
      compact: compact2,
      separate: separate2
    };
    Filterable = {
      URI: URI6,
      map: _map6,
      compact: compact2,
      separate: separate2,
      filter: _filter2,
      filterMap: _filterMap2,
      partition: _partition2,
      partitionMap: _partitionMap2
    };
    FilterableWithIndex = {
      URI: URI6,
      map: _map6,
      mapWithIndex: _mapWithIndex2,
      compact: compact2,
      separate: separate2,
      filter: _filter2,
      filterMap: _filterMap2,
      partition: _partition2,
      partitionMap: _partitionMap2,
      partitionMapWithIndex: _partitionMapWithIndex,
      partitionWithIndex: _partitionWithIndex,
      filterMapWithIndex: _filterMapWithIndex,
      filterWithIndex: _filterWithIndex
    };
    Foldable3 = {
      URI: URI6,
      reduce: _reduce4,
      foldMap: _foldMap4,
      reduceRight: _reduceRight4
    };
    FoldableWithIndex2 = {
      URI: URI6,
      reduce: _reduce4,
      foldMap: _foldMap4,
      reduceRight: _reduceRight4,
      reduceWithIndex: _reduceWithIndex2,
      foldMapWithIndex: _foldMapWithIndex2,
      reduceRightWithIndex: _reduceRightWithIndex2
    };
    Traversable4 = {
      URI: URI6,
      map: _map6,
      reduce: _reduce4,
      foldMap: _foldMap4,
      reduceRight: _reduceRight4,
      traverse: _traverse4,
      sequence: sequence4
    };
    TraversableWithIndex2 = {
      URI: URI6,
      map: _map6,
      mapWithIndex: _mapWithIndex2,
      reduce: _reduce4,
      foldMap: _foldMap4,
      reduceRight: _reduceRight4,
      reduceWithIndex: _reduceWithIndex2,
      foldMapWithIndex: _foldMapWithIndex2,
      reduceRightWithIndex: _reduceRightWithIndex2,
      traverse: _traverse4,
      sequence: sequence4,
      traverseWithIndex: _traverseWithIndex2
    };
    _wither2 = witherDefault(Traversable4, Compactable2);
    _wilt2 = wiltDefault(Traversable4, Compactable2);
    Witherable2 = {
      URI: URI6,
      map: _map6,
      compact: compact2,
      separate: separate2,
      filter: _filter2,
      filterMap: _filterMap2,
      partition: _partition2,
      partitionMap: _partitionMap2,
      reduce: _reduce4,
      foldMap: _foldMap4,
      reduceRight: _reduceRight4,
      traverse: _traverse4,
      sequence: sequence4,
      wither: _wither2,
      wilt: _wilt2
    };
    chainRecDepthFirst2 = chainRecDepthFirst;
    ChainRecDepthFirst = {
      URI: URI6,
      map: _map6,
      ap: _ap5,
      chain: _chain5,
      chainRec: _chainRecDepthFirst2
    };
    chainRecBreadthFirst2 = chainRecBreadthFirst;
    ChainRecBreadthFirst = {
      URI: URI6,
      map: _map6,
      ap: _ap5,
      chain: _chain5,
      chainRec: _chainRecBreadthFirst2
    };
    filterE3 = filterE(Witherable2);
    FromEither3 = {
      URI: URI6,
      fromEither: fromEither2
    };
    fromEitherK3 = fromEitherK(FromEither3);
    unsafeInsertAt3 = unsafeInsertAt;
    unsafeUpdateAt3 = function(i, a, as) {
      return isNonEmpty6(as) ? unsafeUpdateAt(i, a, as) : [];
    };
    unsafeDeleteAt = function(i, as) {
      var xs = as.slice();
      xs.splice(i, 1);
      return xs;
    };
    every2 = every;
    some2 = function(predicate) {
      return function(as) {
        return as.some(predicate);
      };
    };
    exists2 = some2;
    intercalate4 = intercalate3;
    Do5 = of5(emptyRecord);
    bindTo6 = bindTo(Functor6);
    let_6 = let_(Functor6);
    bind6 = bind(Chain5);
    apS6 = apS(Apply5);
    range3 = range;
    empty3 = [];
    cons3 = cons;
    snoc3 = snoc;
    prependToAll2 = prependAll3;
    array2 = {
      URI: URI6,
      compact: compact2,
      separate: separate2,
      map: _map6,
      ap: _ap5,
      of: of5,
      chain: _chain5,
      filter: _filter2,
      filterMap: _filterMap2,
      partition: _partition2,
      partitionMap: _partitionMap2,
      mapWithIndex: _mapWithIndex2,
      partitionMapWithIndex: _partitionMapWithIndex,
      partitionWithIndex: _partitionWithIndex,
      filterMapWithIndex: _filterMapWithIndex,
      filterWithIndex: _filterWithIndex,
      alt: _alt3,
      zero: zero2,
      unfold,
      reduce: _reduce4,
      foldMap: _foldMap4,
      reduceRight: _reduceRight4,
      traverse: _traverse4,
      sequence: sequence4,
      reduceWithIndex: _reduceWithIndex2,
      foldMapWithIndex: _foldMapWithIndex2,
      reduceRightWithIndex: _reduceRightWithIndex2,
      traverseWithIndex: _traverseWithIndex2,
      extend: _extend3,
      wither: _wither2,
      wilt: _wilt2
    };
  }
});

// node_modules/fp-ts/es6/Predicate.js
var not;
var init_Predicate = __esm({
  "node_modules/fp-ts/es6/Predicate.js"() {
    init_shim();
    init_function();
    not = function(predicate) {
      return function(a) {
        return !predicate(a);
      };
    };
  }
});

// node_modules/fp-ts/es6/Option.js
var Option_exports = {};
__export(Option_exports, {
  Alt: () => Alt4,
  Alternative: () => Alternative2,
  ApT: () => ApT2,
  Applicative: () => Applicative4,
  Apply: () => Apply6,
  Chain: () => Chain6,
  Compactable: () => Compactable3,
  Do: () => Do6,
  Extend: () => Extend3,
  Filterable: () => Filterable2,
  Foldable: () => Foldable4,
  FromEither: () => FromEither4,
  Functor: () => Functor7,
  Monad: () => Monad4,
  MonadThrow: () => MonadThrow2,
  Pointed: () => Pointed5,
  Traversable: () => Traversable5,
  URI: () => URI7,
  Witherable: () => Witherable3,
  Zero: () => Zero3,
  alt: () => alt4,
  altW: () => altW4,
  ap: () => ap7,
  apFirst: () => apFirst7,
  apS: () => apS7,
  apSecond: () => apSecond7,
  bind: () => bind7,
  bindTo: () => bindTo7,
  chain: () => chain6,
  chainEitherK: () => chainEitherK2,
  chainFirst: () => chainFirst7,
  chainFirstEitherK: () => chainFirstEitherK2,
  chainNullableK: () => chainNullableK2,
  compact: () => compact3,
  duplicate: () => duplicate6,
  elem: () => elem4,
  exists: () => exists3,
  extend: () => extend6,
  filter: () => filter4,
  filterMap: () => filterMap3,
  flap: () => flap8,
  flatten: () => flatten6,
  fold: () => fold3,
  foldMap: () => foldMap6,
  foldW: () => foldW2,
  fromEither: () => fromEither3,
  fromEitherK: () => fromEitherK4,
  fromNullable: () => fromNullable2,
  fromNullableK: () => fromNullableK2,
  fromPredicate: () => fromPredicate4,
  getApplyMonoid: () => getApplyMonoid2,
  getApplySemigroup: () => getApplySemigroup3,
  getEq: () => getEq6,
  getFirstMonoid: () => getFirstMonoid,
  getLastMonoid: () => getLastMonoid,
  getLeft: () => getLeft,
  getMonoid: () => getMonoid3,
  getOrElse: () => getOrElse2,
  getOrElseW: () => getOrElseW2,
  getOrd: () => getOrd3,
  getRefinement: () => getRefinement,
  getRight: () => getRight,
  getShow: () => getShow6,
  guard: () => guard4,
  isNone: () => isNone2,
  isSome: () => isSome2,
  let: () => let_7,
  map: () => map7,
  mapNullable: () => mapNullable,
  match: () => match4,
  matchW: () => matchW4,
  none: () => none2,
  of: () => of6,
  option: () => option,
  partition: () => partition3,
  partitionMap: () => partitionMap3,
  reduce: () => reduce6,
  reduceRight: () => reduceRight6,
  separate: () => separate3,
  sequence: () => sequence5,
  sequenceArray: () => sequenceArray2,
  some: () => some3,
  throwError: () => throwError2,
  toNullable: () => toNullable,
  toUndefined: () => toUndefined,
  traverse: () => traverse5,
  traverseArray: () => traverseArray2,
  traverseArrayWithIndex: () => traverseArrayWithIndex2,
  traverseReadonlyArrayWithIndex: () => traverseReadonlyArrayWithIndex2,
  traverseReadonlyNonEmptyArrayWithIndex: () => traverseReadonlyNonEmptyArrayWithIndex2,
  tryCatch: () => tryCatch2,
  tryCatchK: () => tryCatchK2,
  wilt: () => wilt2,
  wither: () => wither2,
  zero: () => zero3
});
function fromPredicate4(predicate) {
  return function(a) {
    return predicate(a) ? some3(a) : none2;
  };
}
function elem4(E) {
  return function(a, ma) {
    if (ma === void 0) {
      var elemE_1 = elem4(E);
      return function(ma2) {
        return elemE_1(a, ma2);
      };
    }
    return isNone2(ma) ? false : E.equals(a, ma.value);
  };
}
function getRefinement(getOption) {
  return function(a) {
    return isSome2(getOption(a));
  };
}
var none2, some3, getLeft, getRight, _map7, _ap6, _chain6, _reduce5, _foldMap5, _reduceRight5, _traverse5, _alt4, _filter3, _filterMap3, _extend4, _partition3, _partitionMap3, URI7, getShow6, getEq6, getOrd3, getMonoid3, map7, Functor7, of6, Pointed5, ap7, Apply6, Applicative4, chain6, Chain6, Monad4, reduce6, foldMap6, reduceRight6, Foldable4, altW4, alt4, Alt4, zero3, Zero3, guard4, Alternative2, extend6, Extend3, compact3, defaultSeparated, separate3, Compactable3, filter4, filterMap3, partition3, partitionMap3, Filterable2, traverse5, sequence5, Traversable5, _wither3, _wilt3, wither2, wilt2, Witherable3, throwError2, MonadThrow2, fromEither3, FromEither4, isSome2, isNone2, matchW4, foldW2, match4, fold3, getOrElseW2, getOrElse2, flap8, apFirst7, apSecond7, flatten6, chainFirst7, duplicate6, fromEitherK4, chainEitherK2, chainFirstEitherK2, fromNullable2, tryCatch2, tryCatchK2, fromNullableK2, chainNullableK2, toNullable, toUndefined, exists3, Do6, bindTo7, let_7, bind7, apS7, ApT2, traverseReadonlyNonEmptyArrayWithIndex2, traverseReadonlyArrayWithIndex2, traverseArrayWithIndex2, traverseArray2, sequenceArray2, mapNullable, option, getApplySemigroup3, getApplyMonoid2, getFirstMonoid, getLastMonoid;
var init_Option = __esm({
  "node_modules/fp-ts/es6/Option.js"() {
    init_shim();
    init_Applicative();
    init_Apply();
    init_Chain();
    init_FromEither();
    init_function();
    init_Functor();
    init_internal();
    init_Predicate();
    init_Semigroup();
    init_Separated();
    init_Witherable();
    init_Zero();
    none2 = none;
    some3 = some;
    getLeft = function(ma) {
      return ma._tag === "Right" ? none2 : some3(ma.left);
    };
    getRight = function(ma) {
      return ma._tag === "Left" ? none2 : some3(ma.right);
    };
    _map7 = function(fa, f) {
      return pipe(fa, map7(f));
    };
    _ap6 = function(fab, fa) {
      return pipe(fab, ap7(fa));
    };
    _chain6 = function(ma, f) {
      return pipe(ma, chain6(f));
    };
    _reduce5 = function(fa, b, f) {
      return pipe(fa, reduce6(b, f));
    };
    _foldMap5 = function(M) {
      var foldMapM = foldMap6(M);
      return function(fa, f) {
        return pipe(fa, foldMapM(f));
      };
    };
    _reduceRight5 = function(fa, b, f) {
      return pipe(fa, reduceRight6(b, f));
    };
    _traverse5 = function(F) {
      var traverseF = traverse5(F);
      return function(ta, f) {
        return pipe(ta, traverseF(f));
      };
    };
    _alt4 = function(fa, that) {
      return pipe(fa, alt4(that));
    };
    _filter3 = function(fa, predicate) {
      return pipe(fa, filter4(predicate));
    };
    _filterMap3 = function(fa, f) {
      return pipe(fa, filterMap3(f));
    };
    _extend4 = function(wa, f) {
      return pipe(wa, extend6(f));
    };
    _partition3 = function(fa, predicate) {
      return pipe(fa, partition3(predicate));
    };
    _partitionMap3 = function(fa, f) {
      return pipe(fa, partitionMap3(f));
    };
    URI7 = "Option";
    getShow6 = function(S) {
      return {
        show: function(ma) {
          return isNone2(ma) ? "none" : "some(".concat(S.show(ma.value), ")");
        }
      };
    };
    getEq6 = function(E) {
      return {
        equals: function(x, y) {
          return x === y || (isNone2(x) ? isNone2(y) : isNone2(y) ? false : E.equals(x.value, y.value));
        }
      };
    };
    getOrd3 = function(O) {
      return {
        equals: getEq6(O).equals,
        compare: function(x, y) {
          return x === y ? 0 : isSome2(x) ? isSome2(y) ? O.compare(x.value, y.value) : 1 : -1;
        }
      };
    };
    getMonoid3 = function(S) {
      return {
        concat: function(x, y) {
          return isNone2(x) ? y : isNone2(y) ? x : some3(S.concat(x.value, y.value));
        },
        empty: none2
      };
    };
    map7 = function(f) {
      return function(fa) {
        return isNone2(fa) ? none2 : some3(f(fa.value));
      };
    };
    Functor7 = {
      URI: URI7,
      map: _map7
    };
    of6 = some3;
    Pointed5 = {
      URI: URI7,
      of: of6
    };
    ap7 = function(fa) {
      return function(fab) {
        return isNone2(fab) ? none2 : isNone2(fa) ? none2 : some3(fab.value(fa.value));
      };
    };
    Apply6 = {
      URI: URI7,
      map: _map7,
      ap: _ap6
    };
    Applicative4 = {
      URI: URI7,
      map: _map7,
      ap: _ap6,
      of: of6
    };
    chain6 = function(f) {
      return function(ma) {
        return isNone2(ma) ? none2 : f(ma.value);
      };
    };
    Chain6 = {
      URI: URI7,
      map: _map7,
      ap: _ap6,
      chain: _chain6
    };
    Monad4 = {
      URI: URI7,
      map: _map7,
      ap: _ap6,
      of: of6,
      chain: _chain6
    };
    reduce6 = function(b, f) {
      return function(fa) {
        return isNone2(fa) ? b : f(b, fa.value);
      };
    };
    foldMap6 = function(M) {
      return function(f) {
        return function(fa) {
          return isNone2(fa) ? M.empty : f(fa.value);
        };
      };
    };
    reduceRight6 = function(b, f) {
      return function(fa) {
        return isNone2(fa) ? b : f(fa.value, b);
      };
    };
    Foldable4 = {
      URI: URI7,
      reduce: _reduce5,
      foldMap: _foldMap5,
      reduceRight: _reduceRight5
    };
    altW4 = function(that) {
      return function(fa) {
        return isNone2(fa) ? that() : fa;
      };
    };
    alt4 = altW4;
    Alt4 = {
      URI: URI7,
      map: _map7,
      alt: _alt4
    };
    zero3 = function() {
      return none2;
    };
    Zero3 = {
      URI: URI7,
      zero: zero3
    };
    guard4 = guard(Zero3, Pointed5);
    Alternative2 = {
      URI: URI7,
      map: _map7,
      ap: _ap6,
      of: of6,
      alt: _alt4,
      zero: zero3
    };
    extend6 = function(f) {
      return function(wa) {
        return isNone2(wa) ? none2 : some3(f(wa));
      };
    };
    Extend3 = {
      URI: URI7,
      map: _map7,
      extend: _extend4
    };
    compact3 = chain6(identity);
    defaultSeparated = separated(none2, none2);
    separate3 = function(ma) {
      return isNone2(ma) ? defaultSeparated : separated(getLeft(ma.value), getRight(ma.value));
    };
    Compactable3 = {
      URI: URI7,
      compact: compact3,
      separate: separate3
    };
    filter4 = function(predicate) {
      return function(fa) {
        return isNone2(fa) ? none2 : predicate(fa.value) ? fa : none2;
      };
    };
    filterMap3 = function(f) {
      return function(fa) {
        return isNone2(fa) ? none2 : f(fa.value);
      };
    };
    partition3 = function(predicate) {
      return function(fa) {
        return separated(_filter3(fa, not(predicate)), _filter3(fa, predicate));
      };
    };
    partitionMap3 = function(f) {
      return flow(map7(f), separate3);
    };
    Filterable2 = {
      URI: URI7,
      map: _map7,
      compact: compact3,
      separate: separate3,
      filter: _filter3,
      filterMap: _filterMap3,
      partition: _partition3,
      partitionMap: _partitionMap3
    };
    traverse5 = function(F) {
      return function(f) {
        return function(ta) {
          return isNone2(ta) ? F.of(none2) : F.map(f(ta.value), some3);
        };
      };
    };
    sequence5 = function(F) {
      return function(ta) {
        return isNone2(ta) ? F.of(none2) : F.map(ta.value, some3);
      };
    };
    Traversable5 = {
      URI: URI7,
      map: _map7,
      reduce: _reduce5,
      foldMap: _foldMap5,
      reduceRight: _reduceRight5,
      traverse: _traverse5,
      sequence: sequence5
    };
    _wither3 = witherDefault(Traversable5, Compactable3);
    _wilt3 = wiltDefault(Traversable5, Compactable3);
    wither2 = function(F) {
      var _witherF = _wither3(F);
      return function(f) {
        return function(fa) {
          return _witherF(fa, f);
        };
      };
    };
    wilt2 = function(F) {
      var _wiltF = _wilt3(F);
      return function(f) {
        return function(fa) {
          return _wiltF(fa, f);
        };
      };
    };
    Witherable3 = {
      URI: URI7,
      map: _map7,
      reduce: _reduce5,
      foldMap: _foldMap5,
      reduceRight: _reduceRight5,
      traverse: _traverse5,
      sequence: sequence5,
      compact: compact3,
      separate: separate3,
      filter: _filter3,
      filterMap: _filterMap3,
      partition: _partition3,
      partitionMap: _partitionMap3,
      wither: _wither3,
      wilt: _wilt3
    };
    throwError2 = function() {
      return none2;
    };
    MonadThrow2 = {
      URI: URI7,
      map: _map7,
      ap: _ap6,
      of: of6,
      chain: _chain6,
      throwError: throwError2
    };
    fromEither3 = getRight;
    FromEither4 = {
      URI: URI7,
      fromEither: fromEither3
    };
    isSome2 = isSome;
    isNone2 = function(fa) {
      return fa._tag === "None";
    };
    matchW4 = function(onNone, onSome) {
      return function(ma) {
        return isNone2(ma) ? onNone() : onSome(ma.value);
      };
    };
    foldW2 = matchW4;
    match4 = matchW4;
    fold3 = match4;
    getOrElseW2 = function(onNone) {
      return function(ma) {
        return isNone2(ma) ? onNone() : ma.value;
      };
    };
    getOrElse2 = getOrElseW2;
    flap8 = flap(Functor7);
    apFirst7 = apFirst(Apply6);
    apSecond7 = apSecond(Apply6);
    flatten6 = compact3;
    chainFirst7 = chainFirst(Chain6);
    duplicate6 = extend6(identity);
    fromEitherK4 = fromEitherK(FromEither4);
    chainEitherK2 = chainEitherK(FromEither4, Chain6);
    chainFirstEitherK2 = chainFirstEitherK(FromEither4, Chain6);
    fromNullable2 = function(a) {
      return a == null ? none2 : some3(a);
    };
    tryCatch2 = function(f) {
      try {
        return some3(f());
      } catch (e) {
        return none2;
      }
    };
    tryCatchK2 = function(f) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return tryCatch2(function() {
          return f.apply(void 0, a);
        });
      };
    };
    fromNullableK2 = function(f) {
      return flow(f, fromNullable2);
    };
    chainNullableK2 = function(f) {
      return function(ma) {
        return isNone2(ma) ? none2 : fromNullable2(f(ma.value));
      };
    };
    toNullable = match4(constNull, identity);
    toUndefined = match4(constUndefined, identity);
    exists3 = function(predicate) {
      return function(ma) {
        return isNone2(ma) ? false : predicate(ma.value);
      };
    };
    Do6 = of6(emptyRecord);
    bindTo7 = bindTo(Functor7);
    let_7 = let_(Functor7);
    bind7 = bind(Chain6);
    apS7 = apS(Apply6);
    ApT2 = of6(emptyReadonlyArray);
    traverseReadonlyNonEmptyArrayWithIndex2 = function(f) {
      return function(as) {
        var o = f(0, head(as));
        if (isNone2(o)) {
          return none2;
        }
        var out = [o.value];
        for (var i = 1; i < as.length; i++) {
          var o_1 = f(i, as[i]);
          if (isNone2(o_1)) {
            return none2;
          }
          out.push(o_1.value);
        }
        return some3(out);
      };
    };
    traverseReadonlyArrayWithIndex2 = function(f) {
      var g = traverseReadonlyNonEmptyArrayWithIndex2(f);
      return function(as) {
        return isNonEmpty(as) ? g(as) : ApT2;
      };
    };
    traverseArrayWithIndex2 = traverseReadonlyArrayWithIndex2;
    traverseArray2 = function(f) {
      return traverseReadonlyArrayWithIndex2(function(_, a) {
        return f(a);
      });
    };
    sequenceArray2 = traverseArray2(identity);
    mapNullable = chainNullableK2;
    option = {
      URI: URI7,
      map: _map7,
      of: of6,
      ap: _ap6,
      chain: _chain6,
      reduce: _reduce5,
      foldMap: _foldMap5,
      reduceRight: _reduceRight5,
      traverse: _traverse5,
      sequence: sequence5,
      zero: zero3,
      alt: _alt4,
      extend: _extend4,
      compact: compact3,
      separate: separate3,
      filter: _filter3,
      filterMap: _filterMap3,
      partition: _partition3,
      partitionMap: _partitionMap3,
      wither: _wither3,
      wilt: _wilt3,
      throwError: throwError2
    };
    getApplySemigroup3 = getApplySemigroup(Apply6);
    getApplyMonoid2 = getApplicativeMonoid(Applicative4);
    getFirstMonoid = function() {
      return getMonoid3(first());
    };
    getLastMonoid = function() {
      return getMonoid3(last());
    };
  }
});

// node_modules/fp-ts/es6/string.js
var Eq2, Semigroup, empty4, Monoid, Ord2;
var init_string = __esm({
  "node_modules/fp-ts/es6/string.js"() {
    init_shim();
    init_ReadonlyNonEmptyArray();
    Eq2 = {
      equals: function(first2, second) {
        return first2 === second;
      }
    };
    Semigroup = {
      concat: function(first2, second) {
        return first2 + second;
      }
    };
    empty4 = "";
    Monoid = {
      concat: Semigroup.concat,
      empty: empty4
    };
    Ord2 = {
      equals: Eq2.equals,
      compare: function(first2, second) {
        return first2 < second ? -1 : first2 > second ? 1 : 0;
      }
    };
  }
});

// node_modules/fp-ts/es6/ReadonlyRecord.js
function collect(O) {
  if (typeof O === "function") {
    return collect(Ord2)(O);
  }
  var keysO = keys_(O);
  return function(f) {
    return function(r) {
      var out = [];
      for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {
        var key = _a[_i];
        out.push(f(key, r[key]));
      }
      return out;
    };
  };
}
function isSubrecord(E) {
  return function(me, that) {
    if (that === void 0) {
      var isSubrecordE_1 = isSubrecord(E);
      return function(that2) {
        return isSubrecordE_1(that2, me);
      };
    }
    for (var k in me) {
      if (!has.call(that, k) || !E.equals(me[k], that[k])) {
        return false;
      }
    }
    return true;
  };
}
function lookup3(k, r) {
  if (r === void 0) {
    return function(r2) {
      return lookup3(k, r2);
    };
  }
  return has.call(r, k) ? some(r[k]) : none;
}
function mapWithIndex4(f) {
  return function(r) {
    var out = {};
    for (var k in r) {
      if (has.call(r, k)) {
        out[k] = f(k, r[k]);
      }
    }
    return out;
  };
}
function map8(f) {
  return mapWithIndex4(function(_, a) {
    return f(a);
  });
}
function reduceWithIndex5() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  if (args.length === 2) {
    return reduceWithIndex5(Ord2).apply(void 0, args);
  }
  var keysO = keys_(args[0]);
  return function(b, f) {
    return function(fa) {
      var out = b;
      var ks = keysO(fa);
      var len = ks.length;
      for (var i = 0; i < len; i++) {
        var k = ks[i];
        out = f(k, out, fa[k]);
      }
      return out;
    };
  };
}
function foldMapWithIndex5(O) {
  if ("compare" in O) {
    var keysO_1 = keys_(O);
    return function(M) {
      return function(f) {
        return function(fa) {
          var out = M.empty;
          var ks = keysO_1(fa);
          var len = ks.length;
          for (var i = 0; i < len; i++) {
            var k = ks[i];
            out = M.concat(out, f(k, fa[k]));
          }
          return out;
        };
      };
    };
  }
  return foldMapWithIndex5(Ord2)(O);
}
function reduceRightWithIndex5() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  if (args.length === 2) {
    return reduceRightWithIndex5(Ord2).apply(void 0, args);
  }
  var keysO = keys_(args[0]);
  return function(b, f) {
    return function(fa) {
      var out = b;
      var ks = keysO(fa);
      var len = ks.length;
      for (var i = len - 1; i >= 0; i--) {
        var k = ks[i];
        out = f(k, fa[k], out);
      }
      return out;
    };
  };
}
function traverseWithIndex4(F) {
  var traverseWithIndexOF = _traverseWithIndex3(Ord2)(F);
  return function(f) {
    return function(ta) {
      return traverseWithIndexOF(ta, f);
    };
  };
}
function traverse6(F) {
  var traverseOF = _traverse6(Ord2)(F);
  return function(f) {
    return function(ta) {
      return traverseOF(ta, f);
    };
  };
}
function sequence6(F) {
  return _sequence(Ord2)(F);
}
function partitionMapWithIndex3(f) {
  return function(r) {
    var left4 = {};
    var right4 = {};
    for (var k in r) {
      if (has.call(r, k)) {
        var e = f(k, r[k]);
        switch (e._tag) {
          case "Left":
            left4[k] = e.left;
            break;
          case "Right":
            right4[k] = e.right;
            break;
        }
      }
    }
    return separated(left4, right4);
  };
}
function partitionWithIndex3(predicateWithIndex) {
  return function(r) {
    var left4 = {};
    var right4 = {};
    for (var k in r) {
      if (has.call(r, k)) {
        var a = r[k];
        if (predicateWithIndex(k, a)) {
          right4[k] = a;
        } else {
          left4[k] = a;
        }
      }
    }
    return separated(left4, right4);
  };
}
function filterMapWithIndex3(f) {
  return function(r) {
    var out = {};
    for (var k in r) {
      if (has.call(r, k)) {
        var ob = f(k, r[k]);
        if (isSome(ob)) {
          out[k] = ob.value;
        }
      }
    }
    return out;
  };
}
function filterWithIndex3(predicateWithIndex) {
  return function(fa) {
    var out = {};
    var changed = false;
    for (var key in fa) {
      if (has.call(fa, key)) {
        var a = fa[key];
        if (predicateWithIndex(key, a)) {
          out[key] = a;
        } else {
          changed = true;
        }
      }
    }
    return changed ? out : fa;
  };
}
function fromFoldable(M, F) {
  var fromFoldableMapM = fromFoldableMap(M, F);
  return function(fka) {
    return fromFoldableMapM(fka, identity);
  };
}
function fromFoldableMap(M, F) {
  return function(ta, f) {
    return F.reduce(ta, {}, function(r, a) {
      var _a = f(a), k = _a[0], b = _a[1];
      r[k] = has.call(r, k) ? M.concat(r[k], b) : b;
      return r;
    });
  };
}
function every3(predicate) {
  return function(r) {
    for (var k in r) {
      if (!predicate(r[k])) {
        return false;
      }
    }
    return true;
  };
}
function some4(predicate) {
  return function(r) {
    for (var k in r) {
      if (predicate(r[k])) {
        return true;
      }
    }
    return false;
  };
}
function elem5(E) {
  return function(a, fa) {
    if (fa === void 0) {
      var elemE_1 = elem5(E);
      return function(fa2) {
        return elemE_1(a, fa2);
      };
    }
    for (var k in fa) {
      if (E.equals(fa[k], a)) {
        return true;
      }
    }
    return false;
  };
}
function reduce7() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  if (args.length === 1) {
    var reduceWithIndexO_1 = reduceWithIndex5(args[0]);
    return function(b, f) {
      return reduceWithIndexO_1(b, function(_, b2, a) {
        return f(b2, a);
      });
    };
  }
  return reduce7(Ord2).apply(void 0, args);
}
function foldMap7(O) {
  if ("compare" in O) {
    var foldMapWithIndexO_1 = foldMapWithIndex5(O);
    return function(M) {
      var foldMapWithIndexM = foldMapWithIndexO_1(M);
      return function(f) {
        return foldMapWithIndexM(function(_, a) {
          return f(a);
        });
      };
    };
  }
  return foldMap7(Ord2)(O);
}
function reduceRight7() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  if (args.length === 1) {
    var reduceRightWithIndexO_1 = reduceRightWithIndex5(args[0]);
    return function(b, f) {
      return reduceRightWithIndexO_1(b, function(_, b2, a) {
        return f(b2, a);
      });
    };
  }
  return reduceRight7(Ord2).apply(void 0, args);
}
function getShow7(O) {
  if ("compare" in O) {
    return function(S) {
      return {
        show: function(r) {
          var elements = collect(O)(function(k, a) {
            return "".concat(JSON.stringify(k), ": ").concat(S.show(a));
          })(r).join(", ");
          return elements === "" ? "{}" : "{ ".concat(elements, " }");
        }
      };
    };
  }
  return getShow7(Ord2)(O);
}
function getEq7(E) {
  var isSubrecordE = isSubrecord(E);
  return fromEquals(function(x, y) {
    return isSubrecordE(x)(y) && isSubrecordE(y)(x);
  });
}
function getMonoid4(S) {
  return {
    concat: function(first2, second) {
      if (isEmpty3(first2)) {
        return second;
      }
      if (isEmpty3(second)) {
        return first2;
      }
      var r = Object.assign({}, first2);
      for (var k in second) {
        if (has.call(second, k)) {
          r[k] = has.call(first2, k) ? S.concat(first2[k], second[k]) : second[k];
        }
      }
      return r;
    },
    empty: empty5
  };
}
function hasOwnProperty2(k, r) {
  return has.call(r === void 0 ? this : r, k);
}
var size2, isEmpty3, keys_, keys, toReadonlyArray, upsertAt, has2, empty5, singleton2, union5, intersection3, difference2, _map8, _mapWithIndex3, _reduce6, _foldMap6, _reduceRight6, _filter4, _filterMap4, _partition4, _partitionMap4, _reduceWithIndex3, _foldMapWithIndex3, _reduceRightWithIndex3, _partitionMapWithIndex2, _partitionWithIndex2, _filterMapWithIndex2, _filterWithIndex2, _traverse6, _sequence, _traverseWithIndex3, filter5, filterMap4, partition4, partitionMap4, compact4, separate4, URI8, Functor8, flap9, Compactable4, Foldable5, FoldableWithIndex3, Traversable6, TraversableWithIndex3, _wither4, _wilt4, Witherable4, readonlyRecord;
var init_ReadonlyRecord = __esm({
  "node_modules/fp-ts/es6/ReadonlyRecord.js"() {
    init_shim();
    init_Eq();
    init_function();
    init_Functor();
    init_internal();
    init_Separated();
    init_string();
    init_Witherable();
    size2 = function(r) {
      return Object.keys(r).length;
    };
    isEmpty3 = function(r) {
      for (var k in r) {
        if (has.call(r, k)) {
          return false;
        }
      }
      return true;
    };
    keys_ = function(O) {
      return function(r) {
        return Object.keys(r).sort(O.compare);
      };
    };
    keys = keys_(Ord2);
    toReadonlyArray = collect(Ord2)(function(k, a) {
      return [k, a];
    });
    upsertAt = function(k, a) {
      return function(r) {
        if (has.call(r, k) && r[k] === a) {
          return r;
        }
        var out = Object.assign({}, r);
        out[k] = a;
        return out;
      };
    };
    has2 = function(k, r) {
      return has.call(r, k);
    };
    empty5 = {};
    singleton2 = function(k, a) {
      var _a;
      return _a = {}, _a[k] = a, _a;
    };
    union5 = function(M) {
      return function(second) {
        return function(first2) {
          if (isEmpty3(first2)) {
            return second;
          }
          if (isEmpty3(second)) {
            return first2;
          }
          var out = {};
          for (var k in first2) {
            if (has2(k, second)) {
              out[k] = M.concat(first2[k], second[k]);
            } else {
              out[k] = first2[k];
            }
          }
          for (var k in second) {
            if (!has2(k, out)) {
              out[k] = second[k];
            }
          }
          return out;
        };
      };
    };
    intersection3 = function(M) {
      return function(second) {
        return function(first2) {
          if (isEmpty3(first2) || isEmpty3(second)) {
            return empty5;
          }
          var out = {};
          for (var k in first2) {
            if (has2(k, second)) {
              out[k] = M.concat(first2[k], second[k]);
            }
          }
          return out;
        };
      };
    };
    difference2 = function(second) {
      return function(first2) {
        if (isEmpty3(first2)) {
          return second;
        }
        if (isEmpty3(second)) {
          return first2;
        }
        var out = {};
        for (var k in first2) {
          if (!has2(k, second)) {
            out[k] = first2[k];
          }
        }
        for (var k in second) {
          if (!has2(k, first2)) {
            out[k] = second[k];
          }
        }
        return out;
      };
    };
    _map8 = function(fa, f) {
      return pipe(fa, map8(f));
    };
    _mapWithIndex3 = function(fa, f) {
      return pipe(fa, mapWithIndex4(f));
    };
    _reduce6 = function(O) {
      var reduceO = reduce7(O);
      return function(fa, b, f) {
        return pipe(fa, reduceO(b, f));
      };
    };
    _foldMap6 = function(O) {
      return function(M) {
        var foldMapM = foldMap7(O)(M);
        return function(fa, f) {
          return pipe(fa, foldMapM(f));
        };
      };
    };
    _reduceRight6 = function(O) {
      var reduceRightO = reduceRight7(O);
      return function(fa, b, f) {
        return pipe(fa, reduceRightO(b, f));
      };
    };
    _filter4 = function(fa, predicate) {
      return pipe(fa, filter5(predicate));
    };
    _filterMap4 = function(fa, f) {
      return pipe(fa, filterMap4(f));
    };
    _partition4 = function(fa, predicate) {
      return pipe(fa, partition4(predicate));
    };
    _partitionMap4 = function(fa, f) {
      return pipe(fa, partitionMap4(f));
    };
    _reduceWithIndex3 = function(O) {
      var reduceWithIndexO = reduceWithIndex5(O);
      return function(fa, b, f) {
        return pipe(fa, reduceWithIndexO(b, f));
      };
    };
    _foldMapWithIndex3 = function(O) {
      var foldMapWithIndexO = foldMapWithIndex5(O);
      return function(M) {
        var foldMapWithIndexM = foldMapWithIndexO(M);
        return function(fa, f) {
          return pipe(fa, foldMapWithIndexM(f));
        };
      };
    };
    _reduceRightWithIndex3 = function(O) {
      var reduceRightWithIndexO = reduceRightWithIndex5(O);
      return function(fa, b, f) {
        return pipe(fa, reduceRightWithIndexO(b, f));
      };
    };
    _partitionMapWithIndex2 = function(fa, f) {
      return pipe(fa, partitionMapWithIndex3(f));
    };
    _partitionWithIndex2 = function(fa, predicateWithIndex) {
      return pipe(fa, partitionWithIndex3(predicateWithIndex));
    };
    _filterMapWithIndex2 = function(fa, f) {
      return pipe(fa, filterMapWithIndex3(f));
    };
    _filterWithIndex2 = function(fa, predicateWithIndex) {
      return pipe(fa, filterWithIndex3(predicateWithIndex));
    };
    _traverse6 = function(O) {
      var traverseWithIndexO = _traverseWithIndex3(O);
      return function(F) {
        var traverseWithIndexOF = traverseWithIndexO(F);
        return function(ta, f) {
          return traverseWithIndexOF(ta, flow(SK, f));
        };
      };
    };
    _sequence = function(O) {
      var traverseO = _traverse6(O);
      return function(F) {
        var traverseOF = traverseO(F);
        return function(ta) {
          return traverseOF(ta, identity);
        };
      };
    };
    _traverseWithIndex3 = function(O) {
      return function(F) {
        var keysO = keys_(O);
        return function(ta, f) {
          var ks = keysO(ta);
          if (ks.length === 0) {
            return F.of(empty5);
          }
          var fr = F.of({});
          var _loop_1 = function(key2) {
            fr = F.ap(F.map(fr, function(r) {
              return function(b) {
                var _a;
                return Object.assign({}, r, (_a = {}, _a[key2] = b, _a));
              };
            }), f(key2, ta[key2]));
          };
          for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {
            var key = ks_1[_i];
            _loop_1(key);
          }
          return fr;
        };
      };
    };
    filter5 = function(predicate) {
      return filterWithIndex3(function(_, a) {
        return predicate(a);
      });
    };
    filterMap4 = function(f) {
      return filterMapWithIndex3(function(_, a) {
        return f(a);
      });
    };
    partition4 = function(predicate) {
      return partitionWithIndex3(function(_, a) {
        return predicate(a);
      });
    };
    partitionMap4 = function(f) {
      return partitionMapWithIndex3(function(_, a) {
        return f(a);
      });
    };
    compact4 = function(r) {
      var out = {};
      for (var k in r) {
        if (has.call(r, k)) {
          var oa = r[k];
          if (isSome(oa)) {
            out[k] = oa.value;
          }
        }
      }
      return out;
    };
    separate4 = function(r) {
      var left4 = {};
      var right4 = {};
      for (var k in r) {
        if (has.call(r, k)) {
          var e = r[k];
          if (isLeft(e)) {
            left4[k] = e.left;
          } else {
            right4[k] = e.right;
          }
        }
      }
      return separated(left4, right4);
    };
    URI8 = "ReadonlyRecord";
    Functor8 = {
      URI: URI8,
      map: _map8
    };
    flap9 = flap(Functor8);
    Compactable4 = {
      URI: URI8,
      compact: compact4,
      separate: separate4
    };
    Foldable5 = {
      URI: URI8,
      reduce: _reduce6(Ord2),
      foldMap: _foldMap6(Ord2),
      reduceRight: _reduceRight6(Ord2)
    };
    FoldableWithIndex3 = {
      URI: URI8,
      reduce: _reduce6(Ord2),
      foldMap: _foldMap6(Ord2),
      reduceRight: _reduceRight6(Ord2),
      reduceWithIndex: _reduceWithIndex3(Ord2),
      foldMapWithIndex: _foldMapWithIndex3(Ord2),
      reduceRightWithIndex: _reduceRightWithIndex3(Ord2)
    };
    Traversable6 = {
      URI: URI8,
      map: _map8,
      reduce: _reduce6(Ord2),
      foldMap: _foldMap6(Ord2),
      reduceRight: _reduceRight6(Ord2),
      traverse: _traverse6(Ord2),
      sequence: sequence6
    };
    TraversableWithIndex3 = {
      URI: URI8,
      map: _map8,
      mapWithIndex: _mapWithIndex3,
      reduce: _reduce6(Ord2),
      foldMap: _foldMap6(Ord2),
      reduceRight: _reduceRight6(Ord2),
      reduceWithIndex: _reduceWithIndex3(Ord2),
      foldMapWithIndex: _foldMapWithIndex3(Ord2),
      reduceRightWithIndex: _reduceRightWithIndex3(Ord2),
      traverse: _traverse6(Ord2),
      sequence: sequence6,
      traverseWithIndex: _traverseWithIndex3(Ord2)
    };
    _wither4 = witherDefault(Traversable6, Compactable4);
    _wilt4 = wiltDefault(Traversable6, Compactable4);
    Witherable4 = {
      URI: URI8,
      map: _map8,
      reduce: _reduce6(Ord2),
      foldMap: _foldMap6(Ord2),
      reduceRight: _reduceRight6(Ord2),
      traverse: _traverse6(Ord2),
      sequence: sequence6,
      compact: compact4,
      separate: separate4,
      filter: _filter4,
      filterMap: _filterMap4,
      partition: _partition4,
      partitionMap: _partitionMap4,
      wither: _wither4,
      wilt: _wilt4
    };
    readonlyRecord = {
      URI: URI8,
      map: _map8,
      reduce: _reduce6(Ord2),
      foldMap: _foldMap6(Ord2),
      reduceRight: _reduceRight6(Ord2),
      traverse: _traverse6(Ord2),
      sequence: sequence6,
      compact: compact4,
      separate: separate4,
      filter: _filter4,
      filterMap: _filterMap4,
      partition: _partition4,
      partitionMap: _partitionMap4,
      mapWithIndex: _mapWithIndex3,
      reduceWithIndex: _reduceWithIndex3(Ord2),
      foldMapWithIndex: _foldMapWithIndex3(Ord2),
      reduceRightWithIndex: _reduceRightWithIndex3(Ord2),
      filterMapWithIndex: _filterMapWithIndex2,
      filterWithIndex: _filterWithIndex2,
      partitionMapWithIndex: _partitionMapWithIndex2,
      partitionWithIndex: _partitionWithIndex2,
      traverseWithIndex: _traverseWithIndex3(Ord2),
      wither: _wither4,
      wilt: _wilt4
    };
  }
});

// node_modules/fp-ts/es6/Record.js
var Record_exports = {};
__export(Record_exports, {
  Compactable: () => Compactable5,
  Filterable: () => Filterable3,
  FilterableWithIndex: () => FilterableWithIndex2,
  Foldable: () => Foldable6,
  FoldableWithIndex: () => FoldableWithIndex4,
  Functor: () => Functor9,
  FunctorWithIndex: () => FunctorWithIndex3,
  Traversable: () => Traversable7,
  TraversableWithIndex: () => TraversableWithIndex4,
  URI: () => URI9,
  Witherable: () => Witherable5,
  collect: () => collect2,
  compact: () => compact5,
  deleteAt: () => deleteAt2,
  difference: () => difference3,
  elem: () => elem6,
  empty: () => empty6,
  every: () => every4,
  filter: () => filter6,
  filterMap: () => filterMap5,
  filterMapWithIndex: () => filterMapWithIndex4,
  filterWithIndex: () => filterWithIndex4,
  flap: () => flap10,
  foldMap: () => foldMap8,
  foldMapWithIndex: () => foldMapWithIndex6,
  fromEntries: () => fromEntries,
  fromFoldable: () => fromFoldable2,
  fromFoldableMap: () => fromFoldableMap2,
  getDifferenceMagma: () => getDifferenceMagma2,
  getEq: () => getEq8,
  getFoldable: () => getFoldable,
  getFoldableWithIndex: () => getFoldableWithIndex,
  getIntersectionSemigroup: () => getIntersectionSemigroup2,
  getMonoid: () => getMonoid5,
  getShow: () => getShow8,
  getTraversable: () => getTraversable,
  getTraversableWithIndex: () => getTraversableWithIndex,
  getUnionMonoid: () => getUnionMonoid2,
  getUnionSemigroup: () => getUnionSemigroup3,
  getWitherable: () => getWitherable2,
  has: () => has3,
  hasOwnProperty: () => hasOwnProperty3,
  insertAt: () => insertAt3,
  intersection: () => intersection4,
  isEmpty: () => isEmpty4,
  isSubrecord: () => isSubrecord2,
  keys: () => keys2,
  lookup: () => lookup4,
  map: () => map9,
  mapWithIndex: () => mapWithIndex5,
  modifyAt: () => modifyAt3,
  partition: () => partition5,
  partitionMap: () => partitionMap5,
  partitionMapWithIndex: () => partitionMapWithIndex4,
  partitionWithIndex: () => partitionWithIndex4,
  pop: () => pop,
  record: () => record2,
  reduce: () => reduce8,
  reduceRight: () => reduceRight8,
  reduceRightWithIndex: () => reduceRightWithIndex6,
  reduceWithIndex: () => reduceWithIndex6,
  separate: () => separate5,
  sequence: () => sequence7,
  singleton: () => singleton3,
  size: () => size3,
  some: () => some5,
  toArray: () => toArray,
  toEntries: () => toEntries,
  toUnfoldable: () => toUnfoldable,
  traverse: () => traverse7,
  traverseWithIndex: () => traverseWithIndex5,
  union: () => union6,
  updateAt: () => updateAt3,
  upsertAt: () => upsertAt2,
  wilt: () => wilt3,
  wither: () => wither3
});
function collect2(O) {
  if (typeof O === "function") {
    return collect2(Ord2)(O);
  }
  var keysO = keys_2(O);
  return function(f) {
    return function(r) {
      var out = [];
      for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {
        var key = _a[_i];
        out.push(f(key, r[key]));
      }
      return out;
    };
  };
}
function toUnfoldable(U) {
  return function(r) {
    var sas = toArray(r);
    var len = sas.length;
    return U.unfold(0, function(b) {
      return b < len ? some([sas[b], b + 1]) : none;
    });
  };
}
function deleteAt2(k) {
  return function(r) {
    if (!has.call(r, k)) {
      return r;
    }
    var out = Object.assign({}, r);
    delete out[k];
    return out;
  };
}
function pop(k) {
  var deleteAtk = deleteAt2(k);
  return function(r) {
    var oa = lookup4(k, r);
    return isNone(oa) ? none : some([oa.value, deleteAtk(r)]);
  };
}
function reduceWithIndex6() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return args.length === 1 ? reduceWithIndex5(args[0]) : reduceWithIndex5(Ord2).apply(void 0, args);
}
function foldMapWithIndex6(O) {
  return "compare" in O ? foldMapWithIndex5(O) : foldMapWithIndex5(Ord2)(O);
}
function reduceRightWithIndex6() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return args.length === 1 ? reduceRightWithIndex5(args[0]) : reduceRightWithIndex5(Ord2).apply(void 0, args);
}
function traverseWithIndex5(F) {
  return traverseWithIndex4(F);
}
function traverse7(F) {
  return traverse6(F);
}
function sequence7(F) {
  return sequence6(F);
}
function partitionWithIndex4(predicateWithIndex) {
  return partitionWithIndex3(predicateWithIndex);
}
function filterWithIndex4(predicateWithIndex) {
  return filterWithIndex3(predicateWithIndex);
}
function fromFoldable2(M, F) {
  return fromFoldable(M, F);
}
function fromFoldableMap2(M, F) {
  return fromFoldableMap(M, F);
}
function reduce8() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return args.length === 1 ? reduce7(args[0]) : reduce7(Ord2).apply(void 0, args);
}
function foldMap8(O) {
  return "compare" in O ? foldMap7(O) : foldMap7(Ord2)(O);
}
function reduceRight8() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return args.length === 1 ? reduceRight7(args[0]) : reduceRight7(Ord2).apply(void 0, args);
}
function getShow8(O) {
  return "compare" in O ? getShow7(O) : getShow7(Ord2)(O);
}
var __assign2, size3, isEmpty4, keys_2, keys2, toArray, upsertAt2, has3, updateAt3, modifyAt3, isSubrecord2, lookup4, mapWithIndex5, map9, singleton3, wither3, wilt3, partitionMapWithIndex4, filterMapWithIndex4, toEntries, fromEntries, every4, some5, elem6, union6, intersection4, difference3, _map9, _mapWithIndex4, _reduce7, _foldMap7, _reduceRight7, _filter5, _filterMap5, _partition5, _partitionMap5, _reduceWithIndex4, _foldMapWithIndex4, _reduceRightWithIndex4, _partitionMapWithIndex3, _partitionWithIndex3, _filterMapWithIndex3, _filterWithIndex3, _traverse7, _sequence2, _traverseWithIndex4, filter6, filterMap5, partition5, partitionMap5, compact5, separate5, URI9, getEq8, getMonoid5, Functor9, flap10, FunctorWithIndex3, getFoldable, getFoldableWithIndex, Compactable5, Filterable3, FilterableWithIndex2, getTraversable, getTraversableWithIndex, getWitherable2, getUnionSemigroup3, getUnionMonoid2, getIntersectionSemigroup2, getDifferenceMagma2, Foldable6, FoldableWithIndex4, Traversable7, TraversableWithIndex4, _wither5, _wilt5, Witherable5, empty6, insertAt3, hasOwnProperty3, record2;
var init_Record = __esm({
  "node_modules/fp-ts/es6/Record.js"() {
    init_shim();
    init_Array();
    init_function();
    init_Functor();
    init_internal();
    init_ReadonlyRecord();
    init_Semigroup();
    init_string();
    init_Witherable();
    __assign2 = function() {
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    size3 = size2;
    isEmpty4 = isEmpty3;
    keys_2 = function(O) {
      return function(r) {
        return Object.keys(r).sort(O.compare);
      };
    };
    keys2 = keys_2(Ord2);
    toArray = collect2(Ord2)(function(k, a) {
      return [
        k,
        a
      ];
    });
    upsertAt2 = upsertAt;
    has3 = has2;
    updateAt3 = function(k, a) {
      return modifyAt3(k, function() {
        return a;
      });
    };
    modifyAt3 = function(k, f) {
      return function(r) {
        if (!has3(k, r)) {
          return none;
        }
        var out = Object.assign({}, r);
        out[k] = f(r[k]);
        return some(out);
      };
    };
    isSubrecord2 = isSubrecord;
    lookup4 = lookup3;
    mapWithIndex5 = mapWithIndex4;
    map9 = map8;
    singleton3 = singleton2;
    wither3 = function(F) {
      var traverseF = traverse7(F);
      return function(f) {
        return function(fa) {
          return F.map(pipe(fa, traverseF(f)), compact5);
        };
      };
    };
    wilt3 = function(F) {
      var traverseF = traverse7(F);
      return function(f) {
        return function(fa) {
          return F.map(pipe(fa, traverseF(f)), separate5);
        };
      };
    };
    partitionMapWithIndex4 = partitionMapWithIndex3;
    filterMapWithIndex4 = filterMapWithIndex3;
    toEntries = toArray;
    fromEntries = function(fa) {
      return fromFoldable2(last(), Foldable3)(fa);
    };
    every4 = every3;
    some5 = some4;
    elem6 = elem5;
    union6 = function(M) {
      var unionM = union5(M);
      return function(second) {
        return function(first2) {
          if (isEmpty4(first2)) {
            return __assign2({}, second);
          }
          if (isEmpty4(second)) {
            return __assign2({}, first2);
          }
          return unionM(second)(first2);
        };
      };
    };
    intersection4 = function(M) {
      return function(second) {
        return function(first2) {
          if (isEmpty4(first2) || isEmpty4(second)) {
            return {};
          }
          return intersection3(M)(second)(first2);
        };
      };
    };
    difference3 = function(second) {
      return function(first2) {
        if (isEmpty4(first2)) {
          return __assign2({}, second);
        }
        if (isEmpty4(second)) {
          return __assign2({}, first2);
        }
        return difference2(second)(first2);
      };
    };
    _map9 = _map8;
    _mapWithIndex4 = _mapWithIndex3;
    _reduce7 = _reduce6;
    _foldMap7 = _foldMap6;
    _reduceRight7 = _reduceRight6;
    _filter5 = _filter4;
    _filterMap5 = _filterMap4;
    _partition5 = _partition4;
    _partitionMap5 = _partitionMap4;
    _reduceWithIndex4 = _reduceWithIndex3;
    _foldMapWithIndex4 = _foldMapWithIndex3;
    _reduceRightWithIndex4 = _reduceRightWithIndex3;
    _partitionMapWithIndex3 = _partitionMapWithIndex2;
    _partitionWithIndex3 = _partitionWithIndex2;
    _filterMapWithIndex3 = _filterMapWithIndex2;
    _filterWithIndex3 = _filterWithIndex2;
    _traverse7 = _traverse6;
    _sequence2 = _sequence;
    _traverseWithIndex4 = function(O) {
      return function(F) {
        var keysO = keys_2(O);
        return function(ta, f) {
          var ks = keysO(ta);
          if (ks.length === 0) {
            return F.of({});
          }
          var fr = F.of({});
          var _loop_1 = function(key2) {
            fr = F.ap(F.map(fr, function(r) {
              return function(b) {
                r[key2] = b;
                return r;
              };
            }), f(key2, ta[key2]));
          };
          for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {
            var key = ks_1[_i];
            _loop_1(key);
          }
          return fr;
        };
      };
    };
    filter6 = filter5;
    filterMap5 = filterMap4;
    partition5 = partition4;
    partitionMap5 = partitionMap4;
    compact5 = compact4;
    separate5 = separate4;
    URI9 = "Record";
    getEq8 = getEq7;
    getMonoid5 = getMonoid4;
    Functor9 = {
      URI: URI9,
      map: _map9
    };
    flap10 = flap(Functor9);
    FunctorWithIndex3 = {
      URI: URI9,
      map: _map9,
      mapWithIndex: _mapWithIndex4
    };
    getFoldable = function(O) {
      return {
        URI: URI9,
        reduce: _reduce7(O),
        foldMap: _foldMap7(O),
        reduceRight: _reduceRight7(O)
      };
    };
    getFoldableWithIndex = function(O) {
      return {
        URI: URI9,
        reduce: _reduce7(O),
        foldMap: _foldMap7(O),
        reduceRight: _reduceRight7(O),
        reduceWithIndex: _reduceWithIndex4(O),
        foldMapWithIndex: _foldMapWithIndex4(O),
        reduceRightWithIndex: _reduceRightWithIndex4(O)
      };
    };
    Compactable5 = {
      URI: URI9,
      compact: compact5,
      separate: separate5
    };
    Filterable3 = {
      URI: URI9,
      map: _map9,
      compact: compact5,
      separate: separate5,
      filter: _filter5,
      filterMap: _filterMap5,
      partition: _partition5,
      partitionMap: _partitionMap5
    };
    FilterableWithIndex2 = {
      URI: URI9,
      map: _map9,
      mapWithIndex: _mapWithIndex4,
      compact: compact5,
      separate: separate5,
      filter: _filter5,
      filterMap: _filterMap5,
      partition: _partition5,
      partitionMap: _partitionMap5,
      filterMapWithIndex: _filterMapWithIndex3,
      filterWithIndex: _filterWithIndex3,
      partitionMapWithIndex: _partitionMapWithIndex3,
      partitionWithIndex: _partitionWithIndex3
    };
    getTraversable = function(O) {
      return {
        URI: URI9,
        map: _map9,
        reduce: _reduce7(O),
        foldMap: _foldMap7(O),
        reduceRight: _reduceRight7(O),
        traverse: _traverse7(O),
        sequence: _sequence2(O)
      };
    };
    getTraversableWithIndex = function(O) {
      return {
        URI: URI9,
        map: _map9,
        mapWithIndex: _mapWithIndex4,
        reduce: _reduce7(O),
        foldMap: _foldMap7(O),
        reduceRight: _reduceRight7(O),
        reduceWithIndex: _reduceWithIndex4(O),
        foldMapWithIndex: _foldMapWithIndex4(O),
        reduceRightWithIndex: _reduceRightWithIndex4(O),
        traverse: _traverse7(O),
        sequence: _sequence2(O),
        traverseWithIndex: _traverseWithIndex4(O)
      };
    };
    getWitherable2 = function(O) {
      var T = getTraversable(O);
      return {
        URI: URI9,
        map: _map9,
        reduce: _reduce7(O),
        foldMap: _foldMap7(O),
        reduceRight: _reduceRight7(O),
        traverse: T.traverse,
        sequence: T.sequence,
        compact: compact5,
        separate: separate5,
        filter: _filter5,
        filterMap: _filterMap5,
        partition: _partition5,
        partitionMap: _partitionMap5,
        wither: witherDefault(T, Compactable5),
        wilt: wiltDefault(T, Compactable5)
      };
    };
    getUnionSemigroup3 = function(S) {
      var unionS = union6(S);
      return {
        concat: function(first2, second) {
          return unionS(second)(first2);
        }
      };
    };
    getUnionMonoid2 = function(S) {
      return {
        concat: getUnionSemigroup3(S).concat,
        empty: {}
      };
    };
    getIntersectionSemigroup2 = function(S) {
      var intersectionS = intersection4(S);
      return {
        concat: function(first2, second) {
          return intersectionS(second)(first2);
        }
      };
    };
    getDifferenceMagma2 = function() {
      return {
        concat: function(first2, second) {
          return difference3(second)(first2);
        }
      };
    };
    Foldable6 = {
      URI: URI9,
      reduce: _reduce7(Ord2),
      foldMap: _foldMap7(Ord2),
      reduceRight: _reduceRight7(Ord2)
    };
    FoldableWithIndex4 = {
      URI: URI9,
      reduce: _reduce7(Ord2),
      foldMap: _foldMap7(Ord2),
      reduceRight: _reduceRight7(Ord2),
      reduceWithIndex: _reduceWithIndex4(Ord2),
      foldMapWithIndex: _foldMapWithIndex4(Ord2),
      reduceRightWithIndex: _reduceRightWithIndex4(Ord2)
    };
    Traversable7 = {
      URI: URI9,
      map: _map9,
      reduce: _reduce7(Ord2),
      foldMap: _foldMap7(Ord2),
      reduceRight: _reduceRight7(Ord2),
      traverse: _traverse7(Ord2),
      sequence: sequence7
    };
    TraversableWithIndex4 = {
      URI: URI9,
      map: _map9,
      mapWithIndex: _mapWithIndex4,
      reduce: _reduce7(Ord2),
      foldMap: _foldMap7(Ord2),
      reduceRight: _reduceRight7(Ord2),
      reduceWithIndex: _reduceWithIndex4(Ord2),
      foldMapWithIndex: _foldMapWithIndex4(Ord2),
      reduceRightWithIndex: _reduceRightWithIndex4(Ord2),
      traverse: _traverse7(Ord2),
      sequence: sequence7,
      traverseWithIndex: _traverseWithIndex4(Ord2)
    };
    _wither5 = witherDefault(Traversable7, Compactable5);
    _wilt5 = wiltDefault(Traversable7, Compactable5);
    Witherable5 = {
      URI: URI9,
      map: _map9,
      reduce: _reduce7(Ord2),
      foldMap: _foldMap7(Ord2),
      reduceRight: _reduceRight7(Ord2),
      traverse: _traverse7(Ord2),
      sequence: sequence7,
      compact: compact5,
      separate: separate5,
      filter: _filter5,
      filterMap: _filterMap5,
      partition: _partition5,
      partitionMap: _partitionMap5,
      wither: _wither5,
      wilt: _wilt5
    };
    empty6 = {};
    insertAt3 = upsertAt2;
    hasOwnProperty3 = hasOwnProperty2;
    record2 = {
      URI: URI9,
      map: _map9,
      reduce: _reduce7(Ord2),
      foldMap: _foldMap7(Ord2),
      reduceRight: _reduceRight7(Ord2),
      traverse: _traverse7(Ord2),
      sequence: sequence7,
      compact: compact5,
      separate: separate5,
      filter: _filter5,
      filterMap: _filterMap5,
      partition: _partition5,
      partitionMap: _partitionMap5,
      mapWithIndex: _mapWithIndex4,
      reduceWithIndex: _reduceWithIndex4(Ord2),
      foldMapWithIndex: _foldMapWithIndex4(Ord2),
      reduceRightWithIndex: _reduceRightWithIndex4(Ord2),
      filterMapWithIndex: _filterMapWithIndex3,
      filterWithIndex: _filterWithIndex3,
      partitionMapWithIndex: _partitionMapWithIndex3,
      partitionWithIndex: _partitionWithIndex3,
      traverseWithIndex: _traverseWithIndex4(Ord2),
      wither: _wither5,
      wilt: _wilt5
    };
  }
});

// node_modules/fp-ts/es6/pipeable.js
var pipeable_exports = {};
__export(pipeable_exports, {
  alt: () => alt5,
  ap: () => ap8,
  bimap: () => bimap2,
  chain: () => chain7,
  compose: () => compose,
  contramap: () => contramap2,
  extend: () => extend7,
  filter: () => filter7,
  filterMap: () => filterMap6,
  filterMapWithIndex: () => filterMapWithIndex5,
  filterWithIndex: () => filterWithIndex5,
  foldMap: () => foldMap9,
  foldMapWithIndex: () => foldMapWithIndex7,
  map: () => map10,
  mapLeft: () => mapLeft2,
  mapWithIndex: () => mapWithIndex6,
  partition: () => partition6,
  partitionMap: () => partitionMap6,
  partitionMapWithIndex: () => partitionMapWithIndex5,
  partitionWithIndex: () => partitionWithIndex5,
  pipe: () => pipe2,
  pipeable: () => pipeable,
  promap: () => promap,
  reduce: () => reduce9,
  reduceRight: () => reduceRight9,
  reduceRightWithIndex: () => reduceRightWithIndex7,
  reduceWithIndex: () => reduceWithIndex7
});
function map10(F) {
  return function(f) {
    return function(fa) {
      return F.map(fa, f);
    };
  };
}
function contramap2(F) {
  return function(f) {
    return function(fa) {
      return F.contramap(fa, f);
    };
  };
}
function mapWithIndex6(F) {
  return function(f) {
    return function(fa) {
      return F.mapWithIndex(fa, f);
    };
  };
}
function ap8(F) {
  return function(fa) {
    return function(fab) {
      return F.ap(fab, fa);
    };
  };
}
function chain7(F) {
  return function(f) {
    return function(fa) {
      return F.chain(fa, f);
    };
  };
}
function bimap2(F) {
  return function(f, g) {
    return function(fea) {
      return F.bimap(fea, f, g);
    };
  };
}
function mapLeft2(F) {
  return function(f) {
    return function(fea) {
      return F.mapLeft(fea, f);
    };
  };
}
function extend7(F) {
  return function(f) {
    return function(wa) {
      return F.extend(wa, f);
    };
  };
}
function reduce9(F) {
  return function(b, f) {
    return function(fa) {
      return F.reduce(fa, b, f);
    };
  };
}
function foldMap9(F) {
  return function(M) {
    var foldMapM = F.foldMap(M);
    return function(f) {
      return function(fa) {
        return foldMapM(fa, f);
      };
    };
  };
}
function reduceRight9(F) {
  return function(b, f) {
    return function(fa) {
      return F.reduceRight(fa, b, f);
    };
  };
}
function reduceWithIndex7(F) {
  return function(b, f) {
    return function(fa) {
      return F.reduceWithIndex(fa, b, f);
    };
  };
}
function foldMapWithIndex7(F) {
  return function(M) {
    var foldMapWithIndexM = F.foldMapWithIndex(M);
    return function(f) {
      return function(fa) {
        return foldMapWithIndexM(fa, f);
      };
    };
  };
}
function reduceRightWithIndex7(F) {
  return function(b, f) {
    return function(fa) {
      return F.reduceRightWithIndex(fa, b, f);
    };
  };
}
function alt5(F) {
  return function(that) {
    return function(fa) {
      return F.alt(fa, that);
    };
  };
}
function filter7(F) {
  return function(predicate) {
    return function(fa) {
      return F.filter(fa, predicate);
    };
  };
}
function filterMap6(F) {
  return function(f) {
    return function(fa) {
      return F.filterMap(fa, f);
    };
  };
}
function partition6(F) {
  return function(f) {
    return function(fa) {
      return F.partition(fa, f);
    };
  };
}
function partitionMap6(F) {
  return function(f) {
    return function(fa) {
      return F.partitionMap(fa, f);
    };
  };
}
function filterWithIndex5(F) {
  return function(predicate) {
    return function(fa) {
      return F.filterWithIndex(fa, predicate);
    };
  };
}
function filterMapWithIndex5(F) {
  return function(f) {
    return function(fa) {
      return F.filterMapWithIndex(fa, f);
    };
  };
}
function partitionWithIndex5(F) {
  return function(f) {
    return function(fa) {
      return F.partitionWithIndex(fa, f);
    };
  };
}
function partitionMapWithIndex5(F) {
  return function(f) {
    return function(fa) {
      return F.partitionMapWithIndex(fa, f);
    };
  };
}
function promap(F) {
  return function(f, g) {
    return function(fbc) {
      return F.promap(fbc, f, g);
    };
  };
}
function compose(F) {
  return function(ea) {
    return function(ab) {
      return F.compose(ab, ea);
    };
  };
}
function pipeable(I) {
  var r = {};
  if (isFunctor(I)) {
    r.map = map10(I);
  }
  if (isContravariant(I)) {
    r.contramap = contramap2(I);
  }
  if (isFunctorWithIndex(I)) {
    r.mapWithIndex = mapWithIndex6(I);
  }
  if (isApply(I)) {
    r.ap = ap8(I);
    r.apFirst = apFirst(I);
    r.apSecond = apSecond(I);
  }
  if (isChain(I)) {
    r.chain = chain7(I);
    r.chainFirst = chainFirst(I);
    r.flatten = r.chain(identity);
  }
  if (isBifunctor(I)) {
    r.bimap = bimap2(I);
    r.mapLeft = mapLeft2(I);
  }
  if (isExtend(I)) {
    r.extend = extend7(I);
    r.duplicate = r.extend(identity);
  }
  if (isFoldable(I)) {
    r.reduce = reduce9(I);
    r.foldMap = foldMap9(I);
    r.reduceRight = reduceRight9(I);
  }
  if (isFoldableWithIndex(I)) {
    r.reduceWithIndex = reduceWithIndex7(I);
    r.foldMapWithIndex = foldMapWithIndex7(I);
    r.reduceRightWithIndex = reduceRightWithIndex7(I);
  }
  if (isAlt(I)) {
    r.alt = alt5(I);
  }
  if (isCompactable(I)) {
    r.compact = I.compact;
    r.separate = I.separate;
  }
  if (isFilterable(I)) {
    r.filter = filter7(I);
    r.filterMap = filterMap6(I);
    r.partition = partition6(I);
    r.partitionMap = partitionMap6(I);
  }
  if (isFilterableWithIndex(I)) {
    r.filterWithIndex = filterWithIndex5(I);
    r.filterMapWithIndex = filterMapWithIndex5(I);
    r.partitionWithIndex = partitionWithIndex5(I);
    r.partitionMapWithIndex = partitionMapWithIndex5(I);
  }
  if (isProfunctor(I)) {
    r.promap = promap(I);
  }
  if (isSemigroupoid(I)) {
    r.compose = compose(I);
  }
  if (isMonadThrow(I)) {
    var fromOption4 = function(onNone) {
      return function(ma) {
        return ma._tag === "None" ? I.throwError(onNone()) : I.of(ma.value);
      };
    };
    var fromEither4 = function(ma) {
      return ma._tag === "Left" ? I.throwError(ma.left) : I.of(ma.right);
    };
    var fromPredicate5 = function(predicate, onFalse) {
      return function(a) {
        return predicate(a) ? I.of(a) : I.throwError(onFalse(a));
      };
    };
    var filterOrElse3 = function(predicate, onFalse) {
      return function(ma) {
        return I.chain(ma, function(a) {
          return predicate(a) ? I.of(a) : I.throwError(onFalse(a));
        });
      };
    };
    r.fromOption = fromOption4;
    r.fromEither = fromEither4;
    r.fromPredicate = fromPredicate5;
    r.filterOrElse = filterOrElse3;
  }
  return r;
}
var isFunctor, isContravariant, isFunctorWithIndex, isApply, isChain, isBifunctor, isExtend, isFoldable, isFoldableWithIndex, isAlt, isCompactable, isFilterable, isFilterableWithIndex, isProfunctor, isSemigroupoid, isMonadThrow, pipe2;
var init_pipeable = __esm({
  "node_modules/fp-ts/es6/pipeable.js"() {
    init_shim();
    init_Apply();
    init_Chain();
    init_function();
    isFunctor = function(I) {
      return typeof I.map === "function";
    };
    isContravariant = function(I) {
      return typeof I.contramap === "function";
    };
    isFunctorWithIndex = function(I) {
      return typeof I.mapWithIndex === "function";
    };
    isApply = function(I) {
      return typeof I.ap === "function";
    };
    isChain = function(I) {
      return typeof I.chain === "function";
    };
    isBifunctor = function(I) {
      return typeof I.bimap === "function";
    };
    isExtend = function(I) {
      return typeof I.extend === "function";
    };
    isFoldable = function(I) {
      return typeof I.reduce === "function";
    };
    isFoldableWithIndex = function(I) {
      return typeof I.reduceWithIndex === "function";
    };
    isAlt = function(I) {
      return typeof I.alt === "function";
    };
    isCompactable = function(I) {
      return typeof I.compact === "function";
    };
    isFilterable = function(I) {
      return typeof I.filter === "function";
    };
    isFilterableWithIndex = function(I) {
      return typeof I.filterWithIndex === "function";
    };
    isProfunctor = function(I) {
      return typeof I.promap === "function";
    };
    isSemigroupoid = function(I) {
      return typeof I.compose === "function";
    };
    isMonadThrow = function(I) {
      return typeof I.throwError === "function";
    };
    pipe2 = pipe;
  }
});

// node_modules/io-ts-reporters/target/src/utils.js
var require_utils = __commonJS({
  "node_modules/io-ts-reporters/target/src/utils.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.takeUntil = void 0;
    var takeUntil = function(predicate) {
      return function(as) {
        var init4 = [];
        for (var i = 0; i < as.length; i++) {
          init4[i] = as[i];
          if (predicate(as[i])) {
            return init4;
          }
        }
        return init4;
      };
    };
    exports.takeUntil = takeUntil;
  }
});

// node_modules/io-ts-reporters/target/src/index.js
var require_src = __commonJS({
  "node_modules/io-ts-reporters/target/src/index.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reporter = exports.formatValidationErrors = exports.formatValidationError = exports.TYPE_MAX_LEN = void 0;
    var A = (init_Array(), __toCommonJS(Array_exports));
    var E = (init_Either(), __toCommonJS(Either_exports));
    var NEA = (init_NonEmptyArray(), __toCommonJS(NonEmptyArray_exports));
    var O = (init_Option(), __toCommonJS(Option_exports));
    var R = (init_Record(), __toCommonJS(Record_exports));
    var pipeable_1 = (init_pipeable(), __toCommonJS(pipeable_exports));
    var t = (init_es6(), __toCommonJS(es6_exports));
    var utils_1 = require_utils();
    var isUnionType = function(_a) {
      var type2 = _a.type;
      return type2 instanceof t.UnionType;
    };
    var jsToString = function(value) {
      return value === void 0 ? "undefined" : JSON.stringify(value);
    };
    var keyPath = function(ctx) {
      return ctx.map(function(c) {
        return c.key;
      }).filter(Boolean).join(".");
    };
    var getErrorFromCtx = function(validation) {
      return A.last(validation.context);
    };
    var getValidationContext = function(validation) {
      return validation.context;
    };
    exports.TYPE_MAX_LEN = 160;
    var truncateType = function(type2, options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.truncateLongTypes, truncateLongTypes = _a === void 0 ? true : _a;
      if (truncateLongTypes && type2.length > exports.TYPE_MAX_LEN) {
        return type2.slice(0, exports.TYPE_MAX_LEN - 3) + "...";
      }
      return type2;
    };
    var errorMessageSimple = function(expectedType, path, error, options) {
      return [
        "Expecting " + truncateType(expectedType, options),
        path === "" ? "" : "at " + path,
        "but instead got: " + jsToString(error.value),
        error.message ? "(" + error.message + ")" : ""
      ].filter(Boolean).join(" ");
    };
    var errorMessageUnion = function(expectedTypes, path, value, options) {
      return [
        "Expecting one of:\n",
        expectedTypes.map(function(type2) {
          return "    " + truncateType(type2, options);
        }).join("\n"),
        path === "" ? "\n" : "\nat " + path + " ",
        "but instead got: " + jsToString(value)
      ].filter(Boolean).join("");
    };
    var findExpectedType = function(ctx) {
      return pipeable_1.pipe(ctx, A.findIndex(isUnionType), O.chain(function(n) {
        return A.lookup(n + 1, ctx);
      }));
    };
    var formatValidationErrorOfUnion = function(path, errors, options) {
      var expectedTypes = pipeable_1.pipe(errors, A.map(getValidationContext), A.map(findExpectedType), A.compact);
      var value = pipeable_1.pipe(expectedTypes, A.head, O.map(function(v) {
        return v.actual;
      }), O.getOrElse(function() {
        return void 0;
      }));
      var expected = expectedTypes.map(function(_a) {
        var type2 = _a.type;
        return type2.name;
      });
      return expected.length > 0 ? O.some(errorMessageUnion(expected, path, value, options)) : O.none;
    };
    var formatValidationCommonError = function(path, error, options) {
      return pipeable_1.pipe(error, getErrorFromCtx, O.map(function(errorContext) {
        return errorMessageSimple(errorContext.type.name, path, error, options);
      }));
    };
    var groupByKey = NEA.groupBy(function(error) {
      return pipeable_1.pipe(error.context, utils_1.takeUntil(isUnionType), keyPath);
    });
    var format = function(path, errors, options) {
      return NEA.tail(errors).length > 0 ? formatValidationErrorOfUnion(path, errors, options) : formatValidationCommonError(path, NEA.head(errors), options);
    };
    var formatValidationError = function(error, options) {
      return formatValidationCommonError(keyPath(error.context), error, options);
    };
    exports.formatValidationError = formatValidationError;
    var formatValidationErrors = function(errors, options) {
      return pipeable_1.pipe(errors, groupByKey, R.mapWithIndex(function(path, errors2) {
        return format(path, errors2, options);
      }), R.compact, R.toArray, A.map(function(_a) {
        var _key = _a[0], error = _a[1];
        return error;
      }));
    };
    exports.formatValidationErrors = formatValidationErrors;
    var reporter = function(validation, options) {
      return pipeable_1.pipe(validation, E.mapLeft(function(errors) {
        return exports.formatValidationErrors(errors, options);
      }), E.fold(function(errors) {
        return errors;
      }, function() {
        return [];
      }));
    };
    exports.reporter = reporter;
    var prettyReporter = { report: exports.reporter };
    exports.default = prettyReporter;
  }
});

// node_modules/ton/dist/client/api/TonCache.js
var require_TonCache = __commonJS({
  "node_modules/ton/dist/client/api/TonCache.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InMemoryCache = void 0;
    var InMemoryCache = class {
      constructor() {
        this.cache = /* @__PURE__ */ new Map();
        this.set = async (namespace, key, value) => {
          if (value !== null) {
            this.cache.set(namespace + "$$" + key, value);
          } else {
            this.cache.delete(namespace + "$$" + key);
          }
        };
        this.get = async (namespace, key) => {
          let res = this.cache.get(namespace + "$$" + key);
          if (res !== void 0) {
            return res;
          } else {
            return null;
          }
        };
      }
    };
    exports.InMemoryCache = InMemoryCache;
  }
});

// node_modules/dataloader/index.js
var require_dataloader = __commonJS({
  "node_modules/dataloader/index.js"(exports, module) {
    "use strict";
    init_shim();
    var DataLoader = function() {
      function DataLoader2(batchLoadFn, options) {
        if (typeof batchLoadFn !== "function") {
          throw new TypeError("DataLoader must be constructed with a function which accepts " + ("Array<key> and returns Promise<Array<value>>, but got: " + batchLoadFn + "."));
        }
        this._batchLoadFn = batchLoadFn;
        this._maxBatchSize = getValidMaxBatchSize(options);
        this._batchScheduleFn = getValidBatchScheduleFn(options);
        this._cacheKeyFn = getValidCacheKeyFn(options);
        this._cacheMap = getValidCacheMap(options);
        this._batch = null;
        this.name = getValidName(options);
      }
      var _proto = DataLoader2.prototype;
      _proto.load = function load(key) {
        if (key === null || key === void 0) {
          throw new TypeError("The loader.load() function must be called with a value, " + ("but got: " + String(key) + "."));
        }
        var batch = getCurrentBatch(this);
        var cacheMap = this._cacheMap;
        var cacheKey = this._cacheKeyFn(key);
        if (cacheMap) {
          var cachedPromise = cacheMap.get(cacheKey);
          if (cachedPromise) {
            var cacheHits = batch.cacheHits || (batch.cacheHits = []);
            return new Promise(function(resolve) {
              cacheHits.push(function() {
                resolve(cachedPromise);
              });
            });
          }
        }
        batch.keys.push(key);
        var promise = new Promise(function(resolve, reject) {
          batch.callbacks.push({
            resolve,
            reject
          });
        });
        if (cacheMap) {
          cacheMap.set(cacheKey, promise);
        }
        return promise;
      };
      _proto.loadMany = function loadMany(keys3) {
        if (!isArrayLike(keys3)) {
          throw new TypeError("The loader.loadMany() function must be called with Array<key> " + ("but got: " + keys3 + "."));
        }
        var loadPromises = [];
        for (var i = 0; i < keys3.length; i++) {
          loadPromises.push(this.load(keys3[i])["catch"](function(error) {
            return error;
          }));
        }
        return Promise.all(loadPromises);
      };
      _proto.clear = function clear(key) {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          var cacheKey = this._cacheKeyFn(key);
          cacheMap["delete"](cacheKey);
        }
        return this;
      };
      _proto.clearAll = function clearAll() {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          cacheMap.clear();
        }
        return this;
      };
      _proto.prime = function prime(key, value) {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          var cacheKey = this._cacheKeyFn(key);
          if (cacheMap.get(cacheKey) === void 0) {
            var promise;
            if (value instanceof Error) {
              promise = Promise.reject(value);
              promise["catch"](function() {
              });
            } else {
              promise = Promise.resolve(value);
            }
            cacheMap.set(cacheKey, promise);
          }
        }
        return this;
      };
      return DataLoader2;
    }();
    var enqueuePostPromiseJob = typeof import_process.default === "object" && typeof import_process.default.nextTick === "function" ? function(fn) {
      if (!resolvedPromise) {
        resolvedPromise = Promise.resolve();
      }
      resolvedPromise.then(function() {
        import_process.default.nextTick(fn);
      });
    } : typeof setImmediate === "function" ? function(fn) {
      setImmediate(fn);
    } : function(fn) {
      setTimeout(fn);
    };
    var resolvedPromise;
    function getCurrentBatch(loader) {
      var existingBatch = loader._batch;
      if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize) {
        return existingBatch;
      }
      var newBatch = {
        hasDispatched: false,
        keys: [],
        callbacks: []
      };
      loader._batch = newBatch;
      loader._batchScheduleFn(function() {
        dispatchBatch(loader, newBatch);
      });
      return newBatch;
    }
    function dispatchBatch(loader, batch) {
      batch.hasDispatched = true;
      if (batch.keys.length === 0) {
        resolveCacheHits(batch);
        return;
      }
      var batchPromise;
      try {
        batchPromise = loader._batchLoadFn(batch.keys);
      } catch (e) {
        return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function " + ("errored synchronously: " + String(e) + ".")));
      }
      if (!batchPromise || typeof batchPromise.then !== "function") {
        return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise: " + String(batchPromise) + ".")));
      }
      batchPromise.then(function(values) {
        if (!isArrayLike(values)) {
          throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise of an Array: " + String(values) + "."));
        }
        if (values.length !== batch.keys.length) {
          throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys." + ("\n\nKeys:\n" + String(batch.keys)) + ("\n\nValues:\n" + String(values)));
        }
        resolveCacheHits(batch);
        for (var i = 0; i < batch.callbacks.length; i++) {
          var value = values[i];
          if (value instanceof Error) {
            batch.callbacks[i].reject(value);
          } else {
            batch.callbacks[i].resolve(value);
          }
        }
      })["catch"](function(error) {
        failedDispatch(loader, batch, error);
      });
    }
    function failedDispatch(loader, batch, error) {
      resolveCacheHits(batch);
      for (var i = 0; i < batch.keys.length; i++) {
        loader.clear(batch.keys[i]);
        batch.callbacks[i].reject(error);
      }
    }
    function resolveCacheHits(batch) {
      if (batch.cacheHits) {
        for (var i = 0; i < batch.cacheHits.length; i++) {
          batch.cacheHits[i]();
        }
      }
    }
    function getValidMaxBatchSize(options) {
      var shouldBatch = !options || options.batch !== false;
      if (!shouldBatch) {
        return 1;
      }
      var maxBatchSize = options && options.maxBatchSize;
      if (maxBatchSize === void 0) {
        return Infinity;
      }
      if (typeof maxBatchSize !== "number" || maxBatchSize < 1) {
        throw new TypeError("maxBatchSize must be a positive number: " + maxBatchSize);
      }
      return maxBatchSize;
    }
    function getValidBatchScheduleFn(options) {
      var batchScheduleFn = options && options.batchScheduleFn;
      if (batchScheduleFn === void 0) {
        return enqueuePostPromiseJob;
      }
      if (typeof batchScheduleFn !== "function") {
        throw new TypeError("batchScheduleFn must be a function: " + batchScheduleFn);
      }
      return batchScheduleFn;
    }
    function getValidCacheKeyFn(options) {
      var cacheKeyFn = options && options.cacheKeyFn;
      if (cacheKeyFn === void 0) {
        return function(key) {
          return key;
        };
      }
      if (typeof cacheKeyFn !== "function") {
        throw new TypeError("cacheKeyFn must be a function: " + cacheKeyFn);
      }
      return cacheKeyFn;
    }
    function getValidCacheMap(options) {
      var shouldCache = !options || options.cache !== false;
      if (!shouldCache) {
        return null;
      }
      var cacheMap = options && options.cacheMap;
      if (cacheMap === void 0) {
        return /* @__PURE__ */ new Map();
      }
      if (cacheMap !== null) {
        var cacheFunctions = ["get", "set", "delete", "clear"];
        var missingFunctions = cacheFunctions.filter(function(fnName) {
          return cacheMap && typeof cacheMap[fnName] !== "function";
        });
        if (missingFunctions.length !== 0) {
          throw new TypeError("Custom cacheMap missing methods: " + missingFunctions.join(", "));
        }
      }
      return cacheMap;
    }
    function getValidName(options) {
      if (options && options.name) {
        return options.name;
      }
      return null;
    }
    function isArrayLike(x) {
      return typeof x === "object" && x !== null && typeof x.length === "number" && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));
    }
    module.exports = DataLoader;
  }
});

// node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/axios/lib/helpers/bind.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = function bind8(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/axios/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/axios/lib/utils.js"(exports, module) {
    "use strict";
    init_shim();
    var bind8 = require_bind();
    var toString = Object.prototype.toString;
    function isArray(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return toString.call(val) === "[object FormData]";
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isURLSearchParams(val) {
      return toString.call(val) === "[object URLSearchParams]";
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend8(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind8(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend: extend8,
      trim,
      stripBOM
    };
  }
});

// node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module.exports = InterceptorManager;
  }
});

// node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    module.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "node_modules/axios/lib/core/enhanceError.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      };
      return error;
    };
  }
});

// node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "node_modules/axios/lib/core/createError.js"(exports, module) {
    "use strict";
    init_shim();
    var enhanceError = require_enhanceError();
    module.exports = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };
  }
});

// node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/axios/lib/core/settle.js"(exports, module) {
    "use strict";
    init_shim();
    var createError = require_createError();
    module.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          "Request failed with status code " + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };
  }
});

// node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/axios/lib/helpers/cookies.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    module.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            var match5 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match5 ? decodeURIComponent(match5[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }()
    );
  }
});

// node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
    "use strict";
    init_shim();
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    module.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }()
    );
  }
});

// node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/axios/lib/cancel/Cancel.js"(exports, module) {
    "use strict";
    init_shim();
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module.exports = Cancel;
  }
});

// node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/axios/lib/adapters/xhr.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    module.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError("Request aborted", config, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError("Network Error", config, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config.transitional || defaults.transitional;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(
            timeoutErrorMessage,
            config,
            transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
            request
          ));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/axios/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/axios/lib/defaults.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    var normalizeHeaderName = require_normalizeHeaderName();
    var enhanceError = require_enhanceError();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof import_process.default !== "undefined" && Object.prototype.toString.call(import_process.default) === "[object process]") {
        adapter = require_xhr();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module.exports = defaults;
  }
});

// node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/axios/lib/core/transformData.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    var defaults = require_defaults();
    module.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new Cancel("canceled");
      }
    }
    module.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
      utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    module.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    };
  }
});

// node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "node_modules/axios/lib/env/data.js"(exports, module) {
    init_shim();
    module.exports = {
      "version": "0.25.0"
    };
  }
});

// node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/axios/lib/helpers/validator.js"(exports, module) {
    "use strict";
    init_shim();
    var VERSION = require_data().version;
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type2, i) {
      validators[type2] = function validator(thing) {
        return typeof thing === type2 || "a" + (i < 1 ? "n " : " ") + type2;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed" + (version ? " in " + version : "")));
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys3 = Object.keys(options);
      var i = keys3.length;
      while (i-- > 0) {
        var opt = keys3[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/axios/lib/core/Axios.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      if (!config.url) {
        throw new Error("Provided config url is not valid");
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain8 = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain8, requestInterceptorChain);
        chain8 = chain8.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain8.length) {
          promise = promise.then(chain8.shift(), chain8.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      if (!config.url) {
        throw new Error("Provided config url is not valid");
      }
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data
        }));
      };
    });
    module.exports = Axios;
  }
});

// node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
    "use strict";
    init_shim();
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i;
        var l = token._listeners.length;
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module.exports = CancelToken;
  }
});

// node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/axios/lib/helpers/spread.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    module.exports = function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    };
  }
});

// node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/axios/lib/axios.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    var bind8 = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind8(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults);
    axios.Axios = Axios;
    axios.Cancel = require_Cancel();
    axios.CancelToken = require_CancelToken();
    axios.isCancel = require_isCancel();
    axios.VERSION = require_data().version;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = require_spread();
    axios.isAxiosError = require_isAxiosError();
    module.exports = axios;
    module.exports.default = axios;
  }
});

// node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/axios/index.js"(exports, module) {
    init_shim();
    module.exports = require_axios();
  }
});

// node_modules/ton/package.json
var require_package = __commonJS({
  "node_modules/ton/package.json"(exports, module) {
    module.exports = {
      name: "ton",
      version: "13.4.1",
      repository: "https://github.com/ton-core/ton.git",
      author: "Whales Corp. <developers@whalescorp.com>",
      license: "MIT",
      main: "dist/index.js",
      files: [
        "dist"
      ],
      scripts: {
        docs: "rm -fr docs && typedoc src/index.ts",
        build: "rm -fr dist && tsc --declaration",
        test: "jest --verbose --runInBand",
        release: "yarn build && yarn release-it --npm.yarn1"
      },
      devDependencies: {
        "@release-it/keep-a-changelog": "^3.1.0",
        "@types/jest": "^27.0.1",
        "@types/node": "^16.7.10",
        buffer: "^6.0.3",
        expect: "^27.1.0",
        jest: "^27.1.0",
        "jest-mock": "^27.1.0",
        karma: "^6.3.4",
        "karma-chrome-launcher": "^3.1.0",
        "karma-jasmine": "^4.0.1",
        "karma-typescript": "^5.5.2",
        "karma-webpack": "^5.0.0",
        prando: "^6.0.1",
        "release-it": "^15.5.1",
        "ton-core": "^0.48.0",
        "ton-crypto": "3.2.0",
        "ton-emulator": "^2.1.1",
        "ts-jest": "^27.0.5",
        "ts-loader": "^9.2.5",
        "ts-node": "^10.7.0",
        typedoc: "^0.23.24",
        typescript: "^4.4.2",
        webpack: "^5.51.2"
      },
      dependencies: {
        axios: "^0.25.0",
        dataloader: "^2.0.0",
        "fp-ts": "^2.11.1",
        "io-ts": "^2.2.16",
        "io-ts-reporters": "^2.0.0",
        "symbol.inspect": "1.0.1",
        teslabot: "^1.3.0"
      },
      peerDependencies: {
        "ton-core": ">=0.48.0",
        "ton-crypto": ">=3.2.0"
      },
      publishConfig: {
        access: "public",
        registry: "https://registry.npmjs.org/"
      },
      "release-it": {
        github: {
          release: true
        },
        plugins: {
          "@release-it/keep-a-changelog": {
            filename: "CHANGELOG.md"
          }
        }
      },
      packageManager: "yarn@3.4.1"
    };
  }
});

// node_modules/ton/dist/client/api/HttpApi.js
var require_HttpApi = __commonJS({
  "node_modules/ton/dist/client/api/HttpApi.js"(exports) {
    "use strict";
    init_shim();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpApi = void 0;
    var t = __importStar((init_es6(), __toCommonJS(es6_exports)));
    var Either_1 = require_Either();
    var io_ts_reporters_1 = __importDefault(require_src());
    var TonCache_1 = require_TonCache();
    var dataloader_1 = __importDefault(require_dataloader());
    var axios_1 = __importDefault(require_axios2());
    var version = require_package().version;
    var blockIdExt = t.type({
      "@type": t.literal("ton.blockIdExt"),
      workchain: t.number,
      shard: t.string,
      seqno: t.number,
      root_hash: t.string,
      file_hash: t.string
    });
    var addressInformation = t.type({
      balance: t.union([t.number, t.string]),
      state: t.union([t.literal("active"), t.literal("uninitialized"), t.literal("frozen")]),
      data: t.string,
      code: t.string,
      last_transaction_id: t.type({
        "@type": t.literal("internal.transactionId"),
        lt: t.string,
        hash: t.string
      }),
      block_id: blockIdExt,
      sync_utime: t.number
    });
    var bocResponse = t.type({
      "@type": t.literal("ok")
    });
    var feeResponse = t.type({
      "@type": t.literal("query.fees"),
      source_fees: t.type({
        "@type": t.literal("fees"),
        in_fwd_fee: t.number,
        storage_fee: t.number,
        gas_fee: t.number,
        fwd_fee: t.number
      })
    });
    var callGetMethod = t.type({
      gas_used: t.number,
      exit_code: t.number,
      stack: t.array(t.unknown)
    });
    var messageData = t.union([
      t.type({
        "@type": t.literal("msg.dataRaw"),
        "body": t.string
      }),
      t.type({
        "@type": t.literal("msg.dataText"),
        "text": t.string
      }),
      t.type({
        "@type": t.literal("msg.dataDecryptedText"),
        "text": t.string
      }),
      t.type({
        "@type": t.literal("msg.dataEncryptedText"),
        "text": t.string
      })
    ]);
    var message = t.type({
      source: t.string,
      destination: t.string,
      value: t.string,
      fwd_fee: t.string,
      ihr_fee: t.string,
      created_lt: t.string,
      body_hash: t.string,
      msg_data: messageData
    });
    var transaction = t.type({
      data: t.string,
      utime: t.number,
      transaction_id: t.type({
        lt: t.string,
        hash: t.string
      }),
      fee: t.string,
      storage_fee: t.string,
      other_fee: t.string,
      in_msg: t.union([t.undefined, message]),
      out_msgs: t.array(message)
    });
    var getTransactions = t.array(transaction);
    var getMasterchain = t.type({
      state_root_hash: t.string,
      last: blockIdExt,
      init: blockIdExt
    });
    var getShards = t.type({
      shards: t.array(blockIdExt)
    });
    var blockShortTxt = t.type({
      "@type": t.literal("blocks.shortTxId"),
      mode: t.number,
      account: t.string,
      lt: t.string,
      hash: t.string
    });
    var getBlockTransactions = t.type({
      id: blockIdExt,
      req_count: t.number,
      incomplete: t.boolean,
      transactions: t.array(blockShortTxt)
    });
    var TypedCache = class {
      constructor(namespace, cache, codec, keyEncoder) {
        this.namespace = namespace;
        this.cache = cache;
        this.codec = codec;
        this.keyEncoder = keyEncoder;
      }
      async get(key) {
        let ex = await this.cache.get(this.namespace, this.keyEncoder(key));
        if (ex) {
          let decoded = this.codec.decode(JSON.parse(ex));
          if ((0, Either_1.isRight)(decoded)) {
            return decoded.right;
          }
        }
        return null;
      }
      async set(key, value) {
        if (value !== null) {
          await this.cache.set(this.namespace, this.keyEncoder(key), JSON.stringify(value));
        } else {
          await this.cache.set(this.namespace, this.keyEncoder(key), null);
        }
      }
    };
    var HttpApi = class {
      constructor(endpoint, parameters) {
        this.endpoint = endpoint;
        this.cache = new TonCache_1.InMemoryCache();
        this.parameters = {
          timeout: (parameters == null ? void 0 : parameters.timeout) || 3e4,
          apiKey: parameters == null ? void 0 : parameters.apiKey
        };
        this.shardCache = new TypedCache("ton-shard", this.cache, t.array(blockIdExt), (src) => src + "");
        this.shardLoader = new dataloader_1.default(async (src) => {
          return await Promise.all(src.map(async (v) => {
            const cached = await this.shardCache.get(v);
            if (cached) {
              return cached;
            }
            let loaded = (await this.doCall("shards", { seqno: v }, getShards)).shards;
            await this.shardCache.set(v, loaded);
            return loaded;
          }));
        });
        this.shardTransactionsCache = new TypedCache("ton-shard-tx", this.cache, getBlockTransactions, (src) => src.workchain + ":" + src.shard + ":" + src.seqno);
        this.shardTransactionsLoader = new dataloader_1.default(async (src) => {
          return await Promise.all(src.map(async (v) => {
            const cached = await this.shardTransactionsCache.get(v);
            if (cached) {
              return cached;
            }
            let loaded = await this.doCall("getBlockTransactions", { workchain: v.workchain, seqno: v.seqno, shard: v.shard }, getBlockTransactions);
            await this.shardTransactionsCache.set(v, loaded);
            return loaded;
          }));
        }, { cacheKeyFn: (src) => src.workchain + ":" + src.shard + ":" + src.seqno });
      }
      getAddressInformation(address) {
        return this.doCall("getAddressInformation", { address: address.toString() }, addressInformation);
      }
      async getTransactions(address, opts) {
        const inclusive = opts.inclusive;
        delete opts.inclusive;
        let hash = void 0;
        if (opts.hash) {
          hash = import_buffer.Buffer.from(opts.hash, "base64").toString("hex");
        }
        let limit = opts.limit;
        if (opts.hash && opts.lt && inclusive !== true) {
          limit++;
        }
        let res = await this.doCall("getTransactions", { address: address.toString(), ...opts, limit, hash }, getTransactions);
        if (res.length > limit) {
          res = res.slice(0, limit);
        }
        if (opts.hash && opts.lt && inclusive !== true) {
          res.shift();
          return res;
        } else {
          return res;
        }
      }
      async getMasterchainInfo() {
        return await this.doCall("getMasterchainInfo", {}, getMasterchain);
      }
      async getShards(seqno) {
        return await this.shardLoader.load(seqno);
      }
      async getBlockTransactions(workchain, seqno, shard) {
        return await this.shardTransactionsLoader.load({ workchain, seqno, shard });
      }
      async getTransaction(address, lt, hash) {
        let convHash = import_buffer.Buffer.from(hash, "base64").toString("hex");
        let res = await this.doCall("getTransactions", { address: address.toString(), lt, hash: convHash, limit: 1 }, getTransactions);
        let ex = res.find((v) => v.transaction_id.lt === lt && v.transaction_id.hash === hash);
        if (ex) {
          return ex;
        } else {
          return null;
        }
      }
      async callGetMethod(address, method, stack) {
        return await this.doCall("runGetMethod", { address: address.toString(), method, stack: serializeStack(stack) }, callGetMethod);
      }
      async sendBoc(body) {
        await this.doCall("sendBoc", { boc: body.toString("base64") }, bocResponse);
      }
      async estimateFee(address, args) {
        return await this.doCall("estimateFee", {
          address: address.toString(),
          body: args.body.toBoc().toString("base64"),
          "init_data": args.initData ? args.initData.toBoc().toString("base64") : "",
          "init_code": args.initCode ? args.initCode.toBoc().toString("base64") : "",
          ignore_chksig: args.ignoreSignature
        }, feeResponse);
      }
      async doCall(method, body, codec) {
        let headers = {
          "Content-Type": "application/json",
          "X-Ton-Client-Version": version
        };
        if (this.parameters.apiKey) {
          headers["X-API-Key"] = this.parameters.apiKey;
        }
        let res = await axios_1.default.post(this.endpoint, JSON.stringify({
          id: "1",
          jsonrpc: "2.0",
          method,
          params: body
        }), {
          headers,
          timeout: this.parameters.timeout
        });
        if (res.status !== 200 || !res.data.ok) {
          throw Error("Received error: " + JSON.stringify(res.data));
        }
        let decoded = codec.decode(res.data.result);
        if ((0, Either_1.isRight)(decoded)) {
          return decoded.right;
        } else {
          throw Error("Malformed response: " + io_ts_reporters_1.default.report(decoded).join(", "));
        }
      }
    };
    exports.HttpApi = HttpApi;
    function serializeStack(src) {
      let stack = [];
      for (let s of src) {
        if (s.type === "int") {
          stack.push(["num", s.value.toString()]);
        } else if (s.type === "cell") {
          stack.push(["tvm.Cell", s.cell.toBoc().toString("base64")]);
        } else if (s.type === "slice") {
          stack.push(["tvm.Slice", s.cell.toBoc().toString("base64")]);
        } else if (s.type === "builder") {
          stack.push(["tvm.Builder", s.cell.toBoc().toString("base64")]);
        } else {
          throw Error("Unsupported stack item type: " + s.type);
        }
      }
      return stack;
    }
  }
});

// node_modules/ton/dist/client/TonClient.js
var require_TonClient = __commonJS({
  "node_modules/ton/dist/client/TonClient.js"(exports) {
    "use strict";
    init_shim();
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _TonClient_api;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TonClient = void 0;
    var HttpApi_1 = require_HttpApi();
    var ton_core_1 = require_dist2();
    var TonClient = class {
      constructor(parameters) {
        _TonClient_api.set(this, void 0);
        this.parameters = {
          endpoint: parameters.endpoint
        };
        __classPrivateFieldSet(this, _TonClient_api, new HttpApi_1.HttpApi(this.parameters.endpoint, {
          timeout: parameters.timeout,
          apiKey: parameters.apiKey,
          adapter: parameters.httpAdapter
        }), "f");
      }
      /**
       * Get Address Balance
       * @param address address for balance check
       * @returns balance
       */
      async getBalance(address) {
        return (await this.getContractState(address)).balance;
      }
      /**
       * Invoke get method
       * @param address contract address
       * @param name name of method
       * @param params optional parameters
       * @returns stack and gas_used field
       */
      async runMethod(address, name, stack = []) {
        let res = await __classPrivateFieldGet(this, _TonClient_api, "f").callGetMethod(address, name, stack);
        if (res.exit_code !== 0) {
          throw Error("Unable to execute get method. Got exit_code: " + res.exit_code);
        }
        return { gas_used: res.gas_used, stack: parseStack(res.stack) };
      }
      /**
       * Invoke get method
       * @param address contract address
       * @param name name of method
       * @param params optional parameters
       * @returns stack and gas_used field
       * @deprecated use runMethod instead
       */
      async callGetMethod(address, name, stack = []) {
        return this.runMethod(address, name, stack);
      }
      /**
       * Invoke get method that returns error code instead of throwing error
       * @param address contract address
       * @param name name of method
       * @param params optional parameters
       * @returns stack and gas_used field
      */
      async runMethodWithError(address, name, params = []) {
        let res = await __classPrivateFieldGet(this, _TonClient_api, "f").callGetMethod(address, name, params);
        return { gas_used: res.gas_used, stack: parseStack(res.stack), exit_code: res.exit_code };
      }
      /**
       * Invoke get method that returns error code instead of throwing error
       * @param address contract address
       * @param name name of method
       * @param params optional parameters
       * @returns stack and gas_used field
       * @deprecated use runMethodWithError instead
       */
      async callGetMethodWithError(address, name, stack = []) {
        return this.runMethodWithError(address, name, stack);
      }
      /**
       * Get transactions
       * @param address address
       */
      async getTransactions(address, opts) {
        let tx = await __classPrivateFieldGet(this, _TonClient_api, "f").getTransactions(address, opts);
        let res = [];
        for (let r of tx) {
          res.push((0, ton_core_1.loadTransaction)(ton_core_1.Cell.fromBoc(import_buffer.Buffer.from(r.data, "base64"))[0].beginParse()));
        }
        return res;
      }
      /**
       * Get transaction by it's id
       * @param address address
       * @param lt logical time
       * @param hash transaction hash
       * @returns transaction or null if not exist
       */
      async getTransaction(address, lt, hash) {
        let res = await __classPrivateFieldGet(this, _TonClient_api, "f").getTransaction(address, lt, hash);
        if (res) {
          return (0, ton_core_1.loadTransaction)(ton_core_1.Cell.fromBoc(import_buffer.Buffer.from(res.data, "base64"))[0].beginParse());
        } else {
          return null;
        }
      }
      /**
       * Fetch latest masterchain info
       * @returns masterchain info
       */
      async getMasterchainInfo() {
        let r = await __classPrivateFieldGet(this, _TonClient_api, "f").getMasterchainInfo();
        return {
          workchain: r.init.workchain,
          shard: r.last.shard,
          initSeqno: r.init.seqno,
          latestSeqno: r.last.seqno
        };
      }
      /**
       * Fetch latest workchain shards
       * @param seqno masterchain seqno
       */
      async getWorkchainShards(seqno) {
        let r = await __classPrivateFieldGet(this, _TonClient_api, "f").getShards(seqno);
        return r.map((m) => ({
          workchain: m.workchain,
          shard: m.shard,
          seqno: m.seqno
        }));
      }
      /**
       * Fetch transactions inf shards
       * @param workchain
       * @param seqno
       * @param shard
       */
      async getShardTransactions(workchain, seqno, shard) {
        let tx = await __classPrivateFieldGet(this, _TonClient_api, "f").getBlockTransactions(workchain, seqno, shard);
        if (tx.incomplete) {
          throw Error("Unsupported");
        }
        return tx.transactions.map((v) => ({
          account: ton_core_1.Address.parseRaw(v.account),
          lt: v.lt,
          hash: v.hash
        }));
      }
      /**
       * Send message to a network
       * @param src source message
       */
      async sendMessage(src) {
        const boc = (0, ton_core_1.beginCell)().store((0, ton_core_1.storeMessage)(src)).endCell().toBoc();
        await __classPrivateFieldGet(this, _TonClient_api, "f").sendBoc(boc);
      }
      /**
       * Send file to a network
       * @param src source file
       */
      async sendFile(src) {
        await __classPrivateFieldGet(this, _TonClient_api, "f").sendBoc(src);
      }
      /**
       * Estimate fees for external message
       * @param address target address
       * @returns
       */
      async estimateExternalMessageFee(address, args) {
        return await __classPrivateFieldGet(this, _TonClient_api, "f").estimateFee(address, { body: args.body, initCode: args.initCode, initData: args.initData, ignoreSignature: args.ignoreSignature });
      }
      /**
       * Send external message to contract
       * @param contract contract to send message
       * @param src message body
       */
      async sendExternalMessage(contract, src) {
        if (await this.isContractDeployed(contract.address) || !contract.init) {
          const message = (0, ton_core_1.external)({
            to: contract.address,
            body: src
          });
          await this.sendMessage(message);
        } else {
          const message = (0, ton_core_1.external)({
            to: contract.address,
            init: { code: contract.init.code, data: contract.init.data },
            body: src
          });
          await this.sendMessage(message);
        }
      }
      /**
       * Check if contract is deployed
       * @param address addres to check
       * @returns true if contract is in active state
       */
      async isContractDeployed(address) {
        return (await this.getContractState(address)).state === "active";
      }
      /**
       * Resolves contract state
       * @param address contract address
       */
      async getContractState(address) {
        let info = await __classPrivateFieldGet(this, _TonClient_api, "f").getAddressInformation(address);
        let balance = BigInt(info.balance);
        let state = info.state;
        return {
          balance,
          state,
          code: info.code !== "" ? import_buffer.Buffer.from(info.code, "base64") : null,
          data: info.data !== "" ? import_buffer.Buffer.from(info.data, "base64") : null,
          lastTransaction: info.last_transaction_id.lt !== "0" ? {
            lt: info.last_transaction_id.lt,
            hash: info.last_transaction_id.hash
          } : null,
          blockId: {
            workchain: info.block_id.workchain,
            shard: info.block_id.shard,
            seqno: info.block_id.seqno
          },
          timestampt: info.sync_utime
        };
      }
      /**
       * Open contract
       * @param src source contract
       * @returns contract
       */
      open(src) {
        return (0, ton_core_1.openContract)(src, (args) => createProvider(this, args.address, args.init));
      }
      /**
       * Create a provider
       * @param address address
       * @param init optional init
       * @returns provider
       */
      provider(address, init4) {
        return createProvider(this, address, init4);
      }
    };
    exports.TonClient = TonClient;
    _TonClient_api = /* @__PURE__ */ new WeakMap();
    function parseStack(src) {
      let stack = [];
      for (let s of src) {
        if (s[0] === "num") {
          let val = s[1];
          if (val.startsWith("-")) {
            stack.push({ type: "int", value: -BigInt(val.slice(1)) });
          } else {
            stack.push({ type: "int", value: BigInt(val) });
          }
        } else if (s[0] === "null") {
          stack.push({ type: "null" });
        } else if (s[0] === "cell") {
          stack.push({ type: "cell", cell: ton_core_1.Cell.fromBoc(import_buffer.Buffer.from(s[1].bytes, "base64"))[0] });
        } else if (s[0] === "slice") {
          stack.push({ type: "slice", cell: ton_core_1.Cell.fromBoc(import_buffer.Buffer.from(s[1].bytes, "base64"))[0] });
        } else if (s[0] === "builder") {
          stack.push({ type: "builder", cell: ton_core_1.Cell.fromBoc(import_buffer.Buffer.from(s[1].bytes, "base64"))[0] });
        } else {
          throw Error("Unsupported stack item type: " + s[0]);
        }
      }
      return new ton_core_1.TupleReader(stack);
    }
    function createProvider(client, address, init4) {
      return {
        async getState() {
          let state = await client.getContractState(address);
          let balance = state.balance;
          let last6 = state.lastTransaction ? { lt: BigInt(state.lastTransaction.lt), hash: import_buffer.Buffer.from(state.lastTransaction.hash, "base64") } : null;
          let storage;
          if (state.state === "active") {
            storage = {
              type: "active",
              code: state.code ? state.code : null,
              data: state.data ? state.data : null
            };
          } else if (state.state === "uninitialized") {
            storage = {
              type: "uninit"
            };
          } else if (state.state === "frozen") {
            storage = {
              type: "frozen",
              stateHash: import_buffer.Buffer.alloc(0)
            };
          } else {
            throw Error("Unsupported state");
          }
          return {
            balance,
            last: last6,
            state: storage
          };
        },
        async get(name, args) {
          let method = await client.callGetMethod(address, name, args);
          return { stack: method.stack };
        },
        async external(message) {
          let neededInit = null;
          if (init4 && !await client.isContractDeployed(address)) {
            neededInit = init4;
          }
          const ext = (0, ton_core_1.external)({
            to: address,
            init: neededInit ? { code: neededInit.code, data: neededInit.data } : null,
            body: message
          });
          let boc = (0, ton_core_1.beginCell)().store((0, ton_core_1.storeMessage)(ext)).endCell().toBoc();
          await client.sendFile(boc);
        },
        async internal(via, message) {
          let neededInit = null;
          if (init4 && !await client.isContractDeployed(address)) {
            neededInit = init4;
          }
          let bounce = true;
          if (message.bounce !== null && message.bounce !== void 0) {
            bounce = message.bounce;
          }
          let value;
          if (typeof message.value === "string") {
            value = (0, ton_core_1.toNano)(message.value);
          } else {
            value = message.value;
          }
          let body = null;
          if (typeof message.body === "string") {
            body = (0, ton_core_1.comment)(message.body);
          } else if (message.body) {
            body = message.body;
          }
          await via.send({
            to: address,
            value,
            bounce,
            sendMode: message.sendMode,
            init: neededInit,
            body
          });
        }
      };
    }
  }
});

// node_modules/ton/dist/utils/toUrlSafe.js
var require_toUrlSafe = __commonJS({
  "node_modules/ton/dist/utils/toUrlSafe.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUrlSafe = void 0;
    function toUrlSafe(src) {
      while (src.indexOf("/") >= 0) {
        src = src.replace("/", "_");
      }
      while (src.indexOf("+") >= 0) {
        src = src.replace("+", "-");
      }
      while (src.indexOf("=") >= 0) {
        src = src.replace("=", "");
      }
      return src;
    }
    exports.toUrlSafe = toUrlSafe;
  }
});

// node_modules/ton/dist/client/TonClient4.js
var require_TonClient4 = __commonJS({
  "node_modules/ton/dist/client/TonClient4.js"(exports) {
    "use strict";
    init_shim();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _TonClient4_endpoint;
    var _TonClient4_timeout;
    var _TonClient4_adapter;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TonClient4 = void 0;
    var axios_1 = __importDefault(require_axios2());
    var t = __importStar((init_es6(), __toCommonJS(es6_exports)));
    var ton_core_1 = require_dist2();
    var toUrlSafe_1 = require_toUrlSafe();
    var TonClient4 = class {
      constructor(args) {
        _TonClient4_endpoint.set(this, void 0);
        _TonClient4_timeout.set(this, void 0);
        _TonClient4_adapter.set(this, void 0);
        __classPrivateFieldSet(this, _TonClient4_endpoint, args.endpoint, "f");
        __classPrivateFieldSet(this, _TonClient4_timeout, args.timeout || 5e3, "f");
        __classPrivateFieldSet(this, _TonClient4_adapter, args.httpAdapter, "f");
      }
      /**
       * Get Last Block
       * @returns last block info
       */
      async getLastBlock() {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/latest", { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!lastBlockCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        return res.data;
      }
      /**
       * Get block info
       * @param seqno block sequence number
       * @returns block info
       */
      async getBlock(seqno) {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!blockCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        if (!res.data.exist) {
          throw Error("Block is out of scope");
        }
        return res.data.block;
      }
      /**
       * Get block info by unix timestamp
       * @param ts unix timestamp
       * @returns block info
       */
      async getBlockByUtime(ts) {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/utime/" + ts, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!blockCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        if (!res.data.exist) {
          throw Error("Block is out of scope");
        }
        return res.data.block;
      }
      /**
       * Get block info by unix timestamp
       * @param seqno block sequence number
       * @param address account address
       * @returns account info
       */
      async getAccount(seqno, address) {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }), { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!accountCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        return res.data;
      }
      /**
       * Get account lite info (without code and data)
       * @param seqno block sequence number
       * @param address account address
       * @returns account lite info
       */
      async getAccountLite(seqno, address) {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }) + "/lite", { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!accountLiteCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        return res.data;
      }
      /**
       * Check if contract is deployed
       * @param address addres to check
       * @returns true if contract is in active state
       */
      async isContractDeployed(seqno, address) {
        let account = await this.getAccountLite(seqno, address);
        return account.account.state.type === "active";
      }
      /**
       * Check if account was updated since
       * @param seqno block sequence number
       * @param address account address
       * @param lt account last transaction lt
       * @returns account change info
       */
      async isAccountChanged(seqno, address, lt) {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }) + "/changed/" + lt.toString(10), { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!changedCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        return res.data;
      }
      /**
       * Load one unparsed account transaction
       * @param seqno block sequence number
       * @param address account address
       * @param lt account last transaction lt
       * @returns one unparsed transaction
       */
      async getTransaction(seqno, address, lt) {
        const urladdr = address.toString({ urlSafe: true });
        const urlpath = `/block/${seqno}/${urladdr}/tx/${lt.toString(10)}`;
        const res = await axios_1.default.get(new URL(urlpath, __classPrivateFieldGet(this, _TonClient4_endpoint, "f")).href, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!transactionCodec.is(res.data))
          throw Error("Mailformed response");
        const txcell = ton_core_1.Cell.fromBoc(import_buffer.Buffer.from(res.data.boc, "base64"))[0];
        return { tx: (0, ton_core_1.loadTransaction)(txcell.beginParse()), ...res.data };
      }
      /**
       * Load unparsed account transactions
       * @param address address
       * @param lt last transaction lt
       * @param hash last transaction hash
       * @returns unparsed transactions
       */
      async getAccountTransactions(address, lt, hash) {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/account/" + address.toString({ urlSafe: true }) + "/tx/" + lt.toString(10) + "/" + (0, toUrlSafe_1.toUrlSafe)(hash.toString("base64")), { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!transactionsCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        let data = res.data;
        let tx = [];
        let cells = ton_core_1.Cell.fromBoc(import_buffer.Buffer.from(data.boc, "base64"));
        for (let i = 0; i < data.blocks.length; i++) {
          tx.push({
            block: data.blocks[i],
            tx: (0, ton_core_1.loadTransaction)(cells[i].beginParse())
          });
        }
        return tx;
      }
      /**
       * Get network config
       * @param seqno block sequence number
       * @param ids optional config ids
       * @returns network config
       */
      async getConfig(seqno, ids) {
        let tail5 = "";
        if (ids && ids.length > 0) {
          tail5 = "/" + [...ids].sort().join(",");
        }
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/config" + tail5, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!configCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        return res.data;
      }
      /**
       * Execute run method
       * @param seqno block sequence number
       * @param address account address
       * @param name method name
       * @param args method arguments
       * @returns method result
       */
      async runMethod(seqno, address, name, args) {
        let tail5 = args && args.length > 0 ? "/" + (0, toUrlSafe_1.toUrlSafe)((0, ton_core_1.serializeTuple)(args).toBoc({ idx: false, crc32: false }).toString("base64")) : "";
        let url = __classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }) + "/run/" + name + tail5;
        let res = await axios_1.default.get(url, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!runMethodCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        let resultTuple = res.data.resultRaw ? (0, ton_core_1.parseTuple)(ton_core_1.Cell.fromBoc(import_buffer.Buffer.from(res.data.resultRaw, "base64"))[0]) : [];
        return {
          exitCode: res.data.exitCode,
          result: resultTuple,
          resultRaw: res.data.resultRaw,
          block: res.data.block,
          shardBlock: res.data.shardBlock,
          reader: new ton_core_1.TupleReader(resultTuple)
        };
      }
      /**
       * Send external message
       * @param message message boc
       * @returns message status
       */
      async sendMessage(message) {
        let res = await axios_1.default.post(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/send", { boc: message.toString("base64") }, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!sendCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        return { status: res.data.status };
      }
      /**
       * Open smart contract
       * @param contract contract
       * @returns opened contract
       */
      open(contract) {
        return (0, ton_core_1.openContract)(contract, (args) => createProvider(this, null, args.address, args.init));
      }
      /**
       * Open smart contract
       * @param block block number
       * @param contract contract
       * @returns opened contract
       */
      openAt(block, contract) {
        return (0, ton_core_1.openContract)(contract, (args) => createProvider(this, block, args.address, args.init));
      }
      /**
       * Create provider
       * @param address address
       * @param init optional init data
       * @returns provider
       */
      provider(address, init4) {
        return createProvider(this, null, address, init4 ? init4 : null);
      }
      /**
       * Create provider at specified block number
       * @param block block number
       * @param address address
       * @param init optional init data
       * @returns provider
       */
      providerAt(block, address, init4) {
        return createProvider(this, block, address, init4 ? init4 : null);
      }
    };
    exports.TonClient4 = TonClient4;
    _TonClient4_endpoint = /* @__PURE__ */ new WeakMap(), _TonClient4_timeout = /* @__PURE__ */ new WeakMap(), _TonClient4_adapter = /* @__PURE__ */ new WeakMap();
    function createProvider(client, block, address, init4) {
      return {
        async getState() {
          let sq = block;
          if (sq === null) {
            let res = await client.getLastBlock();
            sq = res.last.seqno;
          }
          let state = await client.getAccount(sq, address);
          let last6 = state.account.last ? { lt: BigInt(state.account.last.lt), hash: import_buffer.Buffer.from(state.account.last.hash, "base64") } : null;
          let storage;
          if (state.account.state.type === "active") {
            storage = {
              type: "active",
              code: state.account.state.code ? import_buffer.Buffer.from(state.account.state.code, "base64") : null,
              data: state.account.state.data ? import_buffer.Buffer.from(state.account.state.data, "base64") : null
            };
          } else if (state.account.state.type === "uninit") {
            storage = {
              type: "uninit"
            };
          } else if (state.account.state.type === "frozen") {
            storage = {
              type: "frozen",
              stateHash: import_buffer.Buffer.from(state.account.state.stateHash, "base64")
            };
          } else {
            throw Error("Unsupported state");
          }
          return {
            balance: BigInt(state.account.balance.coins),
            last: last6,
            state: storage
          };
        },
        async get(name, args) {
          let sq = block;
          if (sq === null) {
            let res = await client.getLastBlock();
            sq = res.last.seqno;
          }
          let method = await client.runMethod(sq, address, name, args);
          if (method.exitCode !== 0 && method.exitCode !== 1) {
            throw Error("Exit code: " + method.exitCode);
          }
          return {
            stack: new ton_core_1.TupleReader(method.result)
          };
        },
        async external(message) {
          let last6 = await client.getLastBlock();
          let neededInit = null;
          if (init4 && (await client.getAccountLite(last6.last.seqno, address)).account.state.type !== "active") {
            neededInit = init4;
          }
          const ext = (0, ton_core_1.external)({
            to: address,
            init: neededInit ? { code: neededInit.code, data: neededInit.data } : null,
            body: message
          });
          let pkg = (0, ton_core_1.beginCell)().store((0, ton_core_1.storeMessage)(ext)).endCell().toBoc();
          await client.sendMessage(pkg);
        },
        async internal(via, message) {
          let last6 = await client.getLastBlock();
          let neededInit = null;
          if (init4 && (await client.getAccountLite(last6.last.seqno, address)).account.state.type !== "active") {
            neededInit = init4;
          }
          let bounce = true;
          if (message.bounce !== null && message.bounce !== void 0) {
            bounce = message.bounce;
          }
          let value;
          if (typeof message.value === "string") {
            value = (0, ton_core_1.toNano)(message.value);
          } else {
            value = message.value;
          }
          let body = null;
          if (typeof message.body === "string") {
            body = (0, ton_core_1.comment)(message.body);
          } else if (message.body) {
            body = message.body;
          }
          await via.send({
            to: address,
            value,
            bounce,
            sendMode: message.sendMode,
            init: neededInit,
            body
          });
        }
      };
    }
    var lastBlockCodec = t.type({
      last: t.type({
        seqno: t.number,
        shard: t.string,
        workchain: t.number,
        fileHash: t.string,
        rootHash: t.string
      }),
      init: t.type({
        fileHash: t.string,
        rootHash: t.string
      }),
      stateRootHash: t.string,
      now: t.number
    });
    var blockCodec = t.union([t.type({
      exist: t.literal(false)
    }), t.type({
      exist: t.literal(true),
      block: t.type({
        shards: t.array(t.type({
          workchain: t.number,
          seqno: t.number,
          shard: t.string,
          rootHash: t.string,
          fileHash: t.string,
          transactions: t.array(t.type({
            account: t.string,
            hash: t.string,
            lt: t.string
          }))
        }))
      })
    })]);
    var storageStatCodec = t.type({
      lastPaid: t.number,
      duePayment: t.union([t.null, t.string]),
      used: t.type({
        bits: t.number,
        cells: t.number,
        publicCells: t.number
      })
    });
    var accountCodec = t.type({
      account: t.type({
        state: t.union([
          t.type({ type: t.literal("uninit") }),
          t.type({ type: t.literal("active"), code: t.union([t.string, t.null]), data: t.union([t.string, t.null]) }),
          t.type({ type: t.literal("frozen"), stateHash: t.string })
        ]),
        balance: t.type({
          coins: t.string
        }),
        last: t.union([
          t.null,
          t.type({
            lt: t.string,
            hash: t.string
          })
        ]),
        storageStat: t.union([t.null, storageStatCodec])
      }),
      block: t.type({
        workchain: t.number,
        seqno: t.number,
        shard: t.string,
        rootHash: t.string,
        fileHash: t.string
      })
    });
    var accountLiteCodec = t.type({
      account: t.type({
        state: t.union([
          t.type({ type: t.literal("uninit") }),
          t.type({ type: t.literal("active"), codeHash: t.string, dataHash: t.string }),
          t.type({ type: t.literal("frozen"), stateHash: t.string })
        ]),
        balance: t.type({
          coins: t.string
        }),
        last: t.union([
          t.null,
          t.type({
            lt: t.string,
            hash: t.string
          })
        ]),
        storageStat: t.union([t.null, storageStatCodec])
      })
    });
    var changedCodec = t.type({
      changed: t.boolean,
      block: t.type({
        workchain: t.number,
        seqno: t.number,
        shard: t.string,
        rootHash: t.string,
        fileHash: t.string
      })
    });
    var runMethodCodec = t.type({
      exitCode: t.number,
      resultRaw: t.union([t.string, t.null]),
      block: t.type({
        workchain: t.number,
        seqno: t.number,
        shard: t.string,
        rootHash: t.string,
        fileHash: t.string
      }),
      shardBlock: t.type({
        workchain: t.number,
        seqno: t.number,
        shard: t.string,
        rootHash: t.string,
        fileHash: t.string
      })
    });
    var configCodec = t.type({
      config: t.type({
        cell: t.string,
        address: t.string,
        globalBalance: t.type({
          coins: t.string
        })
      })
    });
    var sendCodec = t.type({
      status: t.number
    });
    var transactionsCodec = t.type({
      blocks: t.array(t.type({
        workchain: t.number,
        seqno: t.number,
        shard: t.string,
        rootHash: t.string,
        fileHash: t.string
      })),
      boc: t.string
    });
    var transactionCodec = t.type({
      block: t.type({
        workchain: t.number,
        seqno: t.number,
        shard: t.string,
        rootHash: t.string
      }),
      boc: t.string,
      proof: t.string
    });
  }
});

// node_modules/ton/dist/wallets/signing/createWalletTransfer.js
var require_createWalletTransfer = __commonJS({
  "node_modules/ton/dist/wallets/signing/createWalletTransfer.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createWalletTransferV4 = exports.createWalletTransferV3 = exports.createWalletTransferV2 = exports.createWalletTransferV1 = void 0;
    var ton_core_1 = require_dist2();
    var ton_crypto_1 = require_dist();
    function createWalletTransferV1(args) {
      let signingMessage = (0, ton_core_1.beginCell)().storeUint(args.seqno, 32);
      if (args.message) {
        signingMessage.storeUint(args.sendMode, 8);
        signingMessage.storeRef((0, ton_core_1.beginCell)().store((0, ton_core_1.storeMessageRelaxed)(args.message)));
      }
      let signature = (0, ton_crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey);
      const body = (0, ton_core_1.beginCell)().storeBuffer(signature).storeBuilder(signingMessage).endCell();
      return body;
    }
    exports.createWalletTransferV1 = createWalletTransferV1;
    function createWalletTransferV2(args) {
      if (args.messages.length > 4) {
        throw Error("Maximum number of messages in a single transfer is 4");
      }
      let signingMessage = (0, ton_core_1.beginCell)().storeUint(args.seqno, 32);
      if (args.seqno === 0) {
        for (let i = 0; i < 32; i++) {
          signingMessage.storeBit(1);
        }
      } else {
        signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
      }
      for (let m of args.messages) {
        signingMessage.storeUint(args.sendMode, 8);
        signingMessage.storeRef((0, ton_core_1.beginCell)().store((0, ton_core_1.storeMessageRelaxed)(m)));
      }
      let signature = (0, ton_crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey);
      const body = (0, ton_core_1.beginCell)().storeBuffer(signature).storeBuilder(signingMessage).endCell();
      return body;
    }
    exports.createWalletTransferV2 = createWalletTransferV2;
    function createWalletTransferV3(args) {
      if (args.messages.length > 4) {
        throw Error("Maximum number of messages in a single transfer is 4");
      }
      let signingMessage = (0, ton_core_1.beginCell)().storeUint(args.walletId, 32);
      if (args.seqno === 0) {
        for (let i = 0; i < 32; i++) {
          signingMessage.storeBit(1);
        }
      } else {
        signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
      }
      signingMessage.storeUint(args.seqno, 32);
      for (let m of args.messages) {
        signingMessage.storeUint(args.sendMode, 8);
        signingMessage.storeRef((0, ton_core_1.beginCell)().store((0, ton_core_1.storeMessageRelaxed)(m)));
      }
      let signature = (0, ton_crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey);
      const body = (0, ton_core_1.beginCell)().storeBuffer(signature).storeBuilder(signingMessage).endCell();
      return body;
    }
    exports.createWalletTransferV3 = createWalletTransferV3;
    function createWalletTransferV4(args) {
      if (args.messages.length > 4) {
        throw Error("Maximum number of messages in a single transfer is 4");
      }
      let signingMessage = (0, ton_core_1.beginCell)().storeUint(args.walletId, 32);
      if (args.seqno === 0) {
        for (let i = 0; i < 32; i++) {
          signingMessage.storeBit(1);
        }
      } else {
        signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
      }
      signingMessage.storeUint(args.seqno, 32);
      signingMessage.storeUint(0, 8);
      for (let m of args.messages) {
        signingMessage.storeUint(args.sendMode, 8);
        signingMessage.storeRef((0, ton_core_1.beginCell)().store((0, ton_core_1.storeMessageRelaxed)(m)));
      }
      let signature = (0, ton_crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey);
      const body = (0, ton_core_1.beginCell)().storeBuffer(signature).storeBuilder(signingMessage).endCell();
      return body;
    }
    exports.createWalletTransferV4 = createWalletTransferV4;
  }
});

// node_modules/ton/dist/wallets/WalletContractV1R1.js
var require_WalletContractV1R1 = __commonJS({
  "node_modules/ton/dist/wallets/WalletContractV1R1.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletContractV1R1 = void 0;
    var ton_core_1 = require_dist2();
    var createWalletTransfer_1 = require_createWalletTransfer();
    var WalletContractV1R1 = class {
      constructor(workchain, publicKey) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        let code = ton_core_1.Cell.fromBoc(import_buffer.Buffer.from("te6cckEBAQEARAAAhP8AIN2k8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVEH98Ik=", "base64"))[0];
        let data = (0, ton_core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
        this.init = { code, data };
        this.address = (0, ton_core_1.contractAddress)(workchain, { code, data });
      }
      static create(args) {
        return new WalletContractV1R1(args.workchain, args.publicKey);
      }
      /**
       * Get Wallet Balance
       */
      async getBalance(provider) {
        let state = await provider.getState();
        return state.balance;
      }
      /**
       * Get Wallet Seqno
       */
      async getSeqno(provider) {
        let state = await provider.getState();
        if (state.state.type === "active") {
          return ton_core_1.Cell.fromBoc(state.state.data)[0].beginParse().loadUint(32);
        } else {
          return 0;
        }
      }
      /**
       * Send signed transfer
       */
      async send(provider, message) {
        await provider.external(message);
      }
      /**
       * Sign and send transfer
       */
      async sendTransfer(provider, args) {
        let transfer = this.createTransfer(args);
        await this.send(provider, transfer);
      }
      /**
       * Create signed transfer
       */
      createTransfer(args) {
        let sendMode = ton_core_1.SendMode.PAY_GAS_SEPARATELY;
        if (args.sendMode !== null && args.sendMode !== void 0) {
          sendMode = args.sendMode;
        }
        return (0, createWalletTransfer_1.createWalletTransferV1)({
          seqno: args.seqno,
          sendMode,
          secretKey: args.secretKey,
          message: args.message
        });
      }
      /**
       * Create sender
       */
      sender(provider, secretKey) {
        return {
          send: async (args) => {
            let seqno = await this.getSeqno(provider);
            let transfer = this.createTransfer({
              seqno,
              secretKey,
              sendMode: args.sendMode,
              message: (0, ton_core_1.internal)({
                to: args.to,
                value: args.value,
                init: args.init,
                body: args.body,
                bounce: args.bounce
              })
            });
            await this.send(provider, transfer);
          }
        };
      }
    };
    exports.WalletContractV1R1 = WalletContractV1R1;
  }
});

// node_modules/ton/dist/wallets/WalletContractV1R2.js
var require_WalletContractV1R2 = __commonJS({
  "node_modules/ton/dist/wallets/WalletContractV1R2.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletContractV1R2 = void 0;
    var ton_core_1 = require_dist2();
    var createWalletTransfer_1 = require_createWalletTransfer();
    var WalletContractV1R2 = class {
      constructor(workchain, publicKey) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        let code = ton_core_1.Cell.fromBoc(import_buffer.Buffer.from("te6cckEBAQEAUwAAov8AIN0gggFMl7qXMO1E0NcLH+Ck8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVNDieG8=", "base64"))[0];
        let data = (0, ton_core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
        this.init = { code, data };
        this.address = (0, ton_core_1.contractAddress)(workchain, { code, data });
      }
      static create(args) {
        return new WalletContractV1R2(args.workchain, args.publicKey);
      }
      /**
       * Get Wallet Balance
       */
      async getBalance(provider) {
        let state = await provider.getState();
        return state.balance;
      }
      /**
       * Get Wallet Seqno
       */
      async getSeqno(provider) {
        let state = await provider.getState();
        if (state.state.type === "active") {
          let res = await provider.get("seqno", []);
          return res.stack.readNumber();
        } else {
          return 0;
        }
      }
      /**
       * Send signed transfer
       */
      async send(provider, message) {
        await provider.external(message);
      }
      /**
       * Sign and send transfer
       */
      async sendTransfer(provider, args) {
        let transfer = this.createTransfer(args);
        await this.send(provider, transfer);
      }
      /**
       * Create signed transfer
       */
      createTransfer(args) {
        let sendMode = ton_core_1.SendMode.PAY_GAS_SEPARATELY;
        if (args.sendMode !== null && args.sendMode !== void 0) {
          sendMode = args.sendMode;
        }
        return (0, createWalletTransfer_1.createWalletTransferV1)({
          seqno: args.seqno,
          sendMode,
          secretKey: args.secretKey,
          message: args.message
        });
      }
      /**
       * Create sender
       */
      sender(provider, secretKey) {
        return {
          send: async (args) => {
            let seqno = await this.getSeqno(provider);
            let transfer = this.createTransfer({
              seqno,
              secretKey,
              sendMode: args.sendMode,
              message: (0, ton_core_1.internal)({
                to: args.to,
                value: args.value,
                init: args.init,
                body: args.body,
                bounce: args.bounce
              })
            });
            await this.send(provider, transfer);
          }
        };
      }
    };
    exports.WalletContractV1R2 = WalletContractV1R2;
  }
});

// node_modules/ton/dist/wallets/WalletContractV1R3.js
var require_WalletContractV1R3 = __commonJS({
  "node_modules/ton/dist/wallets/WalletContractV1R3.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletContractV1R3 = void 0;
    var ton_core_1 = require_dist2();
    var createWalletTransfer_1 = require_createWalletTransfer();
    var WalletContractV1R3 = class {
      constructor(workchain, publicKey) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        let code = ton_core_1.Cell.fromBoc(import_buffer.Buffer.from("te6cckEBAQEAXwAAuv8AIN0gggFMl7ohggEznLqxnHGw7UTQ0x/XC//jBOCk8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVLW4bkI=", "base64"))[0];
        let data = (0, ton_core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
        this.init = { code, data };
        this.address = (0, ton_core_1.contractAddress)(workchain, { code, data });
      }
      static create(args) {
        return new WalletContractV1R3(args.workchain, args.publicKey);
      }
      /**
       * Get Wallet Balance
       */
      async getBalance(provider) {
        let state = await provider.getState();
        return state.balance;
      }
      /**
       * Get Wallet Seqno
       */
      async getSeqno(provider) {
        let state = await provider.getState();
        if (state.state.type === "active") {
          let res = await provider.get("seqno", []);
          return res.stack.readNumber();
        } else {
          return 0;
        }
      }
      /**
       * Send signed transfer
       */
      async send(executor, message) {
        await executor.external(message);
      }
      /**
       * Sign and send transfer
       */
      async sendTransfer(provider, args) {
        let transfer = this.createTransfer(args);
        await this.send(provider, transfer);
      }
      /**
       * Create signed transfer
       */
      createTransfer(args) {
        let sendMode = ton_core_1.SendMode.PAY_GAS_SEPARATELY;
        if (args.sendMode !== null && args.sendMode !== void 0) {
          sendMode = args.sendMode;
        }
        return (0, createWalletTransfer_1.createWalletTransferV1)({
          seqno: args.seqno,
          sendMode,
          secretKey: args.secretKey,
          message: args.message
        });
      }
      /**
       * Create sender
       */
      sender(provider, secretKey) {
        return {
          send: async (args) => {
            let seqno = await this.getSeqno(provider);
            let transfer = this.createTransfer({
              seqno,
              secretKey,
              sendMode: args.sendMode,
              message: (0, ton_core_1.internal)({
                to: args.to,
                value: args.value,
                init: args.init,
                body: args.body,
                bounce: args.bounce
              })
            });
            await this.send(provider, transfer);
          }
        };
      }
    };
    exports.WalletContractV1R3 = WalletContractV1R3;
  }
});

// node_modules/ton/dist/wallets/WalletContractV2R1.js
var require_WalletContractV2R1 = __commonJS({
  "node_modules/ton/dist/wallets/WalletContractV2R1.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletContractV2R1 = void 0;
    var ton_core_1 = require_dist2();
    var createWalletTransfer_1 = require_createWalletTransfer();
    var WalletContractV2R1 = class {
      constructor(workchain, publicKey) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        let code = ton_core_1.Cell.fromBoc(import_buffer.Buffer.from("te6cckEBAQEAVwAAqv8AIN0gggFMl7qXMO1E0NcLH+Ck8mCDCNcYINMf0x8B+CO78mPtRNDTH9P/0VExuvKhA/kBVBBC+RDyovgAApMg10qW0wfUAvsA6NGkyMsfy//J7VShNwu2", "base64"))[0];
        let data = (0, ton_core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
        this.init = { code, data };
        this.address = (0, ton_core_1.contractAddress)(workchain, { code, data });
      }
      static create(args) {
        return new WalletContractV2R1(args.workchain, args.publicKey);
      }
      /**
       * Get Wallet Balance
       */
      async getBalance(provider) {
        let state = await provider.getState();
        return state.balance;
      }
      /**
       * Get Wallet Seqno
       */
      async getSeqno(provider) {
        let state = await provider.getState();
        if (state.state.type === "active") {
          let res = await provider.get("seqno", []);
          return res.stack.readNumber();
        } else {
          return 0;
        }
      }
      /**
       * Send signed transfer
       */
      async send(provider, message) {
        await provider.external(message);
      }
      /**
       * Sign and send transfer
       */
      async sendTransfer(provider, args) {
        let transfer = this.createTransfer(args);
        await this.send(provider, transfer);
      }
      /**
       * Create signed transfer
       */
      createTransfer(args) {
        let sendMode = ton_core_1.SendMode.PAY_GAS_SEPARATELY;
        if (args.sendMode !== null && args.sendMode !== void 0) {
          sendMode = args.sendMode;
        }
        return (0, createWalletTransfer_1.createWalletTransferV2)({
          seqno: args.seqno,
          sendMode,
          secretKey: args.secretKey,
          messages: args.messages,
          timeout: args.timeout
        });
      }
      /**
       * Create sender
       */
      sender(provider, secretKey) {
        return {
          send: async (args) => {
            let seqno = await this.getSeqno(provider);
            let transfer = this.createTransfer({
              seqno,
              secretKey,
              sendMode: args.sendMode,
              messages: [(0, ton_core_1.internal)({
                to: args.to,
                value: args.value,
                init: args.init,
                body: args.body,
                bounce: args.bounce
              })]
            });
            await this.send(provider, transfer);
          }
        };
      }
    };
    exports.WalletContractV2R1 = WalletContractV2R1;
  }
});

// node_modules/ton/dist/wallets/WalletContractV2R2.js
var require_WalletContractV2R2 = __commonJS({
  "node_modules/ton/dist/wallets/WalletContractV2R2.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletContractV2R2 = void 0;
    var ton_core_1 = require_dist2();
    var createWalletTransfer_1 = require_createWalletTransfer();
    var WalletContractV2R2 = class {
      constructor(workchain, publicKey) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        let code = ton_core_1.Cell.fromBoc(import_buffer.Buffer.from("te6cckEBAQEAYwAAwv8AIN0gggFMl7ohggEznLqxnHGw7UTQ0x/XC//jBOCk8mCDCNcYINMf0x8B+CO78mPtRNDTH9P/0VExuvKhA/kBVBBC+RDyovgAApMg10qW0wfUAvsA6NGkyMsfy//J7VQETNeh", "base64"))[0];
        let data = (0, ton_core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
        this.init = { code, data };
        this.address = (0, ton_core_1.contractAddress)(workchain, { code, data });
      }
      static create(args) {
        return new WalletContractV2R2(args.workchain, args.publicKey);
      }
      /**
       * Get Wallet Balance
       */
      async getBalance(provider) {
        let state = await provider.getState();
        return state.balance;
      }
      /**
       * Get Wallet Seqno
       */
      async getSeqno(provider) {
        let state = await provider.getState();
        if (state.state.type === "active") {
          let res = await provider.get("seqno", []);
          return res.stack.readNumber();
        } else {
          return 0;
        }
      }
      /**
       * Send signed transfer
       */
      async send(provider, message) {
        await provider.external(message);
      }
      /**
       * Sign and send transfer
       */
      async sendTransfer(provider, args) {
        let transfer = this.createTransfer(args);
        await this.send(provider, transfer);
      }
      /**
       * Create signed transfer
       */
      createTransfer(args) {
        let sendMode = ton_core_1.SendMode.PAY_GAS_SEPARATELY;
        if (args.sendMode !== null && args.sendMode !== void 0) {
          sendMode = args.sendMode;
        }
        return (0, createWalletTransfer_1.createWalletTransferV2)({
          seqno: args.seqno,
          sendMode,
          secretKey: args.secretKey,
          messages: args.messages,
          timeout: args.timeout
        });
      }
      /**
       * Create sender
       */
      sender(provider, secretKey) {
        return {
          send: async (args) => {
            let seqno = await this.getSeqno(provider);
            let transfer = this.createTransfer({
              seqno,
              secretKey,
              sendMode: args.sendMode,
              messages: [(0, ton_core_1.internal)({
                to: args.to,
                value: args.value,
                init: args.init,
                body: args.body,
                bounce: args.bounce
              })]
            });
            await this.send(provider, transfer);
          }
        };
      }
    };
    exports.WalletContractV2R2 = WalletContractV2R2;
  }
});

// node_modules/ton/dist/wallets/WalletContractV3R1.js
var require_WalletContractV3R1 = __commonJS({
  "node_modules/ton/dist/wallets/WalletContractV3R1.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletContractV3R1 = void 0;
    var ton_core_1 = require_dist2();
    var createWalletTransfer_1 = require_createWalletTransfer();
    var WalletContractV3R1 = class {
      constructor(workchain, publicKey, walletId) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        if (walletId !== null && walletId !== void 0) {
          this.walletId = walletId;
        } else {
          this.walletId = 698983191 + workchain;
        }
        let code = ton_core_1.Cell.fromBoc(import_buffer.Buffer.from("te6cckEBAQEAYgAAwP8AIN0gggFMl7qXMO1E0NcLH+Ck8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVD++buA=", "base64"))[0];
        let data = (0, ton_core_1.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(publicKey).endCell();
        this.init = { code, data };
        this.address = (0, ton_core_1.contractAddress)(workchain, { code, data });
      }
      static create(args) {
        return new WalletContractV3R1(args.workchain, args.publicKey, args.walletId);
      }
      /**
       * Get wallet balance
       */
      async getBalance(provider) {
        let state = await provider.getState();
        return state.balance;
      }
      /**
       * Get Wallet Seqno
       */
      async getSeqno(provider) {
        let state = await provider.getState();
        if (state.state.type === "active") {
          let res = await provider.get("seqno", []);
          return res.stack.readNumber();
        } else {
          return 0;
        }
      }
      /**
       * Send signed transfer
       */
      async send(provider, message) {
        await provider.external(message);
      }
      /**
       * Sign and send transfer
       */
      async sendTransfer(provider, args) {
        let transfer = this.createTransfer(args);
        await this.send(provider, transfer);
      }
      /**
       * Create transfer
       */
      createTransfer(args) {
        let sendMode = ton_core_1.SendMode.PAY_GAS_SEPARATELY;
        if (args.sendMode !== null && args.sendMode !== void 0) {
          sendMode = args.sendMode;
        }
        return (0, createWalletTransfer_1.createWalletTransferV3)({
          seqno: args.seqno,
          sendMode,
          secretKey: args.secretKey,
          messages: args.messages,
          timeout: args.timeout,
          walletId: this.walletId
        });
      }
      /**
       * Create sender
       */
      sender(provider, secretKey) {
        return {
          send: async (args) => {
            let seqno = await this.getSeqno(provider);
            let transfer = this.createTransfer({
              seqno,
              secretKey,
              sendMode: args.sendMode,
              messages: [(0, ton_core_1.internal)({
                to: args.to,
                value: args.value,
                init: args.init,
                body: args.body,
                bounce: args.bounce
              })]
            });
            await this.send(provider, transfer);
          }
        };
      }
    };
    exports.WalletContractV3R1 = WalletContractV3R1;
  }
});

// node_modules/ton/dist/wallets/WalletContractV3R2.js
var require_WalletContractV3R2 = __commonJS({
  "node_modules/ton/dist/wallets/WalletContractV3R2.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletContractV3R2 = void 0;
    var ton_core_1 = require_dist2();
    var createWalletTransfer_1 = require_createWalletTransfer();
    var WalletContractV3R2 = class {
      constructor(workchain, publicKey, walletId) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        if (walletId !== null && walletId !== void 0) {
          this.walletId = walletId;
        } else {
          this.walletId = 698983191 + workchain;
        }
        let code = ton_core_1.Cell.fromBoc(import_buffer.Buffer.from("te6cckEBAQEAcQAA3v8AIN0gggFMl7ohggEznLqxn3Gw7UTQ0x/THzHXC//jBOCk8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVBC9ba0=", "base64"))[0];
        let data = (0, ton_core_1.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(publicKey).endCell();
        this.init = { code, data };
        this.address = (0, ton_core_1.contractAddress)(workchain, { code, data });
      }
      static create(args) {
        return new WalletContractV3R2(args.workchain, args.publicKey, args.walletId);
      }
      /**
       * Get wallet balance
       */
      async getBalance(provider) {
        let state = await provider.getState();
        return state.balance;
      }
      /**
       * Get Wallet Seqno
       */
      async getSeqno(provider) {
        let state = await provider.getState();
        if (state.state.type === "active") {
          let res = await provider.get("seqno", []);
          return res.stack.readNumber();
        } else {
          return 0;
        }
      }
      /**
       * Send signed transfer
       */
      async send(provider, message) {
        await provider.external(message);
      }
      /**
       * Sign and send transfer
       */
      async sendTransfer(provider, args) {
        let transfer = this.createTransfer(args);
        await this.send(provider, transfer);
      }
      /**
       * Create transfer
       */
      createTransfer(args) {
        let sendMode = ton_core_1.SendMode.PAY_GAS_SEPARATELY;
        if (args.sendMode !== null && args.sendMode !== void 0) {
          sendMode = args.sendMode;
        }
        return (0, createWalletTransfer_1.createWalletTransferV3)({
          seqno: args.seqno,
          sendMode,
          secretKey: args.secretKey,
          messages: args.messages,
          timeout: args.timeout,
          walletId: this.walletId
        });
      }
      /**
       * Create sender
       */
      sender(provider, secretKey) {
        return {
          send: async (args) => {
            let seqno = await this.getSeqno(provider);
            let transfer = this.createTransfer({
              seqno,
              secretKey,
              sendMode: args.sendMode,
              messages: [(0, ton_core_1.internal)({
                to: args.to,
                value: args.value,
                init: args.init,
                body: args.body,
                bounce: args.bounce
              })]
            });
            await this.send(provider, transfer);
          }
        };
      }
    };
    exports.WalletContractV3R2 = WalletContractV3R2;
  }
});

// node_modules/ton/dist/wallets/WalletContractV4.js
var require_WalletContractV4 = __commonJS({
  "node_modules/ton/dist/wallets/WalletContractV4.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletContractV4 = void 0;
    var ton_core_1 = require_dist2();
    var createWalletTransfer_1 = require_createWalletTransfer();
    var WalletContractV4 = class {
      constructor(workchain, publicKey, walletId) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        if (walletId !== null && walletId !== void 0) {
          this.walletId = walletId;
        } else {
          this.walletId = 698983191 + workchain;
        }
        let code = ton_core_1.Cell.fromBoc(import_buffer.Buffer.from("te6ccgECFAEAAtQAART/APSkE/S88sgLAQIBIAIDAgFIBAUE+PKDCNcYINMf0x/THwL4I7vyZO1E0NMf0x/T//QE0VFDuvKhUVG68qIF+QFUEGT5EPKj+AAkpMjLH1JAyx9SMMv/UhD0AMntVPgPAdMHIcAAn2xRkyDXSpbTB9QC+wDoMOAhwAHjACHAAuMAAcADkTDjDQOkyMsfEssfy/8QERITAubQAdDTAyFxsJJfBOAi10nBIJJfBOAC0x8hghBwbHVnvSKCEGRzdHK9sJJfBeAD+kAwIPpEAcjKB8v/ydDtRNCBAUDXIfQEMFyBAQj0Cm+hMbOSXwfgBdM/yCWCEHBsdWe6kjgw4w0DghBkc3RyupJfBuMNBgcCASAICQB4AfoA9AQw+CdvIjBQCqEhvvLgUIIQcGx1Z4MesXCAGFAEywUmzxZY+gIZ9ADLaRfLH1Jgyz8gyYBA+wAGAIpQBIEBCPRZMO1E0IEBQNcgyAHPFvQAye1UAXKwjiOCEGRzdHKDHrFwgBhQBcsFUAPPFiP6AhPLassfyz/JgED7AJJfA+ICASAKCwBZvSQrb2omhAgKBrkPoCGEcNQICEekk30pkQzmkD6f+YN4EoAbeBAUiYcVnzGEAgFYDA0AEbjJftRNDXCx+AA9sp37UTQgQFA1yH0BDACyMoHy//J0AGBAQj0Cm+hMYAIBIA4PABmtznaiaEAga5Drhf/AABmvHfaiaEAQa5DrhY/AAG7SB/oA1NQi+QAFyMoHFcv/ydB3dIAYyMsFywIizxZQBfoCFMtrEszMyXP7AMhAFIEBCPRR8qcCAHCBAQjXGPoA0z/IVCBHgQEI9FHyp4IQbm90ZXB0gBjIywXLAlAGzxZQBPoCFMtqEssfyz/Jc/sAAgBsgQEI1xj6ANM/MFIkgQEI9Fnyp4IQZHN0cnB0gBjIywXLAlAFzxZQA/oCE8tqyx8Syz/Jc/sAAAr0AMntVA==", "base64"))[0];
        let data = (0, ton_core_1.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(this.publicKey).storeBit(0).endCell();
        this.init = { code, data };
        this.address = (0, ton_core_1.contractAddress)(workchain, { code, data });
      }
      static create(args) {
        return new WalletContractV4(args.workchain, args.publicKey, args.walletId);
      }
      /**
       * Get Wallet Balance
       */
      async getBalance(provider) {
        let state = await provider.getState();
        return state.balance;
      }
      /**
       * Get Wallet Seqno
       */
      async getSeqno(provider) {
        let state = await provider.getState();
        if (state.state.type === "active") {
          let res = await provider.get("seqno", []);
          return res.stack.readNumber();
        } else {
          return 0;
        }
      }
      /**
       * Send signed transfer
       */
      async send(provider, message) {
        await provider.external(message);
      }
      /**
       * Sign and send transfer
       */
      async sendTransfer(provider, args) {
        let transfer = this.createTransfer(args);
        await this.send(provider, transfer);
      }
      /**
       * Create signed transfer
       */
      createTransfer(args) {
        let sendMode = ton_core_1.SendMode.PAY_GAS_SEPARATELY;
        if (args.sendMode !== null && args.sendMode !== void 0) {
          sendMode = args.sendMode;
        }
        return (0, createWalletTransfer_1.createWalletTransferV4)({
          seqno: args.seqno,
          sendMode,
          secretKey: args.secretKey,
          messages: args.messages,
          timeout: args.timeout,
          walletId: this.walletId
        });
      }
      /**
       * Create sender
       */
      sender(provider, secretKey) {
        return {
          send: async (args) => {
            let seqno = await this.getSeqno(provider);
            let transfer = this.createTransfer({
              seqno,
              secretKey,
              sendMode: args.sendMode,
              messages: [(0, ton_core_1.internal)({
                to: args.to,
                value: args.value,
                init: args.init,
                body: args.body,
                bounce: args.bounce
              })]
            });
            await this.send(provider, transfer);
          }
        };
      }
    };
    exports.WalletContractV4 = WalletContractV4;
  }
});

// node_modules/ton/dist/jetton/JettonMaster.js
var require_JettonMaster = __commonJS({
  "node_modules/ton/dist/jetton/JettonMaster.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JettonMaster = void 0;
    var ton_core_1 = require_dist2();
    var JettonMaster = class {
      constructor(address) {
        this.address = address;
      }
      static create(address) {
        return new JettonMaster(address);
      }
      async getWalletAddress(provider, owner) {
        let res = await provider.get("get_wallet_address", [{ type: "slice", cell: (0, ton_core_1.beginCell)().storeAddress(owner).endCell() }]);
        return res.stack.readAddress();
      }
      async getJettonData(provider) {
        let res = await provider.get("get_jetton_data", []);
        let totalSupply = res.stack.readBigNumber();
        let mintable = res.stack.readBoolean();
        let adminAddress = res.stack.readAddress();
        let content = res.stack.readCell();
        let walletCode = res.stack.readCell();
        return {
          totalSupply,
          mintable,
          adminAddress,
          content,
          walletCode
        };
      }
    };
    exports.JettonMaster = JettonMaster;
  }
});

// node_modules/ton/dist/jetton/JettonWallet.js
var require_JettonWallet = __commonJS({
  "node_modules/ton/dist/jetton/JettonWallet.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JettonWallet = void 0;
    var JettonWallet = class {
      constructor(address) {
        this.address = address;
      }
      static create(address) {
        return new JettonWallet(address);
      }
      async getBalance(provider) {
        let state = await provider.getState();
        if (state.state.type !== "active") {
          return 0n;
        }
        let res = await provider.get("get_wallet_data", []);
        return res.stack.readBigNumber();
      }
    };
    exports.JettonWallet = JettonWallet;
  }
});

// node_modules/ton/dist/multisig/MultisigOrder.js
var require_MultisigOrder = __commonJS({
  "node_modules/ton/dist/multisig/MultisigOrder.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultisigOrder = void 0;
    var ton_crypto_1 = require_dist();
    var ton_core_1 = require_dist2();
    var MultisigOrder = class {
      constructor(payload) {
        this.signatures = {};
        this.payload = payload;
      }
      static fromCell(cell) {
        var _a;
        let s = cell.beginParse();
        let signatures = (_a = s.loadMaybeRef()) == null ? void 0 : _a.beginParse();
        const messagesCell = s.asCell();
        let order = new MultisigOrder(messagesCell);
        if (signatures) {
          while (signatures.remainingBits > 0) {
            const signature = signatures.loadBuffer(64);
            const ownerId = signatures.loadUint(8);
            order.signatures[ownerId] = signature;
            if (signatures.remainingRefs > 0) {
              signatures = signatures.loadRef().asSlice();
            } else {
              signatures.skip(1);
            }
          }
          signatures.endParse();
        }
        return order;
      }
      static fromPayload(payload) {
        return new MultisigOrder(payload);
      }
      addSignature(ownerId, signature, multisig) {
        const signingHash = this.payload.hash();
        if (!(0, ton_crypto_1.signVerify)(signingHash, signature, multisig.owners.get(ownerId).slice(0, -1))) {
          throw Error("invalid signature");
        }
        this.signatures[ownerId] = signature;
      }
      sign(ownerId, secretKey) {
        const signingHash = this.payload.hash();
        this.signatures[ownerId] = (0, ton_crypto_1.sign)(signingHash, secretKey);
        return signingHash;
      }
      unionSignatures(other) {
        this.signatures = Object.assign({}, this.signatures, other.signatures);
      }
      clearSignatures() {
        this.signatures = {};
      }
      toCell(ownerId) {
        let b = (0, ton_core_1.beginCell)().storeBit(0);
        for (const ownerId2 in this.signatures) {
          const signature = this.signatures[ownerId2];
          b = (0, ton_core_1.beginCell)().storeBit(1).storeRef((0, ton_core_1.beginCell)().storeBuffer(signature).storeUint(parseInt(ownerId2), 8).storeBuilder(b).endCell());
        }
        return (0, ton_core_1.beginCell)().storeUint(ownerId, 8).storeBuilder(b).storeBuilder(this.payload.asBuilder()).endCell();
      }
    };
    exports.MultisigOrder = MultisigOrder;
  }
});

// node_modules/ton/dist/multisig/MultisigOrderBuilder.js
var require_MultisigOrderBuilder = __commonJS({
  "node_modules/ton/dist/multisig/MultisigOrderBuilder.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultisigOrderBuilder = void 0;
    var ton_core_1 = require_dist2();
    var MultisigOrder_1 = require_MultisigOrder();
    var MultisigOrderBuilder = class {
      constructor(walletId, offset) {
        this.messages = (0, ton_core_1.beginCell)();
        this.queryId = 0n;
        this.walletId = walletId;
        this.queryOffset = offset || 7200;
      }
      addMessage(message, mode) {
        if (this.messages.refs >= 4) {
          throw Error("only 4 refs are allowed");
        }
        this.updateQueryId();
        this.messages.storeUint(mode, 8);
        this.messages.storeRef((0, ton_core_1.beginCell)().store((0, ton_core_1.storeMessageRelaxed)(message)).endCell());
      }
      clearMessages() {
        this.messages = (0, ton_core_1.beginCell)();
      }
      build() {
        return MultisigOrder_1.MultisigOrder.fromPayload((0, ton_core_1.beginCell)().storeUint(this.walletId, 32).storeUint(this.queryId, 64).storeBuilder(this.messages).endCell());
      }
      updateQueryId() {
        const time = BigInt(Math.floor(Date.now() / 1e3 + this.queryOffset));
        this.queryId = time << 32n;
      }
    };
    exports.MultisigOrderBuilder = MultisigOrderBuilder;
  }
});

// node_modules/ton/dist/multisig/MultisigWallet.js
var require_MultisigWallet = __commonJS({
  "node_modules/ton/dist/multisig/MultisigWallet.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultisigWallet = void 0;
    var ton_crypto_1 = require_dist();
    var ton_core_1 = require_dist2();
    var MULTISIG_CODE = ton_core_1.Cell.fromBase64("te6ccgECKwEABBgAART/APSkE/S88sgLAQIBIAIDAgFIBAUE2vIgxwCOgzDbPOCDCNcYIPkBAdMH2zwiwAAToVNxePQOb6Hyn9s8VBq6+RDyoAb0BCD5AQHTH1EYuvKq0z9wUwHwCgHCCAGDCryx8mhTFYBA9A5voSCYDqQgwgryZw7f+COqH1NAufJhVCOjU04gIyEiAgLMBgcCASAMDQIBIAgJAgFmCgsAA9GEAiPymAvHoHN9CYbZ5S7Z4BPHohwhJQAtAKkItdJEqCTItdKlwLUAdAT8ArobBKAATwhbpEx4CBukTDgAdAg10rDAJrUAvALyFjPFszJ4HHXI8gBzxb0AMmACASAODwIBIBQVARW77ZbVA0cFUg2zyCoCAUgQEQIBIBITAXOxHXQgwjXGCD5AQHTB4IB1MTtQ9hTIHj0Dm+h8p/XC/9eMfkQ8qCuAfQEIW6TW3Ey4PkBWNs8AaQBgJwA9rtqA6ADoAPoCAXoCEfyAgPyA3XlP+AXkegAA54tkwAAXrhlXP8EA1WZ2oexAAgEgFhcCASAYGQFRtyVbZ4YmRmpGEAgegc30McJNhFpAADMaYeYuAFrgJhwLb+4cC3d0bhAjAYm1WZtnhqvgb+2xxsoicAgej430pBHEoFpAADHDhBACGuQkuuBk9kUWE5kAOeLKhACQCB6IYFImHFImHFImXEA2YlzNijAjAgEgGhsAF7UGtc4QQDVZnah7EAIBIBwdAgOZOB4fARGsGm2eL4G2CUAjABWt+UEAzJV2oewYQAENqTbPBVfBYCMAFa3f3CCAarM7UPYgAiDbPALyZfgAUENxQxPbPO1UIyoACtP/0wcwBKDbPC+uUyCw8mISsQKkJbNTHLmwJYEA4aojoCi8sPJpggGGoPgBBZcCERACPj4wjo0REB/bPEDXePRDEL0F4lQWW1Rz51YQU9zbPFRxClR6vCQlKCYAIO1E0NMf0wfTB9M/9AT0BNEAXgGOGjDSAAHyo9MH0wdQA9cBIPkBBfkBFbrypFAD4GwhIddKqgIi10m68qtwVCATAAwByMv/ywcE1ts87VT4D3AlblOJvrGYEG4QLVDHXwePGzBUJANQTds8UFWgRlAQSRA6SwlTuds8UFQWf+L4AAeDJaGOLCaAQPSWb6UglDBTA7neII4WODk5CNIAAZfTBzAW8AcFkTDifwgHBZJsMeKz5jAGKicoKQBgcI4pA9CDCNcY0wf0BDBTFnj0Dm+h8qXXC/9URUT5EPKmrlIgsVIDvRShI27mbCIyAH5SML6OIF8D+ACTItdKmALTB9QC+wAC6DJwyMoAQBSAQPRDAvAHjhdxyMsAFMsHEssHWM8BWM8WQBOAQPRDAeIBII6KEEUQNEMA2zztVJJfBuIqABzIyx/LB8sHyz/0APQAyQ==");
    var MultisigWallet = class {
      constructor(publicKeys, workchain, walletId, k, opts) {
        this.provider = null;
        this.owners = ton_core_1.Dictionary.empty();
        this.workchain = workchain;
        this.walletId = walletId;
        this.k = k;
        for (let i = 0; i < publicKeys.length; i += 1) {
          this.owners.set(i, import_buffer.Buffer.concat([publicKeys[i], import_buffer.Buffer.alloc(1)]));
        }
        this.init = {
          code: MULTISIG_CODE,
          data: (0, ton_core_1.beginCell)().storeUint(this.walletId, 32).storeUint(this.owners.size, 8).storeUint(this.k, 8).storeUint(0, 64).storeDict(this.owners, ton_core_1.Dictionary.Keys.Uint(8), ton_core_1.Dictionary.Values.Buffer(33)).storeBit(0).endCell()
        };
        this.address = (opts == null ? void 0 : opts.address) || (0, ton_core_1.contractAddress)(workchain, this.init);
        if (opts == null ? void 0 : opts.provider) {
          this.provider = opts.provider;
        } else if (opts == null ? void 0 : opts.client) {
          this.provider = opts.client.provider(this.address, {
            code: this.init.code,
            data: this.init.data
          });
        }
      }
      static async fromAddress(address, opts) {
        let provider;
        if (opts.provider) {
          provider = opts.provider;
        } else {
          if (!opts.client) {
            throw Error("Either provider or client must be specified");
          }
          provider = opts.client.provider(address, {
            code: null,
            data: null
          });
        }
        const contractState = (await provider.getState()).state;
        if (contractState.type !== "active") {
          throw Error("Contract must be active");
        }
        const data = ton_core_1.Cell.fromBoc(contractState.data)[0].beginParse();
        const walletId = data.loadUint(32);
        data.skip(8);
        const k = data.loadUint(8);
        data.skip(64);
        const owners = data.loadDict(ton_core_1.Dictionary.Keys.Uint(8), ton_core_1.Dictionary.Values.Buffer(33));
        let publicKeys = [];
        for (const [key, value] of owners) {
          const publicKey = value.subarray(0, 32);
          publicKeys.push(publicKey);
        }
        return new MultisigWallet(publicKeys, address.workChain, walletId, k, {
          address,
          provider,
          client: opts.client
        });
      }
      async deployExternal(provider) {
        if (!provider && !this.provider) {
          throw Error("you must specify provider if there is no such property in MultisigWallet instance");
        }
        if (!provider) {
          provider = this.provider;
        }
        await provider.external(ton_core_1.Cell.EMPTY);
      }
      async deployInternal(sender, value = 1000000000n) {
        await sender.send({
          sendMode: 3,
          to: this.address,
          value,
          init: this.init,
          body: ton_core_1.Cell.EMPTY,
          bounce: true
        });
      }
      async sendOrder(order, secretKey, provider) {
        if (!provider && !this.provider) {
          throw Error("you must specify provider if there is no such property in MultisigWallet instance");
        }
        if (!provider) {
          provider = this.provider;
        }
        let publicKey = (0, ton_crypto_1.keyPairFromSecretKey)(secretKey).publicKey;
        let ownerId = this.getOwnerIdByPubkey(publicKey);
        let cell = order.toCell(ownerId);
        let signature = (0, ton_crypto_1.sign)(cell.hash(), secretKey);
        cell = (0, ton_core_1.beginCell)().storeBuffer(signature).storeSlice(cell.asSlice()).endCell();
        await provider.external(cell);
      }
      getOwnerIdByPubkey(publicKey) {
        for (const [key, value] of this.owners) {
          if (value.subarray(0, 32).equals(publicKey)) {
            return key;
          }
        }
        throw Error("public key is not an owner");
      }
    };
    exports.MultisigWallet = MultisigWallet;
  }
});

// node_modules/ton/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/ton/dist/index.js"(exports) {
    init_shim();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultisigWallet = exports.MultisigOrderBuilder = exports.MultisigOrder = exports.JettonWallet = exports.JettonMaster = exports.WalletContractV4 = exports.WalletContractV3R2 = exports.WalletContractV3R1 = exports.WalletContractV2R2 = exports.WalletContractV2R1 = exports.WalletContractV1R3 = exports.WalletContractV1R2 = exports.WalletContractV1R1 = exports.TonClient4 = exports.TonClient = exports.HttpApi = void 0;
    __exportStar(require_dist2(), exports);
    var HttpApi_1 = require_HttpApi();
    Object.defineProperty(exports, "HttpApi", { enumerable: true, get: function() {
      return HttpApi_1.HttpApi;
    } });
    var TonClient_1 = require_TonClient();
    Object.defineProperty(exports, "TonClient", { enumerable: true, get: function() {
      return TonClient_1.TonClient;
    } });
    var TonClient4_1 = require_TonClient4();
    Object.defineProperty(exports, "TonClient4", { enumerable: true, get: function() {
      return TonClient4_1.TonClient4;
    } });
    var WalletContractV1R1_1 = require_WalletContractV1R1();
    Object.defineProperty(exports, "WalletContractV1R1", { enumerable: true, get: function() {
      return WalletContractV1R1_1.WalletContractV1R1;
    } });
    var WalletContractV1R2_1 = require_WalletContractV1R2();
    Object.defineProperty(exports, "WalletContractV1R2", { enumerable: true, get: function() {
      return WalletContractV1R2_1.WalletContractV1R2;
    } });
    var WalletContractV1R3_1 = require_WalletContractV1R3();
    Object.defineProperty(exports, "WalletContractV1R3", { enumerable: true, get: function() {
      return WalletContractV1R3_1.WalletContractV1R3;
    } });
    var WalletContractV2R1_1 = require_WalletContractV2R1();
    Object.defineProperty(exports, "WalletContractV2R1", { enumerable: true, get: function() {
      return WalletContractV2R1_1.WalletContractV2R1;
    } });
    var WalletContractV2R2_1 = require_WalletContractV2R2();
    Object.defineProperty(exports, "WalletContractV2R2", { enumerable: true, get: function() {
      return WalletContractV2R2_1.WalletContractV2R2;
    } });
    var WalletContractV3R1_1 = require_WalletContractV3R1();
    Object.defineProperty(exports, "WalletContractV3R1", { enumerable: true, get: function() {
      return WalletContractV3R1_1.WalletContractV3R1;
    } });
    var WalletContractV3R2_1 = require_WalletContractV3R2();
    Object.defineProperty(exports, "WalletContractV3R2", { enumerable: true, get: function() {
      return WalletContractV3R2_1.WalletContractV3R2;
    } });
    var WalletContractV4_1 = require_WalletContractV4();
    Object.defineProperty(exports, "WalletContractV4", { enumerable: true, get: function() {
      return WalletContractV4_1.WalletContractV4;
    } });
    var JettonMaster_1 = require_JettonMaster();
    Object.defineProperty(exports, "JettonMaster", { enumerable: true, get: function() {
      return JettonMaster_1.JettonMaster;
    } });
    var JettonWallet_1 = require_JettonWallet();
    Object.defineProperty(exports, "JettonWallet", { enumerable: true, get: function() {
      return JettonWallet_1.JettonWallet;
    } });
    var MultisigOrder_1 = require_MultisigOrder();
    Object.defineProperty(exports, "MultisigOrder", { enumerable: true, get: function() {
      return MultisigOrder_1.MultisigOrder;
    } });
    var MultisigOrderBuilder_1 = require_MultisigOrderBuilder();
    Object.defineProperty(exports, "MultisigOrderBuilder", { enumerable: true, get: function() {
      return MultisigOrderBuilder_1.MultisigOrderBuilder;
    } });
    var MultisigWallet_1 = require_MultisigWallet();
    Object.defineProperty(exports, "MultisigWallet", { enumerable: true, get: function() {
      return MultisigWallet_1.MultisigWallet;
    } });
  }
});
export default require_dist3();
//# sourceMappingURL=ton.js.map
